{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "newhar",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/newhar/avatar_1599384911.png",
          "userSlug": "newhar"
        },
        "username": "newhar"
      },
      "byLeetcode": false,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "#### 切入点和解题思路\r\n\r\n1. 如果用蛮力检查一个节点的所有的祖先节点，那么，一个节点的祖先节点最多能有 $n-1$ 个，显然会超时的。\r\n2. 一个重要的切入点是： $\\text{nums}[i] \\leq 50$。我们不妨换一种思路：从节点的值 $x$ 出发，枚举满足 $1 \\leq y \\leq 50$ 且 $\\gcd(x,y) = 1$ 的 $y$，并对每个 $y$ 找出离着节点 $i$ 最近的点，最后再在这些点中求出离着当前点最近的点即可。这样只需检查 $50$ 次即可。\r\n3. 那么，如何对于任一数字 $y$，找出离当前节点 $i$ 最近的祖先节点呢？首先可以想到的是，离着节点 $i$ 最近的满足条件的祖先节点，也是这些点中 **最深** 的。我们不妨对每个数字 $1 \\sim 50$ 维护一个栈，并采用 dfs 的思路。每当我们要遍历下一个节点时，就把当前节点的编号 （$\\text{node}$）和节点的深度（$\\text{level}$）push 到 当前节点的值 （$x$） 对应的栈中。这样，栈顶就是数字 $x$ 的、最深 的节点，也是我们之后需要的关于数字 $x$ 的 最近 的节点。此外，要记得 dfs 完成后要将之前 push 进去的元素 pop 出来。\r\n\r\n#### 代码(c++)\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> G;\r\n    stack<pair<int,int>> lasts[55];\r\n    vector<int> res;\r\n    void dfs(int node, int pre, int level, vector<int>& a) {\r\n        int re = -1, lev = -1;\r\n        for(int i = 1; i <= 50; ++i) {\r\n            if(lasts[i].size() && lasts[i].top().first > lev && __gcd(i, a[node]) == 1) {\r\n                re = lasts[i].top().second;\r\n                lev = lasts[i].top().first;\r\n            }\r\n        }\r\n        res[node] = re;\r\n        for(int ne : G[node]) {\r\n            if(ne != pre) {\r\n                lasts[a[node]].push({level, node});\r\n                dfs(ne, node, level + 1, a);\r\n                lasts[a[node]].pop();\r\n            }\r\n        }\r\n    }\r\n    vector<int> getCoprimes(vector<int>& nums, vector<vector<int>>& edges) {\r\n        int n = nums.size();\r\n        G.resize(n);\r\n        for(auto& e : edges) {\r\n            G[e[0]].push_back(e[1]);\r\n            G[e[1]].push_back(e[0]);\r\n        }\r\n        res.resize(n);\r\n        dfs(0, -1, 0, nums);\r\n        return res;\r\n    }\r\n};\r\n```",
      "createdAt": "2021-02-20T16:10:00.132551+00:00",
      "hitCount": 1742,
      "identifier": "ohK7FE",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "bu-tai-yi-yang-de-dfs-ji-lu-suo-you-zui-d3xeu",
        "title": "【不太一样的 DFS】记录所有最近的互质节点"
      },
      "position": 2,
      "prev": {
        "__typename": "BriefSolutionNode",
        "slug": "guan-cha-ti-mu-gei-de-shu-ju-de-zhi-de-f-qkly",
        "title": "观察题目给的数据的值的范围"
      },
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "tree-of-coprimes"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 17,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 2,
          "reactionType": "CONFUSED"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 2,
          "reactionType": "AWESOME"
        }
      ],
      "rewardEnabled": null,
      "slug": "hu-zhi-shu-xiang-jie-ti-mu-de-qie-ru-dia-poyw",
      "status": "PREPUBLISH",
      "summary": "切入点和解题思路\n\n如果用蛮力检查一个节点的所有的祖先节点，那么，一个节点的祖先节点最多能有 n-1 个，显然会超时的。\n一个重要的切入点是： \\text{nums}[i] \\leq 50。我们不妨换一种思路：从节点的值 x 出发，枚举满足 1 \\leq y \\leq 50 且 \\gcd(x,y) = 1 的 y，并",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "【互质树】详解题目的切入点和思路",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 7,
        "id": 612606,
        "viewCount": 1171
      },
      "uuid": "ohK7FE",
      "videosInfo": []
    }
  }
}
