{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "zerotrac ğŸŒ¸",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/zerotrac2/avatar_1628749564.png",
          "userSlug": "zerotrac2"
        },
        "username": "zerotrac2"
      },
      "byLeetcode": false,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "#### å‰è¨€\n\nç”±äºæœ¬é¢˜æ˜¯ã€ŒåŠ›æ‰£æ¯ã€çš„ç«èµ›é¢˜ï¼Œå› æ­¤åªä¼šç»™å‡ºæç¤ºã€ç®€è¦æ€è·¯ä»¥åŠä»£ç ï¼Œä¸ä¼šå¯¹ç®—æ³•æœ¬èº«è¿›è¡Œè¯¦ç»†è¯´æ˜ï¼Œå¸Œæœ›è¯»è€…å¤šå¤šæ€è€ƒã€‚\n\n#### æ–¹æ³•ä¸€ï¼šæ‹†ç‚¹ + æœ€å°å‰²\n\n#### æç¤º $1$\n\næˆ‘ä»¬å¸Œæœ›ã€Œæ¶é­”ã€æ— æ³•åˆ°è¾¾åŸå ¡ï¼Œå³ã€ŒåŸå ¡ã€å’Œã€Œæ¶é­”ã€ä¹‹é—´ä¸è¿é€šï¼Œå¯¹åº”åˆ°å›¾è®ºæ¨¡å‹ä¸Šå°±æ˜¯ã€Œå‰²ã€é—®é¢˜ã€‚\n\n#### æ€è·¯\n\nä½¿ç”¨æœ€å°å‰²å»ºæ¨¡ï¼š\n\n- å°†æ¯ä¸€ä¸ªéã€Œéšœç¢ç‰©ã€çš„æ ¼å­æ‹†åˆ†æˆä¸¤ä¸ªç‚¹ï¼Œä¸€ä¸ªä½œä¸ºã€Œèµ·ç‚¹ã€ä¸€ä¸ªä½œä¸ºã€Œç»ˆç‚¹ã€ã€‚\n    - å¦‚æœè¯¥æ ¼å­æ˜¯ã€Œç©ºåœ°ã€ï¼Œè¿æ¥ä¸€æ¡æµé‡ä¸º $1$ çš„è¾¹ã€‚\n    - å¦åˆ™ï¼Œè¿æ¥ä¸€æ¡æµé‡ä¸º $\\infty$ çš„è¾¹ã€‚\n- ç›¸é‚»ä¸¤ä¸ªæ ¼å­ä¹‹é—´ï¼Œä»ä¸€ä¸ªæ ¼å­çš„ã€Œç»ˆç‚¹ã€åˆ°å¦ä¸€ä¸ªæ ¼å­çš„ã€Œèµ·ç‚¹ã€è¿æ¥ä¸€æ¡æµé‡ä¸º $\\infty$ çš„è¾¹ã€‚\n- å¯¹äºæ‰€æœ‰ã€Œä¼ é€é—¨ã€ï¼Œå®ƒä»¬çš„ã€Œç»ˆç‚¹ã€å‘ã€Œè¶…çº§ä¼ é€é—¨èŠ‚ç‚¹ã€è¿æ¥ä¸€æ¡æµé‡ä¸º $\\infty$ çš„è¾¹ï¼Œå¹¶ä»è¯¥èŠ‚ç‚¹è¿å›ã€Œèµ·ç‚¹ã€ä¸€æ¡æµé‡ä¸º $\\infty$ çš„è¾¹ã€‚\n- æ‰€æœ‰ã€Œæ¶é­”ã€çš„ã€Œç»ˆç‚¹ã€å‘ã€Œè¶…çº§æ¶é­”èŠ‚ç‚¹ã€è¿æ¥ä¸€æ¡æµé‡ä¸º $\\infty$ çš„è¾¹ã€‚\n\nä»¥ã€ŒåŸå ¡ã€çš„ã€Œèµ·ç‚¹ã€ä¸ºæºç‚¹ï¼Œã€Œè¶…çº§æ¶é­”èŠ‚ç‚¹ã€ä¸ºæ±‡ç‚¹ï¼Œæ±‚å‡ºæœ€å°å‰²ã€‚æ ¹æ®æœ€å°å‰²æœ€å¤§æµå®šç†ï¼Œæ±‚å‡ºæœ€å¤§æµå³å¯ã€‚å¦‚æœæœ€å¤§æµä¸º $\\infty$ï¼Œè¯´æ˜ç­”æ¡ˆä¸º $-1$ã€‚\n\n#### ä»£ç \n\nä¸‹é¢çš„æœ€å¤§æµæ¨¡æ¿å‚è€ƒè‡ª [AtCoder Library](https://github.com/atcoder/ac-library)ã€‚\n\n```C++ [sol1-C++]\nnamespace atcoder {\n\nnamespace internal {\n\ntemplate <class T> struct simple_queue {\n    std::vector<T> payload;\n    int pos = 0;\n    void reserve(int n) { payload.reserve(n); }\n    int size() const { return int(payload.size()) - pos; }\n    bool empty() const { return pos == int(payload.size()); }\n    void push(const T& t) { payload.push_back(t); }\n    T& front() { return payload[pos]; }\n    void clear() {\n        payload.clear();\n        pos = 0;\n    }\n    void pop() { pos++; }\n};\n\n}  // namespace internal\n\n}  // namespace atcoder\n\nnamespace atcoder {\n\ntemplate <class Cap> struct mf_graph {\n  public:\n    mf_graph() : _n(0) {}\n    explicit mf_graph(int n) : _n(n), g(n) {}\n\n    int add_edge(int from, int to, Cap cap) {\n        // printf(\"edge = %d %d %d\\n\", from, to, cap);\n        assert(0 <= from && from < _n);\n        assert(0 <= to && to < _n);\n        assert(0 <= cap);\n        int m = int(pos.size());\n        pos.push_back({from, int(g[from].size())});\n        int from_id = int(g[from].size());\n        int to_id = int(g[to].size());\n        if (from == to) to_id++;\n        g[from].push_back(_edge{to, to_id, cap});\n        g[to].push_back(_edge{from, from_id, 0});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n    };\n\n    edge get_edge(int i) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        auto _e = g[pos[i].first][pos[i].second];\n        auto _re = g[_e.to][_e.rev];\n        return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector<edge> edges() {\n        int m = int(pos.size());\n        std::vector<edge> result;\n        for (int i = 0; i < m; i++) {\n            result.push_back(get_edge(i));\n        }\n        return result;\n    }\n    void change_edge(int i, Cap new_cap, Cap new_flow) {\n        int m = int(pos.size());\n        assert(0 <= i && i < m);\n        assert(0 <= new_flow && new_flow <= new_cap);\n        auto& _e = g[pos[i].first][pos[i].second];\n        auto& _re = g[_e.to][_e.rev];\n        _e.cap = new_cap - new_flow;\n        _re.cap = new_flow;\n    }\n\n    Cap flow(int s, int t) {\n        return flow(s, t, std::numeric_limits<Cap>::max());\n    }\n    Cap flow(int s, int t, Cap flow_limit) {\n        assert(0 <= s && s < _n);\n        assert(0 <= t && t < _n);\n        assert(s != t);\n\n        std::vector<int> level(_n), iter(_n);\n        internal::simple_queue<int> que;\n\n        auto bfs = [&]() {\n            std::fill(level.begin(), level.end(), -1);\n            level[s] = 0;\n            que.clear();\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front();\n                que.pop();\n                for (auto e : g[v]) {\n                    if (e.cap == 0 || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if (e.to == t) return;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto dfs = [&](auto self, int v, Cap up) {\n            if (v == s) return up;\n            Cap res = 0;\n            int level_v = level[v];\n            for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                _edge& e = g[v][i];\n                if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                if (d <= 0) continue;\n                g[v][i].cap += d;\n                g[e.to][e.rev].cap -= d;\n                res += d;\n                if (res == up) return res;\n            }\n            level[v] = _n;\n            return res;\n        };\n\n        Cap flow = 0;\n        while (flow < flow_limit) {\n            bfs();\n            if (level[t] == -1) break;\n            std::fill(iter.begin(), iter.end(), 0);\n            Cap f = dfs(dfs, t, flow_limit - flow);\n            if (!f) break;\n            flow += f;\n        }\n        return flow;\n    }\n\n    std::vector<bool> min_cut(int s) {\n        std::vector<bool> visited(_n);\n        internal::simple_queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int p = que.front();\n            que.pop();\n            visited[p] = true;\n            for (auto e : g[p]) {\n                if (e.cap && !visited[e.to]) {\n                    visited[e.to] = true;\n                    que.push(e.to);\n                }\n            }\n        }\n        return visited;\n    }\n\n  private:\n    int _n;\n    struct _edge {\n        int to, rev;\n        Cap cap;\n    };\n    std::vector<std::pair<int, int>> pos;\n    std::vector<std::vector<_edge>> g;\n};\n\n}  // namespace atcoder\n\n\nclass Solution {\nprivate:\n    static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    static constexpr int INF = 20010;\n    \npublic:\n    int guardCastle(vector<string>& grid) {\n        int n = grid[0].size();\n        // extra point for collecting portals & demons\n        // portal=n*4, demons=n*4+1\n        atcoder::mf_graph<int> g(n * 4 + 2);\n        int sx = -1, sy = -1;\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int base_id = i * n + j;\n                if(grid[i][j]=='#') continue;\n                if (grid[i][j] == '.') {\n                    g.add_edge(base_id * 2, base_id * 2 + 1, 1);\n                }\n                else if (grid[i][j] == 'C') {\n                    g.add_edge(base_id * 2, base_id * 2 + 1, INF);\n                    sx = i;\n                    sy = j;\n                }\n                else if (grid[i][j] == 'S' || grid[i][j] == 'P') {\n                    g.add_edge(base_id * 2, base_id * 2 + 1, INF);\n                }\n                \n                if (grid[i][j] == 'S') {\n                    g.add_edge(base_id * 2 + 1, n * 4 + 1, INF);\n                }\n                if (grid[i][j] == 'P') {\n                    g.add_edge(base_id * 2 + 1, n * 4, INF);\n                    g.add_edge(n * 4, base_id * 2, INF);\n                }\n                for (int d = 0; d < 4; ++d) {\n                    int ii = i + dirs[d][0];\n                    int jj = j + dirs[d][1];\n                    if (ii >= 0 && ii < 2 && jj >= 0 && jj < n) {\n                        if (grid[ii][jj] == '#') {\n                            continue;\n                        }\n                        int case_id = ii * n + jj;\n                        g.add_edge(base_id * 2 + 1, case_id * 2, INF);\n                    }\n                }\n            }\n        }\n        \n        int ans = g.flow((sx * n + sy) * 2, n * 4 + 1);\n        if (ans == INF) {\n            ans = -1;\n        }\n        return ans;\n    }\n};\n```\n\n#### æ–¹æ³•äºŒï¼šåŠ¨æ€è§„åˆ’\n\n#### æç¤º $1$\n\nå¦‚æœã€Œæ¶é­”ã€èƒ½å¤Ÿèµ°åˆ°ã€Œä¼ é€é—¨ã€ï¼Œé‚£ä¹ˆã€Œæ¶é­”ã€å°±ä¼šæ”¯é…æ‰€æœ‰çš„ã€Œä¼ é€é—¨ã€ã€‚\nå› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘ä¸¤ç§æƒ…å†µï¼šå³å…è®¸ã€Œæ¶é­”ã€èµ°åˆ°ã€Œä¼ é€é—¨ã€ï¼Œæˆ–è€…ä¸å…è®¸ã€Œæ¶é­”ã€èµ°åˆ°ã€Œä¼ é€é—¨ã€ã€‚\n- å¯¹äºç¬¬ä¸€ç§æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰çš„ã€Œä¼ é€é—¨ã€å…¨éƒ¨çœ‹æˆã€Œæ¶é­”ã€ï¼›\n- å¯¹äºç¬¬äºŒç§æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰çš„ã€Œä¼ é€é—¨ã€å…¨éƒ¨çœ‹æˆã€ŒåŸå ¡ã€ã€‚\n\næ­¤æ—¶ï¼Œç½‘æ ¼ä¸­å°±åªæœ‰ã€ŒåŸå ¡ã€ã€Œæ¶é­”ã€ã€Œç©ºåœ°ã€ã€Œéšœç¢ç‰©ã€äº†ï¼Œæˆ‘ä»¬éœ€è¦åšçš„å°±æ˜¯æŠŠã€ŒåŸå ¡ã€å’Œã€Œæ¶é­”ã€ä¹‹é—´äº’ç›¸åˆ†å¼€ã€‚\n\n#### æç¤º $2$\n\nä½¿ç”¨ä¸¤æ¬¡åŠ¨æ€è§„åˆ’è§£å†³ä¸Šè¿°é—®é¢˜ï¼Œæ¯ä¸€æ¬¡åŠ¨æ€è§„åˆ’è€ƒè™‘ä¸€ç§æƒ…å†µã€‚\n\n#### æ€è·¯\n\nåœ¨åŠ¨æ€è§„åˆ’ä¹‹å‰ï¼ˆå°†ã€Œä¼ é€é—¨ã€æ›¿æ¢æˆã€Œæ¶é­”ã€æˆ–ã€ŒåŸå ¡ã€ä¹‹åï¼‰ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦åˆ¤æ–­ç½‘æ ¼ä¸­æ˜¯å¦æœ‰ç›¸é‚»çš„ã€ŒåŸå ¡ã€å’Œã€Œæ¶é­”ã€ã€‚å¦‚æœæœ‰ï¼Œé‚£ä¹ˆæ˜¾ç„¶æ˜¯æ— æ³•å°†å®ƒä»¬åˆ†å¼€çš„ï¼Œå› æ­¤æ— è§£ï¼›å¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆæŠŠæ‰€æœ‰çš„ã€Œç©ºåœ°ã€éƒ½æ”¾ä¸Šã€Œéšœç¢ç‰©ã€ï¼Œæ˜¾ç„¶å¯ä»¥å°†å®ƒä»¬åˆ†å¼€çš„ï¼Œå› æ­¤å­˜åœ¨è§£ã€‚\n\nç”¨ $f[i][s_1][s_2]$ è¡¨ç¤ºå½“å‰å¤„ç†åˆ°ç¬¬ $i$ åˆ—ï¼Œå¹¶ä¸”ç¬¬ $i$ åˆ—çš„ä¸¤ä¸ªæ ¼å­çš„çŠ¶æ€åˆ†åˆ«æ˜¯ $s_1$ å’Œ $s_2$ æ—¶ï¼Œæœ€å°éœ€è¦å°†ã€Œç©ºåœ°ã€æ”¾ä¸Šã€Œéšœç¢ç‰©ã€çš„æ“ä½œæ¬¡æ•°ã€‚çŠ¶æ€æœ‰ $4$ ç§ï¼š\n\n- $0$ è¡¨ç¤ºã€Œç©ºåœ°ã€\n- $1$ è¡¨ç¤ºã€ŒåŸå ¡ã€æˆ–è€…ä¹‹å‰çš„åˆ—å­˜åœ¨ã€ŒåŸå ¡ã€å¯ä»¥åˆ°è¾¾æ­¤ä½ç½®\n- $2$ è¡¨ç¤ºã€Œæ¶é­”ã€æˆ–è€…ä¹‹å‰çš„åˆ—å­˜åœ¨ã€Œæ¶é­”ã€å¯ä»¥åˆ°è¾¾æ­¤ä½ç½®\n- $3$ è¡¨ç¤ºã€Œéšœç¢ç‰©ã€\n\nä»»æ„ä¸¤ç§çŠ¶æ€ä¹‹é—´éƒ½æ˜¯ç›¸äº’ç‹¬ç«‹çš„ã€‚\n\nä½¿ç”¨è¯¥çŠ¶æ€çš„è¡¨ç¤ºæ–¹æ³•è¿›è¡ŒåŠ¨æ€è§„åˆ’å³å¯ï¼Œå…¶ä¸­çš„ç»†èŠ‚è¾ƒä¸ºå¤æ‚ï¼Œå¸Œæœ›è¯»è€…å¯ä»¥ç»“åˆä¸‹é¢çš„ç»†èŠ‚éƒ¨åˆ†ä»¥åŠä»£ç éƒ¨åˆ†è‡ªè¡Œæ€è€ƒã€‚\n\n#### ç»†èŠ‚\n\nè¿™é‡Œä»‹ç»ä¸€ç§ç›¸å¯¹å®¹æ˜“å®ç°çš„çŠ¶æ€è½¬ç§»æ–¹æ³•ã€‚\n\nè®¾ç¬¬ $i-1$ åˆ—çš„ $f$ çŠ¶æ€ä¸º $s_1$ å’Œ $s_2$ï¼Œç¬¬ $i$ åˆ—æœ¬èº«çš„ä¸¤ä¸ªæ ¼å­ï¼ˆä¸è€ƒè™‘ç¬¬ $i-1$ åˆ—çš„å½±å“ï¼‰çš„çŠ¶æ€ä¸º $t_1$ å’Œ $t_2$ï¼Œæˆ‘ä»¬éœ€è¦åˆ¤æ–­ $s_1, s_2$ æ˜¯å¦å¯ä»¥å’Œ $t_1, t_2$ æˆä¸ºç›¸é‚»çš„ä¸¤åˆ—ã€‚å¦‚æœå¯ä»¥ï¼Œé‚£ä¹ˆ $s_1, s_2$ ä¼šå¯¹ $t_1, t_2$ äº§ç”Ÿå½±å“ï¼ˆä¾‹å¦‚ $s_1=1$ ä¸” $t_1=0$ï¼Œé‚£ä¹ˆã€ŒåŸå ¡ã€å°±å¯ä»¥åˆ°è¾¾ $t_1$ çš„ä½ç½®ï¼Œä¼šå°† $t_1$ çš„å€¼æ›´æ–°ä¸º $1$ï¼‰ã€‚è®¾å½±å“åçš„çŠ¶æ€ä¸º $t_1', t_2'$ï¼Œé‚£ä¹ˆå°±æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š\n\n$$\nf[i][t_1'][t_2'] = \\min\\big\\{ f[i-1][s_1][s_2] + \\Delta(t_1, t_2) \\big\\}\n$$\n\nå…¶ä¸­ $\\Delta(t_1, t_2)$ è¡¨ç¤ºæˆ‘ä»¬é¢å¤–åœ¨ç¬¬ $i$ åˆ—æ”¾ç½®çš„ã€Œéšœç¢ç‰©ã€æ•°é‡ã€‚\n\n#### ä»£ç \n\n```C++ [sol2-C++]\nint f[10010][4][4];\n\nclass Solution {\nprivate:\n    static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\npublic:\n    int check(const vector<string>& grid) {\n        int n = grid[0].size();\n        // check if no (castle, demon) neighbor pair exists\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int d = 0; d < 4; ++d) {\n                    int ni = i + dirs[d][0];\n                    int nj = j + dirs[d][1];\n                    if (ni >= 0 && ni < 2 && nj >= 0 && nj < n) {\n                        if (grid[i][j] == 'C' && grid[ni][nj] == 'S') {\n                            return INT_MAX;\n                        }\n                        if (grid[i][j] == 'S' && grid[ni][nj] == 'C') {\n                            return INT_MAX;\n                        }\n                    }\n                }\n            }\n        }\n\n        // f[i][s1][s2] = ith column, s1, s2, minimum barriers to put\n        // s1, s2 = (0=empty, 1=castle, 2=demon, 3=stone)\n        memset(f, 0x3f, sizeof(f));\n        f[0][0][0] = 0;\n        unordered_map<char, int> rep = {{'.', 0}, {'C', 1}, {'S', 2}, {'#', 3}};\n\n        auto update = [&](int i, int s1, int s2, int t1, int t2, int extra) {\n            if (s1 == 1 || s1 == 2) {\n                if (s1 + t1 == 3) {\n                    return;\n                }\n                if (t1 == 0) {\n                    t1 = s1;\n                }\n            }\n            if (s2 == 1 || s2 == 2) {\n                if (s2 + t2 == 3) {\n                    return;\n                }\n                if (t2 == 0) {\n                    t2 = s2;\n                }\n            }\n            if ((t1 == 1 || t1 == 2) && (t1 + t2 == 3)) {\n                return;\n            }\n            if ((t1 == 1 || t1 == 2) && t2 == 0) {\n                t2 = t1;\n            }\n            if ((t2 == 1 || t2 == 2) && t1 == 0) {\n                t1 = t2;\n            }\n            f[i][t1][t2] = min(f[i][t1][t2], f[i - 1][s1][s2] + extra);\n        };\n\n        for (int i = 1; i <= n; ++i) {\n            int t1 = rep[grid[0][i - 1]];\n            int t2 = rep[grid[1][i - 1]];\n            for (int s1 = 0; s1 < 4; ++s1) {\n                for (int s2 = 0; s2 < 4; ++s2) {\n                    update(i, s1, s2, t1, t2, 0);\n                    if (grid[0][i - 1] == '.') {\n                        update(i, s1, s2, 3, t2, 1);\n                    }\n                    if (grid[1][i - 1] == '.') {\n                        update(i, s1, s2, t1, 3, 1);\n                    }\n                    if (grid[0][i - 1] == '.' && grid[1][i - 1] == '.') {\n                        update(i, s1, s2, 3, 3, 2);\n                    }\n                }\n            }\n        }\n\n        int ans = INT_MAX;\n        for (int i = 0; i < 4; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                ans = min(ans, f[n][i][j]);\n            }\n        }\n        return ans;\n    }\n\n    int guardCastle(vector<string>& grid) {\n        int n = grid[0].size();\n        int ans = INT_MAX;\n\n        // mark every portal as castle\n        auto g1 = grid;\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (g1[i][j] == 'P') {\n                    g1[i][j] = 'C';\n                }\n            }\n        }\n        ans = min(ans, check(g1));\n\n        // mark every portal as demon\n        auto g2 = grid;\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (g2[i][j] == 'P') {\n                    g2[i][j] = 'S';\n                }\n            }\n        }\n        ans = min(ans, check(g2));\n\n        if (ans == INT_MAX) {\n            ans = -1;\n        }\n        return ans;\n    }\n};\n```",
      "createdAt": "2021-04-10T16:31:45.514298+00:00",
      "hitCount": 1710,
      "identifier": "Dh0jHD",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "zhuang-tai-ya-suo-dp-by-heyshb-2ron",
        "title": "çŠ¶æ€å‹ç¼©DP"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "7rLGCR"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 23,
          "reactionType": "UPVOTE"
        }
      ],
      "rewardEnabled": null,
      "slug": "lcp-38-shou-wei-cheng-bao-by-zerotrac2-kgv2",
      "status": "PUBLISHED",
      "summary": "å‰è¨€\nç”±äºæœ¬é¢˜æ˜¯ã€ŒåŠ›æ‰£æ¯ã€çš„ç«èµ›é¢˜ï¼Œå› æ­¤åªä¼šç»™å‡ºæç¤ºã€ç®€è¦æ€è·¯ä»¥åŠä»£ç ï¼Œä¸ä¼šå¯¹ç®—æ³•æœ¬èº«è¿›è¡Œè¯¦ç»†è¯´æ˜ï¼Œå¸Œæœ›è¯»è€…å¤šå¤šæ€è€ƒã€‚\n æ–¹æ³•ä¸€ï¼šæ‹†ç‚¹ + æœ€å°å‰²\n æç¤º 1\næˆ‘ä»¬å¸Œæœ›ã€Œæ¶é­”ã€æ— æ³•åˆ°è¾¾åŸå ¡ï¼Œå³ã€ŒåŸå ¡ã€å’Œã€Œæ¶é­”ã€ä¹‹é—´ä¸è¿é€šï¼Œå¯¹åº”åˆ°å›¾è®ºæ¨¡å‹ä¸Šå°±æ˜¯ã€Œå‰²ã€é—®é¢˜ã€‚\n æ€è·¯\nä½¿ç”¨æœ€å°å‰²å»ºæ¨¡ï¼š\n\nå°†æ¯ä¸€ä¸ªéã€Œéšœç¢ç‰©ã€çš„æ ¼å­æ‹†åˆ†æˆä¸¤",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Graph",
          "nameTranslated": "å›¾",
          "slug": "graph",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Dynamic Programming",
          "nameTranslated": "åŠ¨æ€è§„åˆ’",
          "slug": "dynamic-programming",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "LCP 38. å®ˆå«åŸå ¡",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 0,
        "id": 714128,
        "viewCount": 1227
      },
      "uuid": "Dh0jHD",
      "videosInfo": []
    }
  }
}
