{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "可爱不是 3 岁",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/arsenal-591/avatar_1625975086.png",
          "userSlug": "arsenal-591"
        },
        "username": "Arsenal-591"
      },
      "byLeetcode": false,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "感谢 [@zerotrac2](/u/zerotrac2/) 提供的绝妙思路。\r\n\r\n对于原排列中第 $i$ 个元素，设 $f(i)$ 为进行一次操作后，该元素的新的下标。根据题意：\r\n- 当 $i < n/2$ 时，$f(i)=2i$（第一条规则）\r\n- 当 $i \\ge n/2$ 时，$f(i)=2i-(n-1)$（第二条规则）\r\n\r\n原排列中的第 $0$ 和 $n-1$ 个元素的下标是不会变化的，我们无需进行考虑。\r\n对于其余元素 $i \\in [1, n-1)$，都有 $f(i) \\equiv 2i \\bmod (n-1)$。\r\n\r\n下面，记 $f^k(i)$ 为原排列中第 $i$ 个元素操作 $k$ 次后的下标，即 $f^2(i) = f(f(i)), f^3(i) = f(f(f(i)))$ 等等，那么我们有\r\n\r\n$$\r\nf^k(i) \\equiv 2^ki \\bmod (n-1)\r\n$$\r\n\r\n这意味着：**为了让排列还原到初始值，必须有 $f^k(i) \\equiv 2^ki \\equiv i \\bmod (n-1)$**。\r\n\r\n当 $i=1$ 时，我们有\r\n\r\n$$\r\nf^k(1) \\equiv 2^k \\equiv 1 \\bmod (n-1)\r\n$$\r\n\r\n如果存在 $k$ 满足上式，那么将上式两侧同乘 $i$，得到 $f^k(i) \\equiv i \\bmod (n-1)$ 即对于 $i \\in [1, n-1)$ 恒成立。因此，原题等价于寻找最小的 $k$，使得 $2^k \\equiv 1 \\bmod (n-1)$。\r\n\r\n```C++ [sol1-C++]\r\nclass Solution {\r\npublic:\r\n    int reinitializePermutation(int n) {\r\n        if (n == 2) {\r\n            return 1;\r\n        }\r\n        int k = 1;\r\n        int pow2 = 2;\r\n        while (pow2 != 1) {\r\n            k++;\r\n            pow2 = pow2 * 2 % (n - 1);\r\n        }\r\n        return k;\r\n    }\r\n};\r\n```\r\n\r\n```Python [sol1-Python3]\r\nclass Solution:\r\n    def reinitializePermutation(self, n: int) -> int:\r\n        if n == 2:\r\n            return 1\r\n        \r\n        k, pow2 = 1, 2\r\n        while pow2 != 1:\r\n            k += 1\r\n            pow2 = pow2 * 2 % (n - 1)\r\n        \r\n        return k\r\n```\r\n\r\n由于 $n-1$ 是奇数，$2$ 和 $n-1$ 互质，那么根据 [欧拉定理](https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA))\r\n\r\n$$\r\n2^{\\varphi(n-1)} \\equiv 1 \\bmod (n-1)\r\n$$\r\n\r\n即 $k=\\varphi(n-1)$ 一定是一个解，其中 $\\varphi$ 为 [欧拉函数](https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0)。因此，最小的 $k$ 一定小于等于 $\\varphi(n-1)$。而后者是 $O(n-1) = O(n)$ 的，因此总的时间复杂度为 $O(n)$。\r\n\r\n**注记 1**：题面中给出的是新数组中下标为 $i$ 的元素来源自原数组中的哪个元素，即为 $f$ 的反函数。为了从反函数中求解出 $f$，可以利用换元法。\r\n**注记 2**：为了推导出 $i \\in [1, n-1)$，都有 $f(i) = 2i \\bmod (n-1)$，需要对两种情况做分类讨论。\r\n**注记 3**：本思路来自网站 [Project Euler](https://projecteuler.net) 的题目 [Riffle Shuffles](https://projecteuler.net/problem=622)。",
      "createdAt": "2021-03-28T04:06:33.907669+00:00",
      "hitCount": 3192,
      "identifier": "a6HdCM",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "cdie-dai-by-monologue-s-bzp8",
        "title": "c++迭代"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "minimum-number-of-operations-to-reinitialize-a-permutation"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 54,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 4,
          "reactionType": "AWESOME"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 1,
          "reactionType": "CONFUSED"
        }
      ],
      "rewardEnabled": null,
      "slug": "shu-xue-on-suan-fa-by-arsenal-591-xatz",
      "status": "PREPUBLISH",
      "summary": "感谢 @zerotrac2 提供的绝妙思路。\n对于原排列中第 i 个元素，设 f(i) 为进行一次操作后，该元素的新的下标。根据题意：\n\n当 i < n/2 时，f(i)=2i（第一条规则）\n当 i \\ge n/2 时，f(i)=2i-(n-1)（第二条规则）\n\n原排列中的第 0 和 n-1 个元素的下标是不会变化的，",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Math",
          "nameTranslated": "数学",
          "slug": "math",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "【数学】 O(n) 算法",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 16,
        "id": 684745,
        "viewCount": 2355
      },
      "uuid": "a6HdCM",
      "videosInfo": []
    }
  }
}
