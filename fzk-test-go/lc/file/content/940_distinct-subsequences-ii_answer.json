{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "力扣 (LeetCode)",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2021/03/73c9f099-abbe-4d94-853f-f8abffd459cd/leetcode.png",
          "userSlug": "leetcode"
        },
        "username": "LeetCode"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "#### 方法一：动态规划\n\n虽然解决这题的代码很短，但它的算法并不是很容易设计。我们会用动态规划先求出包括空序列的所有子序列，再返回答案之前再减去空序列。\n\n我们用 `dp[k]` 表示 `S[0 .. k]` 可以组成的不同子序列的数目。如果 `S` 中的所有字符都不相同，例如 `S = \"abcx\"`，那么状态转移方程就是简单的 `dp[k] = dp[k-1] * 2`，例如 `dp[2] = 8`，它包括 `(\"\", \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", \"abc\")` 这 `8` 个不同的子序列，而 `dp[3]` 在这些子序列的末尾增加 `x`，就可以得到额外的 `8` 个不同的子序列，即 `(\"x\", \"ax\", \"bx\", \"cx\", \"abx\", \"acx\", \"bcx\", \"abcx\")`，因此 `dp[3] = 8 * 2 = 16`。\n\n但当 `S` 中有相同字母的时候，就要考虑重复计数的问题了，例如当 `S = \"abab\"` 时，我们有：\n\n* `dp[0] = 2`，它包括 `(\"\", \"a\")`；\n\n* `dp[1] = 4`，它包括 `(\"\", \"a\", \"b\", \"ab\")`；\n\n* `dp[2] = 7`，它包括 `(\"\", \"a\", \"b\", \"aa\", \"ab\", \"ba\", \"aba\")`；\n\n* `dp[3] = 12`，它包括 `(\"\", \"a\", \"b\", \"aa\", \"ab\", \"ba\", \"bb\", \"aab\", \"aba\", \"abb\", \"bab\", \"abab\")`。\n\n当从 `dp[2]` 转移到 `dp[3]` 时，我们只会在 `dp[2]` 中的 `(\"b\", \"aa\", \"ab\", \"ba\", \"aba\")` 的末尾增加 `b`，而忽略掉 `(\"\", \"a\")`，因为它们会得到重复的子序列。我们可以发现，这里的 `(\"\", \"a\")` 刚好就是 `dp[0]`，也就是上一次增加 `b` 之前的子序列集合。因此我们就得到了如下的状态转移方程：\n\n`dp[k] = 2 * dp[k - 1] - dp[last[S[k]] - 1]`\n\n即在计算 `dp[k]` 时，首先会将 `dp[k - 1]` 对应的子序列的末尾添加 `S[k]` 得到额外的 `dp[k - 1]` 个子序列，并减去重复出现的子序列数目，这个数目即为上一次添加 `S[k]` 之前的子序列数目 `dp[last[S[k]] - 1]`。\n\n```Java [sol1]\nclass Solution {\n    public int distinctSubseqII(String S) {\n        int MOD = 1_000_000_007;\n        int N = S.length();\n        int[] dp = new int[N+1];\n        dp[0] = 1;\n\n        int[] last = new int[26];\n        Arrays.fill(last, -1);\n\n        for (int i = 0; i < N; ++i) {\n            int x = S.charAt(i) - 'a';\n            dp[i+1] = dp[i] * 2 % MOD;\n            if (last[x] >= 0)\n                dp[i+1] -= dp[last[x]];\n            dp[i+1] %= MOD;\n            last[x] = i;\n        }\n\n        dp[N]--;\n        if (dp[N] < 0) dp[N] += MOD;\n        return dp[N];\n    }\n}\n```\n\n```Python [sol1]\nclass Solution(object):\n    def distinctSubseqII(self, S):\n        dp = [1]\n        last = {}\n        for i, x in enumerate(S):\n            dp.append(dp[-1] * 2)\n            if x in last:\n                dp[-1] -= dp[last[x]]\n            last[x] = i\n\n        return (dp[-1] - 1) % (10**9 + 7)\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(N)$，其中, where $N$ 是字符串 `S` 的长度。\n\n* 空间复杂度：$O(N)$，也可以将空间复杂度优化到 $O(1)$。",
      "createdAt": "2019-07-22T09:13:14.118038+00:00",
      "hitCount": 11102,
      "identifier": "iCmSGG",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "wei-rao-li-lun-dong-tai-gui-hua-cong-wu-5ak81",
        "title": "【微扰理论】动态规划+哈希表 从无重复字母的情况开始讨论"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "distinct-subsequences-ii"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 24,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 2,
          "reactionType": "AWESOME"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 1,
          "reactionType": "CONFUSED"
        }
      ],
      "rewardEnabled": null,
      "slug": "bu-tong-de-zi-xu-lie-ii-by-leetcode",
      "status": "PUBLISHED",
      "summary": "§ 方法一：动态规划\n虽然解决这题的代码很短，但它的算法并不是很容易设计。我们会用动态规划先求出包括空序列的所有子序列，再返回答案之前再减去空序列。\n我们用 dp[k] 表示 S[0 .. k] 可以组成的不同子序列的数目。如果 S 中的所有字符都不相同，例如 S = \"abcx\"，那么状态转移方程就是简单的 dp[k",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Dynamic Programming",
          "nameTranslated": "动态规划",
          "slug": "dynamic-programming",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python",
          "nameTranslated": "",
          "slug": "python",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "不同的子序列 II",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 27,
        "id": 15997,
        "viewCount": 7018
      },
      "uuid": "iCmSGG",
      "videosInfo": []
    }
  }
}
