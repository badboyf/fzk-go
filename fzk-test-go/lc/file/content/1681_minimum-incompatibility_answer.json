{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "zerotrac ğŸŒ¸",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/zerotrac2/avatar_1628749564.png",
          "userSlug": "zerotrac2"
        },
        "username": "zerotrac2"
      },
      "byLeetcode": false,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "#### å‰è¨€\n\nè¯»æ‡‚æœ¬ç¯‡é¢˜è§£éœ€è¦å·²æŒæ¡å¦‚ä¸‹çŸ¥è¯†ç‚¹ï¼š\n\n- ä½è¿ç®—ä¸­çš„ã€Œæšä¸¾å­é›†ã€ï¼Œå³ç»™å®šä¸€ä¸ªæ•´æ•° $x$ï¼Œå¦‚ä½•ä¸é‡å¤åœ°æšä¸¾ $x$ äºŒè¿›åˆ¶è¡¨ç¤ºçš„å­é›† $\\{y\\}$ã€‚ã€Œå­é›†ã€çš„å®šä¹‰ä¸ºï¼Œ$y$ çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æ¯ä¸€ä¸ªå‡ºç°çš„ $1$ï¼Œ$x$ ä¸­ç›¸åŒçš„ä½ç½®ä¹Ÿä¸º $1$ï¼Œç”¨ä½è¿ç®—å³ä¸º $x ~\\&~ y = y$ã€‚\n\n- ã€Œæšä¸¾å­é›†ã€çš„æ—¶é—´å¤æ‚åº¦åˆ†æï¼Œå¯¹äºæ‰€æœ‰ä½æ•°ä¸è¶…è¿‡ $n$ çš„äºŒè¿›åˆ¶æ•°ï¼Œæ•°é‡ä¸º $2^n$ã€‚å¦‚æœæšä¸¾ä¸€ä¸ªå­é›†çš„æ—¶é—´å¤æ‚åº¦è®°ä¸º $O(1)$ï¼Œé‚£ä¹ˆæšä¸¾æ•´æ•° $x$ çš„æ‰€æœ‰å­é›†çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(2^n)$ã€‚ç„¶è€Œå¦‚æœæˆ‘ä»¬æšä¸¾**æ¯ä¸€ä¸ªä¸è¶…è¿‡ $n$ çš„äºŒè¿›åˆ¶æ•°çš„æ‰€æœ‰å­é›†**ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦å®é™…ä¸Šä¸æ˜¯ $O(2^n \\cdot 2^n) = O(4^n)$ï¼Œè€Œæ˜¯ $O(3^n)$ï¼Œå…·ä½“å¯ä»¥ç”¨äºŒé¡¹å¼å®šç†æ¥è¯æ˜ã€‚\n\n[@newhar](/u/newhar/) æœ‰æ—¶é—´å¤æ‚åº¦æ¯”æœ¬ç¯‡é¢˜è§£æ›´ä½çš„æ–¹æ³•ï¼š[è€å¥—è·¯-çŠ¶æ€å‹ç¼©dp](https://leetcode-cn.com/problems/minimum-incompatibility/solution/lao-tao-lu-zhuang-tai-ya-suo-dp-by-newha-j58b/)ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šçŠ¶æ€å‹ç¼©åŠ¨æ€è§„åˆ’\n\n**æ€è·¯ä¸ç®—æ³•**\n\nè®¾æ•°ç»„ $\\textit{nums}$ çš„é•¿åº¦ä¸º $n$ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªé•¿åº¦ä¸º $\\textit{mask}$ çš„äºŒè¿›åˆ¶è¡¨ç¤ºæ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ å½“å‰æ˜¯å¦å·²ç»è¢«é€‰æ‹©è¿‡ï¼š$\\textit{mask}$ çš„ç¬¬ $i$ ä½ä¸º $1$ è¡¨ç¤º $\\textit{nums}[i]$ å·²ç»è¢«é€‰æ‹©è¿‡ï¼Œ$0$ è¡¨ç¤º $\\textit{nums}[i]$ æœªè¢«é€‰æ‹©è¿‡ã€‚\n\nè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å°è¯•ä½¿ç”¨çŠ¶æ€å‹ç¼©åŠ¨æ€è§„åˆ’çš„æ–¹æ³•æ¥è§£å†³æœ¬é¢˜ã€‚è®° $f[\\textit{mask}]$ è¡¨ç¤ºå½“é€‰æ‹©çš„å…ƒç´ é›†åˆä¸º $\\textit{mask}$ æ—¶**æœ€å°çš„**ä¸å…¼å®¹æ€§çš„å’Œã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å†™å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š\n\n$$\nf[\\textit{mask}] = \\min_{\\textit{sub} \\text{~is valid}} \\big\\{  f[\\textit{mask} \\oplus \\textit{sub}] + \\textit{value}[\\textit{sub}] \\big\\}\n$$\n\nè¿™ä¸ªçŠ¶æ€æ–¹ç¨‹æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿæˆ‘ä»¬å°è¯•æšä¸¾ $\\textit{mask}$ çš„ä¸€ä¸ªå­é›† $\\textit{sub}$ï¼Œå®ƒè¡¨ç¤ºæˆ‘ä»¬**æœ€åä¸€ä¸ªé€‰æ‹©çš„å­é›†**ï¼ŒåŒæ—¶å®ƒå¿…é¡»æ»¡è¶³ä¸€äº›æ¡ä»¶ã€‚å½“æˆ‘ä»¬é€‰æ‹©äº†å­é›† $\\textit{sub}$ åï¼Œæˆ‘ä»¬è®¡ç®—å®ƒçš„ä¸å…¼å®¹æ€§ $\\textit{value}[\\textit{sub}]$ï¼Œå¹¶ä¸”å°†å®ƒä» $\\textit{mask}$ ä¸­ç§»é™¤ã€‚è¿™é‡Œ $\\oplus$ è¡¨ç¤ºå¼‚æˆ–è¿ç®—ï¼Œ$\\textit{mask} \\oplus \\textit{sub}$ å°±æ˜¯å°† $\\textit{sub}$ ä» $\\textit{mask}$ ä¸­ç§»é™¤çš„æ“ä½œã€‚å‰©ä½™çš„æ‰€æœ‰å…ƒç´ å¯¹åº”çš„æœ€å°ä¸å…¼å®¹æ€§çš„å’Œä¸º $f[\\textit{mask} \\oplus \\textit{sub}]$ï¼Œå› æ­¤å°†è¿™ä¸¤é¡¹ç›¸åŠ ï¼Œå¹¶åœ¨æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„ $\\textit{sub}$ ä¸­é€‰å–ç›¸åŠ çš„æœ€å°å€¼ï¼Œå°±å¯ä»¥å¾—åˆ° $\\textit{mask}$ å¯¹åº”çš„æœ€å°ä¸å…¼å®¹æ€§çš„å’Œã€‚\n\né‚£ä¹ˆ $\\textit{sub}$ éœ€è¦æ»¡è¶³å“ªäº›è¦æ±‚å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥æ ¹æ®é¢˜ç›®æè¿°ï¼Œå°† $\\textit{sub}$ çš„è¦æ±‚åˆ—ä¸¾å‡ºæ¥ï¼š\n\n- $\\textit{sub}$ ä¸­å¿…é¡»æ°å¥½æœ‰ $\\dfrac{n}{k}$ ä¸ª $1$ï¼Œè¿™æ ·å®ƒæ‰èƒ½æˆä¸ºä¸€ä¸ªå­é›†ï¼›\n\n- $\\textit{sub}$ ä¸­ä»»æ„ä¸¤ä¸ª $1$ å¯¹åº”çš„æ•°ç»„ $\\textit{nums}$ ä¸­çš„å…ƒç´ å¿…é¡»ä¸èƒ½ç›¸åŒã€‚\n\næ ¹æ®è¿™äº›è¦æ±‚ï¼Œæˆ‘ä»¬å¯ä»¥ã€Œé¢„å¤„ç†ã€å‡ºæ‰€æœ‰æ»¡è¶³è¦æ±‚çš„ $\\textit{sub}$ã€‚å¦‚æœ $\\textit{sub}$ æ»¡è¶³è¦æ±‚ï¼Œé‚£ä¹ˆ $\\textit{value}[\\textit{sub}]$ å°±æ˜¯ $\\textit{sub}$ çš„ä¸å…¼å®¹æ€§ï¼›å¦‚æœ $\\textit{sub}$ ä¸æ»¡è¶³è¦æ±‚ï¼Œé‚£ä¹ˆ $\\textit{value}$ å°±æ˜¯ $-1$ã€‚é¢„å¤„ç†çš„æ–¹æ³•ä¹Ÿå¾ˆç®€å•ï¼Œæˆ‘ä»¬éå†æ‰€æœ‰é•¿åº¦ä¸è¶…è¿‡ $n$ çš„äºŒè¿›åˆ¶æ•°ï¼Œä½¿ç”¨è¯­è¨€è‡ªå¸¦çš„ API åˆ¤æ–­å…¶æ˜¯å¦æœ‰ $\\frac{n}{k}$ ä¸ª $1$ï¼Œå†ä½¿ç”¨æ•°ç»„æˆ–è€…å“ˆå¸Œè¡¨è¿›è¡Œè®¡æ•°ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦å…¶ä¸­å…ƒç´ ä¸¤ä¸¤ä¸åŒå³å¯ã€‚\n\n```C++ [sol0-C++]\nvector<int> value(1 << n, -1);\nfor (int sub = 0; sub < (1 << n); ++sub) {\n    // åˆ¤æ–­ sub æ˜¯å¦æœ‰ n/k ä¸ª 1\n    if (__builtin_popcount(mask) == n / k) {\n        // ä½¿ç”¨æ•°ç»„è¿›è¡Œè®¡æ•°\n        for (int j = 0; j < n; ++j) {\n            if (sub & (1 << j)) {\n                ++freq[nums[j]];\n            }\n        }\n        // ä»»æ„ä¸€ä¸ªæ•°ä¸èƒ½å‡ºç°è¶…è¿‡ 1 æ¬¡\n        bool flag = true;\n        for (int j = 1; j <= n; ++j) {\n            if (freq[j] > 1) {\n                flag = false;\n                break;\n            }\n        }\n        // å¦‚æœæ»¡è¶³è¦æ±‚ï¼Œé‚£ä¹ˆè®¡ç®— sub çš„ä¸å…¼å®¹æ€§\n        if (flag) {\n            int lb = INT_MAX, rb = INT_MIN;\n            for (int j = 1; j <= n; ++j) {\n                if (freq[j] > 0) {\n                    lb = min(lb, j);\n                    rb = max(rb, j);\n                }\n            }\n            valid[sub] = rb - lb;\n        }\n        // ç”±äºæˆ‘ä»¬ä½¿ç”¨æ•°ç»„è¿›è¡Œè®¡æ•°ï¼Œå› æ­¤è¦å°†æ•°ç»„æ¢å¤åŸçŠ¶\n        for (int j = 0; j < n; ++j) {\n            if (sub & (1 << j)) {\n                --freq[nums[j]];\n            }\n        }\n    }\n}\n```\n\n```Python [sol0-Python3]\nvalue = dict()\nfor sub in range(1 << n):\n    # åˆ¤æ–­ sub æ˜¯å¦æœ‰ n/k ä¸ª 1\n    if bin(sub).count(\"1\") == n // k:\n        # ä½¿ç”¨å“ˆå¸Œè¡¨è¿›è¡Œè®¡æ•°\n        freq = set()\n        flag = True\n        for j in range(n):\n            if sub & (1 << j):\n                # ä»»æ„ä¸€ä¸ªæ•°ä¸èƒ½å‡ºç°è¶…è¿‡ 1 æ¬¡\n                if nums[j] in freq:\n                    flag = False\n                    break\n                freq.add(nums[j])\n        \n        # å¦‚æœæ»¡è¶³è¦æ±‚ï¼Œé‚£ä¹ˆè®¡ç®— sub çš„ä¸å…¼å®¹æ€§\n        if flag:\n            value[sub] = max(freq) - min(freq)\n```\n\nåœ¨é¢„å¤„ç†å‡ºæ‰€æœ‰ $\\textit{sub}$ ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥è¿›è¡ŒåŠ¨æ€è§„åˆ’äº†ã€‚åŠ¨æ€è§„åˆ’çš„è¾¹ç•Œæ¡ä»¶ä¸ºï¼š\n\n$$\nf[0] = 0\n$$\n\nè¡¨ç¤ºæˆ‘ä»¬ä»€ä¹ˆéƒ½ä¸å–ï¼Œé‚£ä¹ˆä¸å…¼å®¹æ€§ä¸º $0$ã€‚å…¶ä½™çš„ $f$ å€¼æ‰åˆå§‹æ—¶éƒ½ç½®ä¸º $-1$ï¼Œè¡¨ç¤ºä¸æ»¡è¶³è¦æ±‚ã€‚å½“æˆ‘ä»¬éå†æ‰€æœ‰é•¿åº¦ä¸è¶…è¿‡ $n$ çš„äºŒè¿›åˆ¶æ•°ä½œä¸º $\\textit{mask}$ æ—¶ï¼Œæˆ‘ä»¬é¦–å…ˆå¯ä»¥é€šè¿‡è¯­è¨€è‡ªå¸¦çš„ API åˆ¤æ–­ $\\textit{mask}$ ä¸­ $1$ çš„ä¸ªæ•°æ˜¯å¦ä¸º $\\frac{n}{k}$ çš„å€æ•°ï¼Œè¿™æ ·å¯ä»¥å¤§å¤§å‡å°‘å¸¸æ•°ã€‚å¦‚æœæ»¡è¶³è¦æ±‚ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æšä¸¾å­é›†ï¼Œåˆ¤æ–­å­é›†æ˜¯å¦æ»¡è¶³è¦æ±‚ï¼Œå¹¶ä½¿ç”¨çŠ¶æ€è½¬ç§»æ–¹ç¨‹è¿›è¡Œè®¡ç®—å³å¯ã€‚\n\næœ€ç»ˆçš„ç­”æ¡ˆå³ä¸º $f[2^n-1]$ã€‚\n\n**æ³¨æ„ï¼š** å¦‚æœä½¿ç”¨ Python è¯­è¨€ï¼Œéœ€è¦åŠ  $n=k$ çš„ç‰¹æ®Šåˆ¤æ–­ï¼Œ$O(3^n)$ å¯¹äº Python æ¥è¯´è¿˜æ˜¯æœ‰ç‚¹é«˜ã€‚\n\n**ä»£ç **\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int minimumIncompatibility(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> value(1 << n, -1);\n        vector<int> freq(n + 1);\n        for (int sub = 0; sub < (1 << n); ++sub) {\n            // åˆ¤æ–­ sub æ˜¯å¦æœ‰ n/k ä¸ª 1\n            if (__builtin_popcount(sub) == n / k) {\n                // ä½¿ç”¨æ•°ç»„è¿›è¡Œè®¡æ•°\n                for (int j = 0; j < n; ++j) {\n                    if (sub & (1 << j)) {\n                        ++freq[nums[j]];\n                    }\n                }\n                // ä»»æ„ä¸€ä¸ªæ•°ä¸èƒ½å‡ºç°è¶…è¿‡ 1 æ¬¡\n                bool flag = true;\n                for (int j = 1; j <= n; ++j) {\n                    if (freq[j] > 1) {\n                        flag = false;\n                        break;\n                    }\n                }\n                // å¦‚æœæ»¡è¶³è¦æ±‚ï¼Œé‚£ä¹ˆè®¡ç®— sub çš„ä¸å…¼å®¹æ€§\n                if (flag) {\n                    int lb = INT_MAX, rb = INT_MIN;\n                    for (int j = 1; j <= n; ++j) {\n                        if (freq[j] > 0) {\n                            lb = min(lb, j);\n                            rb = max(rb, j);\n                        }\n                    }\n                    value[sub] = rb - lb;\n                }\n                // ç”±äºæˆ‘ä»¬ä½¿ç”¨æ•°ç»„è¿›è¡Œè®¡æ•°ï¼Œå› æ­¤è¦å°†æ•°ç»„æ¢å¤åŸçŠ¶\n                for (int j = 0; j < n; ++j) {\n                    if (sub & (1 << j)) {\n                        --freq[nums[j]];\n                    }\n                }\n            }\n        }\n        \n        vector<int> f(1 << n, -1);\n        f[0] = 0;\n        for (int mask = 1; mask < (1 << n); ++mask) {\n            // åˆ¤æ–­ mask æ˜¯å¦æœ‰ n/k å€æ•°ä¸ª 1\n            if (__builtin_popcount(mask) % (n / k) == 0) {\n                // æšä¸¾å­é›†\n                for (int sub = mask; sub; sub = (sub - 1) & mask) {\n                    if (value[sub] != -1 && f[mask ^ sub] != -1) {\n                        if (f[mask] == -1) {\n                            f[mask] = f[mask ^ sub] + value[sub];\n                        }\n                        else {\n                            f[mask] = min(f[mask], f[mask ^ sub] + value[sub]);\n                        }\n                    }\n                }\n            }\n        }\n            \n        return f[(1 << n) - 1];\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        # ç‰¹æ®Šåˆ¤æ–­ï¼Œå¦‚æœå…ƒç´ æ•°é‡ç­‰äºç»„æ•°\n        if n == k:\n            return 0\n        \n        value = dict()\n        for sub in range(1 << n):\n            # åˆ¤æ–­ sub æ˜¯å¦æœ‰ n/k ä¸ª 1\n            if bin(sub).count(\"1\") == n // k:\n                # ä½¿ç”¨å“ˆå¸Œè¡¨è¿›è¡Œè®¡æ•°\n                freq = set()\n                flag = True\n                for j in range(n):\n                    if sub & (1 << j):\n                        # ä»»æ„ä¸€ä¸ªæ•°ä¸èƒ½å‡ºç°è¶…è¿‡ 1 æ¬¡\n                        if nums[j] in freq:\n                            flag = False\n                            break\n                        freq.add(nums[j])\n                \n                # å¦‚æœæ»¡è¶³è¦æ±‚ï¼Œé‚£ä¹ˆè®¡ç®— sub çš„ä¸å…¼å®¹æ€§\n                if flag:\n                    value[sub] = max(freq) - min(freq)\n        \n        f = dict()\n        f[0] = 0\n        for mask in range(1 << n):\n            # åˆ¤æ–­ mask æ˜¯å¦æœ‰ n/k å€æ•°ä¸ª 1\n            if bin(mask).count(\"1\") % (n // k) == 0:\n                # æšä¸¾å­é›†\n                sub = mask\n                while sub > 0:\n                    if sub in value and mask ^ sub in f:\n                        if mask not in f:\n                            f[mask] = f[mask ^ sub] + value[sub]\n                        else:\n                            f[mask] = min(f[mask], f[mask ^ sub] + value[sub])\n                    sub = (sub - 1) & mask\n            \n        return -1 if (1 << n) - 1 not in f else f[(1 << n) - 1]\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(3^n)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(2^n)$ã€‚\n\n#### æ–¹æ³•ä¸€ç‚¹äº”ï¼šæšä¸¾å­é›†ä¼˜åŒ–\n\n**æ€è·¯ä¸ç®—æ³•**\n\nåœ¨æšä¸¾ $\\textit{mask}$ çš„å­é›†çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æšä¸¾æ‰€æœ‰å­é›†å†ä¾æ¬¡åˆ¤æ–­æ¯ä¸€ä¸ªå­é›†æ˜¯å¦æ»¡è¶³è¦æ±‚çš„ã€‚äº‹å®ä¸Šï¼Œè¿™ä¸€æ­¥æ˜¯å¯ä»¥è¿›è¡Œä¸€ä¸ªå°ä¼˜åŒ–çš„ï¼šå¦‚æœ $\\textit{value}$ ä¸­æ»¡è¶³è¦æ±‚çš„å­é›†ä¸ªæ•°å°äº $\\textit{mask}$ çš„å­é›†ï¼ˆæ— è®ºæ˜¯å¦æ»¡è¶³ï¼‰ä¸ªæ•°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æšä¸¾ $\\textit{value}$ï¼Œå°† $\\textit{value}$ è®¾è®¡ä¸ºå“ˆå¸Œè¡¨å³å¯ã€‚\n\nç”±äº C++ æ–¹æ³•ä¸€å·²ç»å¾ˆå¿«äº†ï¼Œæ‰€ä»¥ä¸‹é¢ä»…ç»™å‡º Python çš„ä»£ç ã€‚\n\n**ä»£ç **\n\n```Python [sol15-Python3]\nclass Solution:\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        \n        value = dict()\n        for sub in range(1 << n):\n            # åˆ¤æ–­ sub æ˜¯å¦æœ‰ n/k ä¸ª 1\n            if bin(sub).count(\"1\") == n // k:\n                # ä½¿ç”¨å“ˆå¸Œè¡¨è¿›è¡Œè®¡æ•°\n                freq = set()\n                flag = True\n                for j in range(n):\n                    if sub & (1 << j):\n                        # ä»»æ„ä¸€ä¸ªæ•°ä¸èƒ½å‡ºç°è¶…è¿‡ 1 æ¬¡\n                        if nums[j] in freq:\n                            flag = False\n                            break\n                        freq.add(nums[j])\n                \n                # å¦‚æœæ»¡è¶³è¦æ±‚ï¼Œé‚£ä¹ˆè®¡ç®— sub çš„ä¸å…¼å®¹æ€§\n                if flag:\n                    value[sub] = max(freq) - min(freq)\n        \n        f = dict()\n        f[0] = 0\n        for mask in range(1 << n):\n            # åˆ¤æ–­ mask æ˜¯å¦æœ‰ n/k å€æ•°ä¸ª 1\n            if bin(mask).count(\"1\") % (n // k) == 0:\n                # å¦‚æœå­é›†ä¸ªæ•°å°äº value ä¸­æ»¡è¶³è¦æ±‚çš„å­é›†ä¸ªæ•°ï¼Œæˆ‘ä»¬æ‰æšä¸¾å­é›†\n                if 2**bin(mask).count(\"1\") < len(value):\n                    sub = mask\n                    while sub > 0:\n                        if sub in value and mask ^ sub in f:\n                            if mask not in f:\n                                f[mask] = f[mask ^ sub] + value[sub]\n                            else:\n                                f[mask] = min(f[mask], f[mask ^ sub] + value[sub])\n                        sub = (sub - 1) & mask\n                else:\n                    for sub, v in value.items():\n                        if (mask & sub) == sub and mask ^ sub in f:\n                            if mask not in f:\n                                f[mask] = f[mask ^ sub] + v\n                            else:\n                                f[mask] = min(f[mask], f[mask ^ sub] + v)\n            \n        return -1 if (1 << n) - 1 not in f else f[(1 << n) - 1]\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(3^n)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(2^n)$ã€‚",
      "createdAt": "2020-12-06T04:15:27.232623+00:00",
      "hitCount": 5646,
      "identifier": "R30MrS",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "lao-tao-lu-zhuang-tai-ya-suo-dp-by-newha-j58b",
        "title": "è€å¥—è·¯-çŠ¶æ€å‹ç¼©dpï¼ˆè®°å¿†åŒ–æœç´¢ï¼Œ8msï¼‰"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "minimum-incompatibility"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 51,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 4,
          "reactionType": "AWESOME"
        }
      ],
      "rewardEnabled": null,
      "slug": "zui-xiao-bu-jian-rong-xing-by-zerotrac2-rwje",
      "status": "PUBLISHED",
      "summary": "å‰è¨€\nè¯»æ‡‚æœ¬ç¯‡é¢˜è§£éœ€è¦å·²æŒæ¡å¦‚ä¸‹çŸ¥è¯†ç‚¹ï¼š\n\n\nä½è¿ç®—ä¸­çš„ã€Œæšä¸¾å­é›†ã€ï¼Œå³ç»™å®šä¸€ä¸ªæ•´æ•° xï¼Œå¦‚ä½•ä¸é‡å¤åœ°æšä¸¾ x äºŒè¿›åˆ¶è¡¨ç¤ºçš„å­é›† \\{y\\}ã€‚ã€Œå­é›†ã€çš„å®šä¹‰ä¸ºï¼Œy çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æ¯ä¸€ä¸ªå‡ºç°çš„ 1ï¼Œx ä¸­ç›¸åŒçš„ä½ç½®ä¹Ÿä¸º 1ï¼Œç”¨ä½è¿ç®—å³ä¸º x ~\\&~ y = yã€‚\n\n\nã€Œæšä¸¾å­é›†ã€çš„æ—¶é—´å¤æ‚åº¦åˆ†æï¼Œå¯¹äºæ‰€æœ‰ä½æ•°ä¸è¶…è¿‡",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Bit Manipulation",
          "nameTranslated": "ä½è¿ç®—",
          "slug": "bit-manipulation",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Dynamic Programming",
          "nameTranslated": "åŠ¨æ€è§„åˆ’",
          "slug": "dynamic-programming",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python",
          "nameTranslated": "",
          "slug": "python",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "æœ€å°ä¸å…¼å®¹æ€§",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 29,
        "id": 510954,
        "viewCount": 3655
      },
      "uuid": "R30MrS",
      "videosInfo": []
    }
  }
}
