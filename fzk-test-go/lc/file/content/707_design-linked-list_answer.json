{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "力扣 (LeetCode)",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2021/03/73c9f099-abbe-4d94-853f-f8abffd459cd/leetcode.png",
          "userSlug": "leetcode"
        },
        "username": "LeetCode"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "####  面试要点\n链表时一个包含零个或多个元素的数据结构。每个元素都包含一个值和到另一个元素的链接。根据链接数的不同，可以分为单链表，双链表和多重链表。\n\n单链表是最简单的一种，它提供了在常数时间内的 `addAtHead` 操作和在线性时间内的 `addAtTail` 的操作。双链表是最常用的一种，因为它提供了在常数时间内的 `addAtHead` 和 `addAtTail` 操作，并且优化的插入和删除。\n\n双链表在 Java 中的实现为 LinkedList，在 Python 中为 list。这些结构都比较常用，有两个要点：\n- 哨兵节点：\n\n哨兵节点在树和链表中被广泛用作伪头、伪尾等，通常不保存任何数据。\n\n我们将使用伪头来简化我们简化插入和删除。在接下来的两种方法中应用此方法。\n\n- 双链表的双向搜索：我们可以从头部或尾部进行搜索。\n\n\n####  方法一：单链表\n让我们从最简单的链表开始。\n\n![在这里插入图片描述](https://pic.leetcode-cn.com/b3221337c286323c36ce9b991b6248c3ad8e93bce90fb261af9a687f16d02933-file_1578973150799){:width=500}\n\n```python [init1-Python]\nclass MyLinkedList:\n    def __init__(self):\n        self.size = 0\n        self.head = ListNode(0)  # sentinel node as pseudo-head\n```\n\n```java [init1-Java]\nclass MyLinkedList {\n  int size;\n  ListNode head;  // sentinel node as pseudo-head\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n  }\n}\n```\n\n哨兵节点被用作伪头始终存在，这样结构中永远不为空，它将至少包含一个伪头。MyLinkedList 中所有节点均包含：值 + 链接到下一个元素的指针。\n\n```python [ListNode1-Python]\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n```\n\n```java [ListNode1-Java]\npublic class ListNode {\n  int val;\n  ListNode next;\n  ListNode(int x) { val = x; }\n}\n```\n\n`addAtIndex`，`addAtHead` 和 `addAtTail`：\n我们首先讨论 `addAtIndex`，因为伪头的关系 `addAtHead` 和 `addAtTail` 可以使用 `addAtIndex` 来完成。\n\n这个想法很简单：\n- 找到要插入位置节点的前驱节点。如果要在头部插入，则它的前驱节点就是伪头。如果要在尾部插入节点，则前驱节点就是尾节点。\n- 通过改变 `next` 来插入节点。\n\n```python [add1-Python]\nto_add.next = pred.next\npred.next = to_add\n```\n\n```java [add1-Java]\ntoAdd.next = pred.next;\npred.next = toAdd;\n```\n\n![在这里插入图片描述](https://pic.leetcode-cn.com/b7d03b863918800496ee9e58758a654e2e05569a27c798251ae95e65edf9b402-file_1578973150851){:width=500}\n\n![在这里插入图片描述](https://pic.leetcode-cn.com/34ea9b5645a5ec2f31eff8766d50417c2d5c8b72d638ac36d4ca123d6fb68729-file_1578973150845){:width=500}\n\n`deleteAtIndex`：\n和插入同样的道理。\n- 找到要删除节点的前驱节点。\n- 通过改变 `next` 来删除节点。\n\n```python [delete2-Python]\n# delete pred.next \npred.next = pred.next.next\n```\n\n```java [delete2-Java]\n// delete pred.next \npred.next = pred.next.next;\n```\n\n![在这里插入图片描述](https://pic.leetcode-cn.com/72fe13e2fc3ed8358180b5101af1cbe7fb2126dc9b0801c6fd30f90dc60aca41-file_1578973150923){:width=500}\n\n`get`：\n从伪头节点开始，向前走 `index+1` 步。\n\n```python [get1-Python]\n# index steps needed \n# to move from sentinel node to wanted index\nfor _ in range(index + 1):\n    curr = curr.next\nreturn curr.val\n```\n\n```java [get1-Java]\n// index steps needed \n// to move from sentinel node to wanted index\nfor(int i = 0; i < index + 1; ++i) curr = curr.next;\nreturn curr.val;\n```\n\n![在这里插入图片描述](https://pic.leetcode-cn.com/f4df3682e14bbd9fd24edd58337ed727503f559badc39b7b80aec88ec6909233-file_1578973150859){:width=500}\n\n**全部代码：**\n\n```python [solution1-Python]\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass MyLinkedList:\n    def __init__(self):\n        self.size = 0\n        self.head = ListNode(0)  # sentinel node as pseudo-head\n        \n\n    def get(self, index: int) -> int:\n        \"\"\"\n        Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n        \"\"\"\n        # if index is invalid\n        if index < 0 or index >= self.size:\n            return -1\n        \n        curr = self.head\n        # index steps needed \n        # to move from sentinel node to wanted index\n        for _ in range(index + 1):\n            curr = curr.next\n        return curr.val\n            \n\n    def addAtHead(self, val: int) -> None:\n        \"\"\"\n        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n        \"\"\"\n        self.addAtIndex(0, val)\n        \n\n    def addAtTail(self, val: int) -> None:\n        \"\"\"\n        Append a node of value val to the last element of the linked list.\n        \"\"\"\n        self.addAtIndex(self.size, val)\n        \n\n    def addAtIndex(self, index: int, val: int) -> None:\n        \"\"\"\n        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\n        \"\"\"\n        # If index is greater than the length, \n        # the node will not be inserted.\n        if index > self.size:\n            return\n        \n        # [so weird] If index is negative, \n        # the node will be inserted at the head of the list.\n        if index < 0:\n            index = 0\n        \n        self.size += 1\n        # find predecessor of the node to be added\n        pred = self.head\n        for _ in range(index):\n            pred = pred.next\n            \n        # node to be added\n        to_add = ListNode(val)\n        # insertion itself\n        to_add.next = pred.next\n        pred.next = to_add\n        \n\n    def deleteAtIndex(self, index: int) -> None:\n        \"\"\"\n        Delete the index-th node in the linked list, if the index is valid.\n        \"\"\"\n        # if the index is invalid, do nothing\n        if index < 0 or index >= self.size:\n            return\n        \n        self.size -= 1\n        # find predecessor of the node to be deleted\n        pred = self.head\n        for _ in range(index):\n            pred = pred.next\n            \n        # delete pred.next \n        pred.next = pred.next.next\n```\n\n```java [solution1-Java]\npublic class ListNode {\n  int val;\n  ListNode next;\n  ListNode(int x) { val = x; }\n}\n\nclass MyLinkedList {\n  int size;\n  ListNode head;  // sentinel node as pseudo-head\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n  }\n\n  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\n  public int get(int index) {\n    // if index is invalid\n    if (index < 0 || index >= size) return -1;\n\n    ListNode curr = head;\n    // index steps needed \n    // to move from sentinel node to wanted index\n    for(int i = 0; i < index + 1; ++i) curr = curr.next;\n    return curr.val;\n  }\n\n  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\n  public void addAtHead(int val) {\n    addAtIndex(0, val);\n  }\n\n  /** Append a node of value val to the last element of the linked list. */\n  public void addAtTail(int val) {\n    addAtIndex(size, val);\n  }\n\n  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\n  public void addAtIndex(int index, int val) {\n    // If index is greater than the length, \n    // the node will not be inserted.\n    if (index > size) return;\n\n    // [so weird] If index is negative, \n    // the node will be inserted at the head of the list.\n    if (index < 0) index = 0;\n\n    ++size;\n    // find predecessor of the node to be added\n    ListNode pred = head;\n    for(int i = 0; i < index; ++i) pred = pred.next;\n\n    // node to be added\n    ListNode toAdd = new ListNode(val);\n    // insertion itself\n    toAdd.next = pred.next;\n    pred.next = toAdd;\n  }\n\n  /** Delete the index-th node in the linked list, if the index is valid. */\n  public void deleteAtIndex(int index) {\n    // if the index is invalid, do nothing\n    if (index < 0 || index >= size) return;\n\n    size--;\n    // find predecessor of the node to be deleted\n    ListNode pred = head;\n    for(int i = 0; i < index; ++i) pred = pred.next;\n\n    // delete pred.next \n    pred.next = pred.next.next;\n  }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：\n\t* `addAtHead`： $\\mathcal{O}(1)$\n\t* `addAtInder`，`get`，`deleteAtIndex`: $\\mathcal{O}(k)$，其中 $k$ 指的是元素的索引。\n\t* `addAtTail`：$\\mathcal{O}(N)$，其中 $N$ 指的是链表的元素个数。\n* 空间复杂度：所有的操作都是 $O(1)$。\n\n\n####  方法二：双链表\n双链表比单链表快得多，测试用例花费的时间比单链表快了两倍。但是它更加复杂，它包含了 `size`，记录链表元素个数，和伪头伪尾。\n\n![在这里插入图片描述](https://pic.leetcode-cn.com/ffb51bf8583d324c68afb3c5b5f9fe0f61f3fa65167d462d6f8549566c3c8f33-file_1578973150884)\n\n```python [init2-Python]\nclass MyLinkedList:\n    def __init__(self):\n        self.size = 0\n        # sentinel nodes as pseudo-head and pseudo-tail\n        self.head, self.tail = ListNode(0), ListNode(0) \n        self.head.next = self.tail\n        self.tail.prev = self.head\n```\n\n```java [init2-Java]\nclass MyLinkedList {\n  int size;\n  // sentinel nodes as pseudo-head and pseudo-tail\n  ListNode head, tail;\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n    tail = new ListNode(0);\n    head.next = tail;\n    tail.prev = head;\n  }\n}\n```\n\n伪头和伪尾总是存在，MyLinkedList 中所有节点都包含：值 + 指向前一个节点的指针 + 指向后一个节点的指针。\n\n```python [ListNode2-Python]\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        self.prev = None\n```\n\n```java [ListNode2-Java]\npublic class ListNode {\n  int val;\n  ListNode next;\n  ListNode prev;\n  ListNode(int x) { val = x; }\n}\n```\n\n`addAtIndex`，`addAtHead` 和 `addAtTail`：\n- 找到要插入节点的前驱节点和后继节点。如果要在头部插入节点，则它的前驱结点是伪头。如果要在尾部插入节点，则它的后继节点是伪尾。\n- 通过改变前驱结点和后继节点的链接关系添加元素。\n\n```python [add2-Python]\nto_add.prev = pred\nto_add.next = succ\npred.next = to_add\nsucc.prev = to_add\n```\n\n```java [add2-Java]\ntoAdd.prev = pred\ntoAdd.next = succ\npred.next = toAdd\nsucc.prev = toAdd\n```\n\n![在这里插入图片描述](https://pic.leetcode-cn.com/b4e5057ef258b98ea66252cd168cae535419161b28a6d6e5859c405e5585eb1b-file_1578973150914)\n\n`deleteAtIndex`：\n和插入同样的道理。\n- 找到要删除节点的前驱结点和后继节点。\n- 通过改变前驱结点和后继节点的链接关系删除元素。\n\n```python [delete2-Python]\npred.next = succ\nsucc.prev = pred\n```\n\n```java [delete2-Java]\npred.next = succ\nsucc.prev = pred\n```\n\n![在这里插入图片描述](https://pic.leetcode-cn.com/323a5bf16db256a4267fb8e379606ab54f73e9f6c95db4980f4fdd5bf4f57a08-file_1578973150887)\n\n`get`：\n- 通过比较 `index` 和 `size - index` 的大小判断从头开始较快还是从尾巴开始较快。\n- 从较快的方向开始。 \n\n```python [get2-Python]\n# choose the fastest way: to move from the head\n# or to move from the tail\nif index + 1 < self.size - index:\n    curr = self.head\n    for _ in range(index + 1):\n        curr = curr.next\nelse:\n    curr = self.tail\n    for _ in range(self.size - index):\n        curr = curr.prev\n```\n\n```java [get2-Java]\n// choose the fastest way: to move from the head\n// or to move from the tail\nListNode curr = head;\nif (index + 1 < size - index)\n  for(int i = 0; i < index + 1; ++i) curr = curr.next;\nelse {\n  curr = tail;\n  for(int i = 0; i < size - index; ++i) curr = curr.prev;\n}\n```\n\n![在这里插入图片描述](https://pic.leetcode-cn.com/eaefffaaf1f3155f210d6b9a2f4f302b0bb4a1653deea8e63e4313005e4faa60-file_1578973150893)\n\n**全部代码：**\n\n```python [solution2-Python]\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next, self.prev = None, None\n\nclass MyLinkedList:\n    def __init__(self):\n        self.size = 0\n        # sentinel nodes as pseudo-head and pseudo-tail\n        self.head, self.tail = ListNode(0), ListNode(0) \n        self.head.next = self.tail\n        self.tail.prev = self.head\n        \n\n    def get(self, index: int) -> int:\n        \"\"\"\n        Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n        \"\"\"\n        # if index is invalid\n        if index < 0 or index >= self.size:\n            return -1\n        \n        # choose the fastest way: to move from the head\n        # or to move from the tail\n        if index + 1 < self.size - index:\n            curr = self.head\n            for _ in range(index + 1):\n                curr = curr.next\n        else:\n            curr = self.tail\n            for _ in range(self.size - index):\n                curr = curr.prev\n                \n        return curr.val\n            \n\n    def addAtHead(self, val: int) -> None:\n        \"\"\"\n        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n        \"\"\"\n        pred, succ = self.head, self.head.next\n        \n        self.size += 1\n        to_add = ListNode(val)\n        to_add.prev = pred\n        to_add.next = succ\n        pred.next = to_add\n        succ.prev = to_add\n        \n\n    def addAtTail(self, val: int) -> None:\n        \"\"\"\n        Append a node of value val to the last element of the linked list.\n        \"\"\"\n        succ, pred = self.tail, self.tail.prev\n        \n        self.size += 1\n        to_add = ListNode(val)\n        to_add.prev = pred\n        to_add.next = succ\n        pred.next = to_add\n        succ.prev = to_add\n        \n\n    def addAtIndex(self, index: int, val: int) -> None:\n        \"\"\"\n        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\n        \"\"\"\n        # If index is greater than the length, \n        # the node will not be inserted.\n        if index > self.size:\n            return\n        \n        # [so weird] If index is negative, \n        # the node will be inserted at the head of the list.\n        if index < 0:\n            index = 0\n        \n        # find predecessor and successor of the node to be added\n        if index < self.size - index:\n            pred = self.head\n            for _ in range(index):\n                pred = pred.next\n            succ = pred.next\n        else:\n            succ = self.tail\n            for _ in range(self.size - index):\n                succ = succ.prev\n            pred = succ.prev\n        \n        # insertion itself\n        self.size += 1\n        to_add = ListNode(val)\n        to_add.prev = pred\n        to_add.next = succ\n        pred.next = to_add\n        succ.prev = to_add\n        \n\n    def deleteAtIndex(self, index: int) -> None:\n        \"\"\"\n        Delete the index-th node in the linked list, if the index is valid.\n        \"\"\"\n        # if the index is invalid, do nothing\n        if index < 0 or index >= self.size:\n            return\n        \n        # find predecessor and successor of the node to be deleted\n        if index < self.size - index:\n            pred = self.head\n            for _ in range(index):\n                pred = pred.next\n            succ = pred.next.next\n        else:\n            succ = self.tail\n            for _ in range(self.size - index - 1):\n                succ = succ.prev\n            pred = succ.prev.prev\n            \n        # delete pred.next \n        self.size -= 1\n        pred.next = succ\n        succ.prev = pred\n```\n\n```java [solution2-Java]\npublic class ListNode {\n  int val;\n  ListNode next;\n  ListNode prev;\n  ListNode(int x) { val = x; }\n}\n\nclass MyLinkedList {\n  int size;\n  // sentinel nodes as pseudo-head and pseudo-tail\n  ListNode head, tail;\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n    tail = new ListNode(0);\n    head.next = tail;\n    tail.prev = head;\n  }\n\n  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\n  public int get(int index) {\n    // if index is invalid\n    if (index < 0 || index >= size) return -1;\n\n    // choose the fastest way: to move from the head\n    // or to move from the tail\n    ListNode curr = head;\n    if (index + 1 < size - index)\n      for(int i = 0; i < index + 1; ++i) curr = curr.next;\n    else {\n      curr = tail;\n      for(int i = 0; i < size - index; ++i) curr = curr.prev;\n    }\n\n    return curr.val;\n  }\n\n  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\n  public void addAtHead(int val) {\n    ListNode pred = head, succ = head.next;\n\n    ++size;\n    ListNode toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n  }\n\n  /** Append a node of value val to the last element of the linked list. */\n  public void addAtTail(int val) {\n    ListNode succ = tail, pred = tail.prev;\n\n    ++size;\n    ListNode toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n  }\n\n  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\n  public void addAtIndex(int index, int val) {\n    // If index is greater than the length, \n    // the node will not be inserted.\n    if (index > size) return;\n\n    // [so weird] If index is negative, \n    // the node will be inserted at the head of the list.\n    if (index < 0) index = 0;\n\n    // find predecessor and successor of the node to be added\n    ListNode pred, succ;\n    if (index < size - index) {\n      pred = head;\n      for(int i = 0; i < index; ++i) pred = pred.next;\n      succ = pred.next;\n    }\n    else {\n      succ = tail;\n      for (int i = 0; i < size - index; ++i) succ = succ.prev;\n      pred = succ.prev;\n    }\n\n    // insertion itself\n    ++size;\n    ListNode toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n  }\n\n  /** Delete the index-th node in the linked list, if the index is valid. */\n  public void deleteAtIndex(int index) {\n    // if the index is invalid, do nothing\n    if (index < 0 || index >= size) return;\n\n    // find predecessor and successor of the node to be deleted\n    ListNode pred, succ;\n    if (index < size - index) {\n      pred = head;\n      for(int i = 0; i < index; ++i) pred = pred.next;\n      succ = pred.next.next;\n    }\n    else {\n      succ = tail;\n      for (int i = 0; i < size - index - 1; ++i) succ = succ.prev;\n      pred = succ.prev.prev;\n    }\n\n    // delete pred.next \n    --size;\n    pred.next = succ;\n    succ.prev = pred;\n  }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：\n\t* `addAtHead`，`addAtTail`： $\\mathcal{O}(1)$\n\t* `get`，`addAtIndex`，`delete`：$\\mathcal{O}(\\min(k, N - k))$，其中 $k$ 指的是元素的索引。\n* 空间复杂度：所有的操作都是 $\\mathcal{O}(1)$。",
      "createdAt": "2020-01-14T03:32:14.571523+00:00",
      "hitCount": 53524,
      "identifier": "Yvh9AK",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "si-lu-xiang-jie-she-ji-lian-biao-by-seve-mgpu",
        "title": "思路详解：设计链表"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "design-linked-list"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 76,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 10,
          "reactionType": "CONFUSED"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 6,
          "reactionType": "AWESOME"
        }
      ],
      "rewardEnabled": null,
      "slug": "she-ji-lian-biao-by-leetcode",
      "status": "PUBLISHED",
      "summary": " 面试要点\n链表时一个包含零个或多个元素的数据结构。每个元素都包含一个值和到另一个元素的链接。根据链接数的不同，可以分为单链表，双链表和多重链表。\n单链表是最简单的一种，它提供了在常数时间内的 addAtHead 操作和在线性时间内的 addAtTail 的操作。双链表是最常用的一种，因为它提供了在常数时间内的 add",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python",
          "nameTranslated": "",
          "slug": "python",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "https://pic.leetcode-cn.com/b3221337c286323c36ce9b991b6248c3ad8e93bce90fb261af9a687f16d02933-file_1578973150799",
      "title": "设计链表",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 50,
        "id": 73955,
        "viewCount": 36005
      },
      "uuid": "Yvh9AK",
      "videosInfo": []
    }
  }
}
