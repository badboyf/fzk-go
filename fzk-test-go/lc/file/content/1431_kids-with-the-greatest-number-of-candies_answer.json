{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "力扣官方题解",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/leetcode-solution/avatar_1582018938.png",
          "userSlug": "leetcode-solution"
        },
        "username": "LeetCode-Solution"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "### 📺 视频题解  \n![1431. 拥有最多糖果的孩子.mp4](23e02b0e-6a64-4153-acf7-1001b619c58e)\n\n### 📖 文字题解\n#### 方法一：遍历\n\n**思路**\n\n如果我们希望某个小朋友拥有的糖果最多，那么最优的方案当然是把额外的所有糖果都分给这个小朋友。因此，我们可以枚举每一个小朋友，并将额外的所有糖果都分给这个小朋友，然后再用 $O(n)$ 的时间遍历其余的小朋友，就可以判断这个小朋友是否拥有最多的糖果。\n\n上述方法的时间复杂度为 $O(n^2)$，然而我们可以将其优化为 $O(n)$。事实上，对于每一个小朋友，只要这个小朋友「拥有的糖果数目」加上「额外的糖果数目」大于等于所有小朋友拥有的糖果数目最大值，那么这个小朋友就可以拥有最多的糖果。\n\n**证明**\n\n设某个小朋友的糖果数为 $x$，其余小朋友拥有的糖果数目最大值为 $y$，额外的糖果数为 $e$。这个小朋友可以拥有最多的糖果，当且仅当\n\n$$\nx+e \\geq y\n$$\n\n由于 $x+e \\geq x$ 显然成立，那么我们有\n\n$$\nx+e \\geq \\max(x, y)\n$$\n\n而 $\\max(x, y)$ 就是所有小朋友拥有的糖果数目最大值。因此我们可以预处理出这个值，随后遍历每一个小朋友，只要这个小朋友「拥有的糖果数目」加上「额外的糖果数目」大于等于这个值，就可以满足要求。\n\n**代码**\n\n```cpp [sol1-C++]\nclass Solution {\npublic:\n    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {\n        int n = candies.size();\n        int maxCandies = *max_element(candies.begin(), candies.end());\n        vector<bool> ret;\n        for (int i = 0; i < n; ++i) {\n            ret.push_back(candies[i] + extraCandies >= maxCandies);\n        }\n        return ret;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {\n        int n = candies.length;\n        int maxCandies = 0;\n        for (int i = 0; i < n; ++i) {\n            maxCandies = Math.max(maxCandies, candies[i]);\n        }\n        List<Boolean> ret = new ArrayList<Boolean>();\n        for (int i = 0; i < n; ++i) {\n            ret.add(candies[i] + extraCandies >= maxCandies);\n        }\n        return ret;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        maxCandies = max(candies)\n        ret = [candy + extraCandies >= maxCandies for candy in candies]\n        return ret\n```\n\n```golang [sol1-Golang]\nfunc kidsWithCandies(candies []int, extraCandies int) []bool {\n    n := len(candies)\n    maxCandies := 0\n    for i := 0; i < n; i++ {\n        maxCandies = max(maxCandies, candies[i])\n    }\n    ret := make([]bool, n)\n    for i := 0; i < n; i++ {\n        ret[i] = candies[i] + extraCandies >= maxCandies\n    }\n    return ret\n}\n\nfunc max(x, y int) int {\n    if x > y {\n        return x\n    }\n    return y\n}\n```\n\n**复杂度分析**\n\n假设小朋友的总数为 $n$。\n\n+ 时间复杂度：我们首先使用 $O(n)$ 的时间预处理出所有小朋友拥有的糖果数目最大值。对于每一个小朋友，我们需要 $O(1)$ 的时间判断这个小朋友是否可以拥有最多的糖果，故渐进时间复杂度为 $O(n)$。\n\n+ 空间复杂度：这里只用了常数个变量作为辅助空间，与 $n$ 的规模无关，故渐进空间复杂度为 $O(1)$。",
      "createdAt": "2020-05-31T09:53:33.526292+00:00",
      "hitCount": 29754,
      "identifier": "ZSMBxO",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "shu-zu-mo-ni-by-euyvvl-tgrn",
        "title": "数组模拟"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "kids-with-the-greatest-number-of-candies"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 26,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 4,
          "reactionType": "AWESOME"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 2,
          "reactionType": "CONFUSED"
        }
      ],
      "rewardEnabled": null,
      "slug": "yong-you-zui-duo-tang-guo-de-hai-zi-by-leetcode-so",
      "status": "PUBLISHED",
      "summary": "📺 视频题解 📖 文字题解 方法一：遍历 思路 如果我们希望某个小朋友拥有的糖果最多，那么最优的方案当然是把额外的所有糖果都分给这个小朋友。因此，我们可以枚举每一个小朋友，并将额外的所有糖果都分给这个小朋友，然后再用 $O(n)$ 的时间遍历其余的小朋友，就可以判断这个小朋友是否拥有最多的糖果。 上述方法的时间复杂度为",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Array",
          "nameTranslated": "数组",
          "slug": "array",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Go",
          "nameTranslated": "",
          "slug": "golang",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python",
          "nameTranslated": "",
          "slug": "python",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "拥有最多糖果的孩子",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 168,
        "id": 269245,
        "viewCount": 25933
      },
      "uuid": "ZSMBxO",
      "videosInfo": [
        {
          "__typename": "VideoInfoNode",
          "coverUrl": "https://video.leetcode-cn.com/image/cover/7CC6EE61E89C4AEFB15A48D211736279-6-2.png",
          "duration": 228.1387,
          "videoId": "d7dbedc0bfa14fc1b5ff28a1bb75c7f7"
        }
      ]
    }
  }
}
