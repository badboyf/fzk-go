{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "随心源",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/sui-xin-yuan/avatar_1628139313.png",
          "userSlug": "sui-xin-yuan"
        },
        "username": "sui-xin-yuan"
      },
      "byLeetcode": false,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "### 解题思路\n\n单源最短路径问题：Dijkstra、Bellman-Ford、SPFA\n全源最短路径问题：Floyd\n\n模板参考：《算法笔记》\n\n所有算法代码附有本题执行结果图片，读者可以自行比对。\n\n**方法一：Floyd**\n\n```cpp\nclass Solution {\npublic:\n    void Floyd(vector<vector<int>>& distances, int n){\n        for (int k=0; k<n; ++k) {\n            for (int i=0; i<n; ++i) {\n                for (int j=0; j<n; ++j) {\n                    if (distances[i][k]!=INT_MAX && distances[k][j] != INT_MAX && distances[i][k] + distances[k][j] < distances[i][j]) {\n                        distances[i][j] = distances[i][k] + distances[k][j];\n                    }\n                }\n            }\n        }\n    }\n    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n        vector<vector<int>>distances(n,vector<int>(n,INT_MAX)); //全源最短路径矩阵\n        for (int i=0; i<n; i++) {\n            distances[i][i] = 0; //自身到自身的距离为0\n        }\n        for (vector<int> edge : edges) {\n            int u=edge[0], v=edge[1], w=edge[2];\n            distances[u][v]=w;\n            distances[v][u]=w;\n        }\n        Floyd(distances, n);\n        int idx = -1, minCount = INT_MAX;\n        for (int i=0; i<n; ++i) {\n            int count = 0;\n            for (int j=0; j<n; ++j) {\n                if (distances[i][j]<=distanceThreshold && i!=j) {\n                    count++;\n                }\n            }\n            if (count <= minCount) {\n                minCount = count;\n                idx = i;\n            }\n        }\n        return idx;\n    }\n};\n```\n\n执行效率：\n\n执行用时：84 ms, 在所有 C++ 提交中击败了64.89%的用户\n\n内存消耗：12.2 MB, 在所有 C++ 提交中击败了28.24%的用户\n\n![Screen Shot 2021-07-15 at 12.30.34 PM.png](https://pic.leetcode-cn.com/1626324037-vwjtBv-Screen%20Shot%202021-07-15%20at%2012.30.34%20PM.png)\n\n使用C静态数组可极大提速，也是本题的最优解：\n\n```cpp\nclass Solution {\npublic:\n    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n        const int INF = 0x3f3f3f3f;\n        int dist[n][n];\n        memset(dist,INF,sizeof(dist));\n        for(int i=0;i<n;i++)\n        dist[i][i]=0;\n        for(int i=0;i<edges.size();i++){\n            dist[edges[i][0]][edges[i][1]]=edges[i][2];\n            dist[edges[i][1]][edges[i][0]]=edges[i][2];\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n                }\n            }\n        }\n        int id=-1, minCnt=INF;\n        for(int i=0;i<n;i++){\n            int cnt=0;\n            for(int j=0;j<n;j++){\n                if(dist[i][j]<=distanceThreshold)\n                    cnt++;\n            }\n            if(cnt<=minCnt){\n                minCnt=cnt;\n                id=i;\n            }\n        }\n        return id;\n    }\n};\n```\n\n\n执行效率：\n\n执行用时：20 ms, 在所有 C++ 提交中击败了99.61%的用户\n\n内存消耗：11.3 MB, 在所有 C++ 提交中击败了93.39%的用户\n\n![Screen Shot 2021-07-16 at 5.31.45 PM.png](https://pic.leetcode-cn.com/1626443000-bJUZar-Screen%20Shot%202021-07-16%20at%205.31.45%20PM.png)\n\n\n**方法二：Dijkstra**\n利用优先队列替换for循环是另一种写法，第二栏是priority_queue版，实测本题使用priority_queue运行速度反而下降。\n\n邻接矩阵版：\n\n```C++ []\nclass Solution {\npublic:\n    void Dijkstra(vector<vector<int>>& graph, vector<int>& distances, vector<bool>& visited, int n, int distanceThreshold, int start) {\n        distances[start] = 0; //自身到自身的距离为0\n        for (int i=0; i<n; ++i) {\n            int u=-1, minDis = INT_MAX;\n            for (int j=0; j<n; ++j) {\n                if (!visited[j] && distances[j] < minDis) {\n                    u = j;\n                    minDis = distances[j];\n                }\n            }\n            if (u==-1) return; //所有点不可达\n            visited[u] = true;\n            for (int v=0; v<n; ++v) {\n                if (!visited[v] && graph[u][v] != INT_MAX) {\n                    if (distances[u] + graph[u][v] < distances[v]) {\n                        distances[v] = distances[u] + graph[u][v];\n                    }\n                }\n            }\n        }\n    }\n    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n        vector<vector<int>>graph(n,vector<int>(n,INT_MAX)); //邻接矩阵\n        for (vector<int> edge : edges) {\n            int u=edge[0], v=edge[1], w=edge[2];\n            graph[u][v] = graph[v][u] = w;\n        }\n        int idx = -1, minCount = INT_MAX;\n        for (int i=0; i<n; ++i) {\n            vector<int>distances(n,INT_MAX); //单源最短路径数组\n            vector<bool>visited(n,false);\n            Dijkstra(graph, distances, visited, n, distanceThreshold, i);\n            int count = 0; //小于等于距离阈值的城市个数\n            for (int j=0; j<n; ++j) {\n                if (distances[j]<=distanceThreshold && i!=j) {\n                    count++;\n                }\n            }\n            if (count <= minCount) {\n                minCount = count;\n                idx = i;\n            }\n        }\n        return idx;\n    }\n};\n```\n```C++ []\nclass Solution { //优先队列版\npublic:\n    void Dijkstra(vector<vector<int>>& graph, vector<int>& distances, int n, int distanceThreshold, int start) {\n        //小顶堆，按照距离dist从小到大排序，pair中first存dist\n        priority_queue <pair<int, int>,vector<pair<int, int>>, greater<pair<int, int>>> q;\n        distances[start] = 0;\n        q.push({distances[start],start});\n        while (!q.empty()) {\n            pair<int, int>p = q.top();\n            int u = p.second;\n            q.pop();\n            if (distances[u] < p.first) {\n                continue;\n            }\n            for (int v=0; v<n; ++v) {\n                if (graph[u][v] != INT_MAX && distances[v]>distances[u]+graph[u][v]) {\n                    distances[v]=distances[u]+graph[u][v];\n                        q.push({distances[v],v});\n                }\n            }\n        }\n    }\n    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n        vector<vector<int>>graph(n,vector<int>(n,INT_MAX)); //邻接矩阵\n        for (vector<int> edge : edges) {\n            int u=edge[0], v=edge[1], w=edge[2];\n            graph[u][v] = graph[v][u] = w;\n        }\n        int idx = -1, minCount = INT_MAX;\n        for (int i=0; i<n; ++i) {\n            vector<int>distances(n,INT_MAX); //单源最短路径数组\n            Dijkstra(graph, distances, n, distanceThreshold, i);\n            int count = 0; //小于等于距离阈值的城市个数\n            for (int j=0; j<n; ++j) {\n                if (distances[j]<=distanceThreshold && i!=j) {\n                    count++;\n                }\n            }\n            if (count <= minCount) {\n                minCount = count;\n                idx = i;\n            }\n        }\n        return idx;\n    }\n};\n```\n\n\n执行效率：\n\n执行用时：68 ms, 在所有 C++ 提交中击败了73.66%的用户\n\n内存消耗：12.6 MB, 在所有 C++ 提交中击败了17.55%的用户\n\n![Screen Shot 2021-07-15 at 12.32.30 PM.png](https://pic.leetcode-cn.com/1626324235-QJsTRT-Screen%20Shot%202021-07-15%20at%2012.32.30%20PM.png)\n\n使用静态数组可极大提速\n```cpp\nclass Solution {\npublic:\n    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n        const int INF = 0x3f3f3f3f;\n        int graph[n][n];\n        memset(graph,INF,sizeof(graph));\n        int dist[n];\n        bool vis[n];\n        for (vector<int> edge : edges) {\n            int u=edge[0], v=edge[1], w=edge[2];\n            graph[u][v] = graph[v][u] = w;\n        }\n        int idx = -1, minCnt = INF;\n        for (int i=0; i<n; ++i) {\n            memset(dist, INF, sizeof(dist));\n            dist[i] = 0; //自身到自身的距离为0\n            memset(vis, false, sizeof(vis));\n            for (int j=0; j<n; ++j) {\n                int u=-1, minDis = INF;\n                for (int k=0; k<n; ++k) {\n                    if (!vis[k] && dist[k] < minDis) {\n                        u = k;\n                        minDis = dist[k];\n                    }\n                }\n                if (u==-1) {\n                    break; //所有点不可达，直接结束，加速代码进程\n                }\n                vis[u] = true;\n                for (int v=0; v<n; ++v) {\n                    if (!vis[v]) {\n                        dist[v] = min(dist[v], dist[u] + graph[u][v]);\n                    }\n                }\n            }\n            int cnt = 0;\n            for (int j=0; j<n; ++j) {\n                if (dist[j] <= distanceThreshold && i != j) {\n                    cnt++;\n                }\n            }\n            if (cnt <= minCnt) {\n                minCnt = cnt;\n                idx = i;\n            }\n        }\n        return idx;\n    }\n};\n```\n执行效率：\n\n执行用时：28 ms, 在所有 C++ 提交中击败了97.67%的用户\n\n内存消耗：11.8 MB, 在所有 C++ 提交中击败了47.47%的用户\n\n![Screen Shot 2021-07-16 at 9.34.24 PM.png](https://pic.leetcode-cn.com/1626442958-BCMYSr-Screen%20Shot%202021-07-16%20at%209.34.24%20PM.png)\n\n\n邻接表版：\n```cpp\nclass Solution {\npublic:\n    void Dijkstra(vector<vector<pair<int, int>>>&graph, vector<int>& distances, vector<bool>& visited, int n, int distanceThreshold, int start) {\n        distances[start] = 0; //自身到自身的距离为0\n        for (int i=0; i<n; ++i) {\n            int u=-1, minDis = INT_MAX;\n            for (int j=0; j<n; ++j) {\n                if (!visited[j] && distances[j] < minDis) {\n                    u = j;\n                    minDis = distances[j];\n                }\n            }\n            if (u==-1) return; //所有点不可达\n            visited[u] = true;\n            for (int j=0; j<graph[u].size(); ++j) {\n                int v = graph[u][j].first;\n                int w = graph[u][j].second;\n                if (!visited[v]) {\n                    if (distances[u] + w < distances[v]) {\n                        distances[v] = distances[u] + w;\n                    }\n                }\n            }\n        }\n    }\n    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n        vector<vector<pair<int, int>>>graph(n); //邻接表\n        for (vector<int> edge : edges) {\n            int u=edge[0], v=edge[1], w=edge[2];\n            graph[u].push_back(make_pair(v, w));\n            graph[v].push_back(make_pair(u, w));\n        }\n        int idx = -1, minCount = INT_MAX;\n        for (int i=0; i<n; ++i) {\n            vector<int>distances(n,INT_MAX); //单源最短路径数组\n            vector<bool>visited(n,false);\n            Dijkstra(graph, distances, visited, n, distanceThreshold, i);\n            int count = 0; //小于等于距离阈值的城市个数\n            for (int j=0; j<n; ++j) {\n                if (distances[j]<=distanceThreshold && i!=j) {\n                    count++;\n                }\n            }\n            if (count <= minCount) {\n                minCount = count;\n                idx = i;\n            }\n        }\n        return idx;\n    }\n};\n```\n\n执行效率：\n\n执行用时：52 ms, 在所有 C++ 提交中击败了80.92%的用户\n\n内存消耗：13.2 MB, 在所有 C++ 提交中击败了15.65%的用户\n\n![Screen Shot 2021-07-15 at 12.31.31 PM.png](https://pic.leetcode-cn.com/1626324345-DJgLXy-Screen%20Shot%202021-07-15%20at%2012.31.31%20PM.png)\n\n\n**方法三：Bellman-Ford**\n\n注意：\n1.这里用到边表，但是不能直接用题目给的vector<vector<int>>& edges，必须要自己构建vector<Edge>& edges，Edge是结构体，否则会超时。\n2.题目给的是无向边，每条无向边实际上是两条有向边，分析时注意。\n\nBellman-Ford可根据距离判断图有没有负环，本题无需判断负环，模板中舍去。\n\n```cpp\nclass Solution {\npublic:\n    struct Edge{\n        int from;\n        int to;\n        int weight;\n    };\n    void BellmanFord(vector<Edge>& edges, vector<int>& distances, int n, int start) {\n        distances[start] = 0;\n        for(auto& e:edges){\n            if(e.from == start) distances[e.to] = e.weight;\n        }\n        for(int i=0; i<n-1; ++i){\n            for(auto& e:edges){\n                if(distances[e.from] != INT_MAX && distances[e.to] > distances[e.from]+e.weight)\n                    distances[e.to] = distances[e.from]+e.weight;\n            }\n        }\n    }\n    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n        vector<Edge> evec;\n        for (vector<int> e: edges) {\n            Edge e1,e2;\n            e1.from = e[0]; e1.to = e[1]; e1.weight = e[2];\n            e2.from = e[1]; e2.to = e[0]; e2.weight = e[2];\n            evec.emplace_back(e1); evec.emplace_back(e2);\n        }\n        int idx = -1, minCount = INT_MAX;\n        for (int i=0; i<n; ++i) {\n            vector<int>distances(n,INT_MAX); //单源最短路径数组\n            BellmanFord(evec, distances, n, i);\n            int count = 0; //小于等于距离阈值的城市个数\n            for (int j=0; j<n; ++j) {\n                if (distances[j]<=distanceThreshold && i!=j) {\n                    count++;\n                }\n            }\n            if (count <= minCount) {\n                minCount = count;\n                idx = i;\n            }\n        }\n        return idx;\n    }\n};\n```\n执行效率：\n\n执行用时：956 ms, 在所有 C++ 提交中击败了5.38%的用户\n\n内存消耗：13 MB, 在所有 C++ 提交中击败了16.16%的用户\n\n![Screen Shot 2021-07-15 at 12.29.54 PM.png](https://pic.leetcode-cn.com/1626324771-WYvzSb-Screen%20Shot%202021-07-15%20at%2012.29.54%20PM.png)\n\n\n**方法四：SPFA**\nBellman-Ford的优化，利用队列优化，队列升级为优先队列可进一步加速，有空更新SPFA的priority_queue加速版。\nSPFA可根据顶点入队次数判断有没有负环，本题无需判断负环，模板中顶点入队次数数组舍去。\n\n邻接表版(数组表示)\n```cpp\nclass Solution {\npublic:\n    void SPFA(vector<vector<pair<int, int>>>& graph, vector<int>& distances, vector<bool>& inQueue, int start) {\n        queue<int>q;\n        q.push(start); //源点入队\n        distances[start] = 0;\n        inQueue[start] = true; //源点已入队\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            inQueue[u] = false; //已出队\n            for (int k=0; k<graph[u].size(); ++k) {\n                int v = graph[u][k].first;\n                int w = graph[u][k].second;\n                if (distances[u] + w < distances[v]) {\n                    distances[v] = distances[u] + w;\n                    if (!inQueue[v]) {\n                        q.push(v);\n                        inQueue[v] = true;\n                    }\n                }\n            }\n        }\n    }\n    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n        vector<vector<pair<int, int>>>graph(n); //邻接表\n        for (vector<int> edge : edges) {\n            int u=edge[0], v=edge[1], w=edge[2];\n            graph[u].push_back(make_pair(v, w));\n            graph[v].push_back(make_pair(u, w));\n        }\n        int idx = -1, minCount = INT_MAX;\n        for (int i=0; i<n; ++i) {\n            vector<int>distances(n,INT_MAX); //单源最短路径数组\n            vector<bool>inQueue(n,false); //顶点是否在队列中\n            SPFA(graph, distances, inQueue, i);\n            int count = 0; //小于等于距离阈值的城市个数\n            for (int j=0; j<n; ++j) {\n                if (distances[j]<=distanceThreshold && i!=j) {\n                    count++;\n                }\n            }\n            if (count <= minCount) {\n                minCount = count;\n                idx = i;\n            }\n        }\n        return idx;\n    }\n};\n```\n执行效率：\n\n执行用时：72 ms, 在所有 C++ 提交中击败了61.68%的用户\n\n内存消耗：14.3 MB, 在所有 C++ 提交中击败了16.60%的用户\n\n![Screen Shot 2021-07-29 at 9.52.59 PM.png](https://pic.leetcode-cn.com/1627566943-lsPuPI-Screen%20Shot%202021-07-29%20at%209.52.59%20PM.png)\n\n\n邻接表版(静态链表表示）\n```cpp\nclass Solution {\n    static constexpr int MAXN = 1100, MAXM = MAXN*(MAXN-1)/2;\npublic:\n    struct Edge{\n        int from;\n        int to;\n        int weight;\n        int next;\n    }e[MAXM];\n    int head[MAXN];\n    int t;\n    void add(int u, int v, int w) {\n        e[t].from = u;\n        e[t].to = v;\n        e[t].weight = w;\n        e[t].next = head[u];\n        head[u] = t++;\n    }\n    void SPFA(vector<int>& distances, vector<bool>& visited, int start) {\n        queue<int>q;\n        q.push(start);\n        distances[start] = 0;\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            visited[u] = false;\n            for (int i=head[u]; i!=-1; i=e[i].next) {\n                int v = e[i].to;\n                if (distances[v]>distances[u]+e[i].weight) {\n                    distances[v] = distances[u]+e[i].weight;\n                    if (!visited[v]) {\n                        visited[v] = true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n        t = 0;\n        memset(head, -1, sizeof(head));\n        for (vector<int> e: edges) { //添加所有无向边\n            add(e[0], e[1], e[2]);\n            add(e[1], e[0], e[2]);\n        }\n        int idx = -1, minCount = INT_MAX;\n        for (int i=0; i<n; ++i) {\n            vector<int>distances(n,INT_MAX); //单源最短路径数组\n            vector<bool>visited(n,false);\n            SPFA(distances, visited, i);\n            int count = 0; //小于等于距离阈值的城市个数\n            for (int j=0; j<n; ++j) {\n                if (distances[j]<=distanceThreshold && i!=j) {\n                    count++;\n                }\n            }\n            if (count <= minCount) {\n                minCount = count;\n                idx = i;\n            }\n        }\n        return idx;\n    }\n};\n```\n执行效率：\n\n执行用时：72 ms, 在所有 C++ 提交中击败了72.31%的用户\n\n内存消耗：23.7 MB, 在所有 C++ 提交中击败了5.39%的用户\n\n![Screen Shot 2021-07-15 at 12.30.34 PM.png](https://pic.leetcode-cn.com/1626324893-gPYSnP-Screen%20Shot%202021-07-15%20at%2012.30.34%20PM.png)\n\n### 总结\n\n执行效率最高的是Floyd和Dijkstra：\n在使用vector的情况下，Dijkstra快于Floyd；\n在使用C静态数组的情况下，Floyd快于Dijkstra；\nC静态数组大大快于vector。\n\n执行效率最低的是Bellman-Ford。\n\n***吐血模板大总结，有空将持续更新。***\n\n**原创不易，欢迎收藏点赞评论。**",
      "createdAt": "2021-07-15T04:57:09.556067+00:00",
      "hitCount": 1484,
      "identifier": "IUPPus",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "yu-zhi-ju-chi-nei-lin-ju-zui-shao-de-cheng-shi-flo",
        "title": "【阈值距离内邻居最少的城市】：Floyd插点法，详解 + 答疑"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 16,
          "reactionType": "UPVOTE"
        }
      ],
      "rewardEnabled": null,
      "slug": "zui-duan-lu-jing-mo-ban-da-ji-he-cban-fl-gs7u",
      "status": "PUBLISHED",
      "summary": "解题思路\n单源最短路径问题：Dijkstra、Bellman-Ford、SPFA\n全源最短路径问题：Floyd\n模板参考：《算法笔记》\n所有算法代码附有本题执行结果图片，读者可以自行比对。\n方法一：Floyd\n执行效率：\n执行用时：84 ms, 在所有 C++ 提交中击败了64.89%的用户\n内存消耗：12.2 MB,",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Dijkstra",
          "nameTranslated": "",
          "slug": "dijkstra",
          "tagType": "ADDITIONAL_TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Floyd",
          "nameTranslated": "",
          "slug": "floyd",
          "tagType": "ADDITIONAL_TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Bellman-Ford",
          "nameTranslated": "",
          "slug": "bellman-ford",
          "tagType": "ADDITIONAL_TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "SPFA",
          "nameTranslated": "",
          "slug": "spfa",
          "tagType": "ADDITIONAL_TOPIC"
        }
      ],
      "thumbnail": "https://pic.leetcode-cn.com/1626324037-vwjtBv-Screen%20Shot%202021-07-15%20at%2012.30.34%20PM.png",
      "title": "1334. 最短路径（Floyd/Dijkstra/Bellman-Ford/SPFA）模板大集合 C++ 版 ",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 1,
        "id": 877013,
        "viewCount": 978
      },
      "uuid": "IUPPus",
      "videosInfo": []
    }
  }
}
