{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "åŠ›æ‰£å®˜æ–¹é¢˜è§£",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/leetcode-solution/avatar_1582018938.png",
          "userSlug": "leetcode-solution"
        },
        "username": "LeetCode-Solution"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "### ğŸ“º è§†é¢‘é¢˜è§£ \n![112. è·¯å¾„æ€»å’Œ.mp4](fa34574c-0a90-48e9-8487-01d91349aade)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### å†™åœ¨å‰é¢\n\næ³¨æ„åˆ°æœ¬é¢˜çš„è¦æ±‚æ˜¯ï¼Œè¯¢é—®æ˜¯å¦æœ‰ä»ã€Œæ ¹èŠ‚ç‚¹ã€åˆ°æŸä¸ªã€Œå¶å­èŠ‚ç‚¹ã€ç»è¿‡çš„è·¯å¾„ä¸Šçš„èŠ‚ç‚¹ä¹‹å’Œç­‰äºç›®æ ‡å’Œã€‚æ ¸å¿ƒæ€æƒ³æ˜¯å¯¹æ ‘è¿›è¡Œä¸€æ¬¡éå†ï¼Œåœ¨éå†æ—¶è®°å½•ä»æ ¹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„å’Œï¼Œä»¥é˜²æ­¢é‡å¤è®¡ç®—ã€‚\n\n> éœ€è¦ç‰¹åˆ«æ³¨æ„çš„æ˜¯ï¼Œç»™å®šçš„ `root` å¯èƒ½ä¸ºç©ºã€‚\n\n#### æ–¹æ³•ä¸€ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢\n\n**æ€è·¯åŠç®—æ³•**\n\né¦–å…ˆæˆ‘ä»¬å¯ä»¥æƒ³åˆ°ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢çš„æ–¹å¼ï¼Œè®°å½•ä»æ ¹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„å’Œï¼Œä»¥é˜²æ­¢é‡å¤è®¡ç®—ã€‚\n\nè¿™æ ·æˆ‘ä»¬ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—ï¼Œåˆ†åˆ«å­˜å‚¨å°†è¦éå†çš„èŠ‚ç‚¹ï¼Œä»¥åŠæ ¹èŠ‚ç‚¹åˆ°è¿™äº›èŠ‚ç‚¹çš„è·¯å¾„å’Œå³å¯ã€‚\n\n<![fig1](https://assets.leetcode-cn.com/solution-static/112/1.png),![fig2](https://assets.leetcode-cn.com/solution-static/112/2.png),![fig3](https://assets.leetcode-cn.com/solution-static/112/3.png),![fig4](https://assets.leetcode-cn.com/solution-static/112/4.png),![fig5](https://assets.leetcode-cn.com/solution-static/112/5.png),![fig6](https://assets.leetcode-cn.com/solution-static/112/6.png),![fig7](https://assets.leetcode-cn.com/solution-static/112/7.png),![fig8](https://assets.leetcode-cn.com/solution-static/112/8.png),![fig9](https://assets.leetcode-cn.com/solution-static/112/9.png),![fig10](https://assets.leetcode-cn.com/solution-static/112/10.png),![fig11](https://assets.leetcode-cn.com/solution-static/112/11.png),![fig12](https://assets.leetcode-cn.com/solution-static/112/12.png)>\n\n**ä»£ç **\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode *root, int sum) {\n        if (root == nullptr) {\n            return false;\n        }\n        queue<TreeNode *> que_node;\n        queue<int> que_val;\n        que_node.push(root);\n        que_val.push(root->val);\n        while (!que_node.empty()) {\n            TreeNode *now = que_node.front();\n            int temp = que_val.front();\n            que_node.pop();\n            que_val.pop();\n            if (now->left == nullptr && now->right == nullptr) {\n                if (temp == sum) {\n                    return true;\n                }\n                continue;\n            }\n            if (now->left != nullptr) {\n                que_node.push(now->left);\n                que_val.push(now->left->val + temp);\n            }\n            if (now->right != nullptr) {\n                que_node.push(now->right);\n                que_val.push(now->right->val + temp);\n            }\n        }\n        return false;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if (root == null) {\n            return false;\n        }\n        Queue<TreeNode> queNode = new LinkedList<TreeNode>();\n        Queue<Integer> queVal = new LinkedList<Integer>();\n        queNode.offer(root);\n        queVal.offer(root.val);\n        while (!queNode.isEmpty()) {\n            TreeNode now = queNode.poll();\n            int temp = queVal.poll();\n            if (now.left == null && now.right == null) {\n                if (temp == sum) {\n                    return true;\n                }\n                continue;\n            }\n            if (now.left != null) {\n                queNode.offer(now.left);\n                queVal.offer(now.left.val + temp);\n            }\n            if (now.right != null) {\n                queNode.offer(now.right);\n                queVal.offer(now.right.val + temp);\n            }\n        }\n        return false;\n    }\n}\n```\n\n```golang [sol1-Golang]\nfunc hasPathSum(root *TreeNode, sum int) bool {\n    if root == nil {\n        return false\n    }\n    queNode := []*TreeNode{}\n    queVal := []int{}\n    queNode = append(queNode, root)\n    queVal = append(queVal, root.Val)\n    for len(queNode) != 0 {\n        now := queNode[0]\n        queNode = queNode[1:]\n        temp := queVal[0]\n        queVal = queVal[1:]\n        if now.Left == nil && now.Right == nil {\n            if temp == sum {\n                return true\n            }\n            continue\n        }\n        if now.Left != nil {\n            queNode = append(queNode, now.Left)\n            queVal = append(queVal, now.Left.Val + temp)\n        }\n        if now.Right != nil {\n            queNode = append(queNode, now.Right)\n            queVal = append(queVal, now.Right.Val + temp)\n        }\n    }\n    return false\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\n        if not root:\n            return False\n        que_node = collections.deque([root])\n        que_val = collections.deque([root.val])\n        while que_node:\n            now = que_node.popleft()\n            temp = que_val.popleft()\n            if not now.left and not now.right:\n                if temp == sum:\n                    return True\n                continue\n            if now.left:\n                que_node.append(now.left)\n                que_val.append(now.left.val + temp)\n            if now.right:\n                que_node.append(now.right)\n                que_val.append(now.right.val + temp)\n        return False\n```\n\n```C [sol1-C]\ntypedef struct queNode {\n    int val;\n    struct TreeNode *node;\n    struct queNode *next;\n} queNode;\n\nvoid init(struct queNode **p, int val, struct TreeNode *node) {\n    (*p) = (struct queNode *)malloc(sizeof(struct queNode));\n    (*p)->val = val;\n    (*p)->node = node;\n    (*p)->next = NULL;\n}\n\nbool hasPathSum(struct TreeNode *root, int sum) {\n    if (root == NULL) {\n        return false;\n    }\n    struct queNode *queLeft, *queRight;\n    init(&queLeft, root->val, root);\n    queRight = queLeft;\n    while (queLeft != NULL) {\n        struct TreeNode *now = queLeft->node;\n        int temp = queLeft->val;\n        if (now->left == NULL && now->right == NULL) {\n            if (temp == sum) return true;\n        }\n        if (now->left != NULL) {\n            init(&queRight->next, now->left->val + temp, now->left);\n            queRight = queRight->next;\n        }\n        if (now->right != NULL) {\n            init(&queRight->next, now->right->val + temp, now->right);\n            queRight = queRight->next;\n        }\n        queLeft = queLeft->next;\n    }\n    return false;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ æ˜¯æ ‘çš„èŠ‚ç‚¹æ•°ã€‚å¯¹æ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡ã€‚\n  \n- ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ æ˜¯æ ‘çš„èŠ‚ç‚¹æ•°ã€‚ç©ºé—´å¤æ‚åº¦ä¸»è¦å–å†³äºé˜Ÿåˆ—çš„å¼€é”€ï¼Œé˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ªæ•°ä¸ä¼šè¶…è¿‡æ ‘çš„èŠ‚ç‚¹æ•°ã€‚\n\n#### æ–¹æ³•äºŒï¼šé€’å½’\n\n**æ€è·¯åŠç®—æ³•**\n\nè§‚å¯Ÿè¦æ±‚æˆ‘ä»¬å®Œæˆçš„å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥å½’çº³å‡ºå®ƒçš„åŠŸèƒ½ï¼šè¯¢é—®æ˜¯å¦å­˜åœ¨ä»å½“å‰èŠ‚ç‚¹ `root` åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œæ»¡è¶³å…¶è·¯å¾„å’Œä¸º `sum`ã€‚\n\nå‡å®šä»æ ¹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„å€¼ä¹‹å’Œä¸º `val`ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªå¤§é—®é¢˜è½¬åŒ–ä¸ºä¸€ä¸ªå°é—®é¢˜ï¼šæ˜¯å¦å­˜åœ¨ä»å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹åˆ°å¶å­çš„è·¯å¾„ï¼Œæ»¡è¶³å…¶è·¯å¾„å’Œä¸º `sum - val`ã€‚ \n\nä¸éš¾å‘ç°è¿™æ»¡è¶³é€’å½’çš„æ€§è´¨ï¼Œè‹¥å½“å‰èŠ‚ç‚¹å°±æ˜¯å¶å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç›´æ¥åˆ¤æ–­ `sum` æ˜¯å¦ç­‰äº `val` å³å¯ï¼ˆå› ä¸ºè·¯å¾„å’Œå·²ç»ç¡®å®šï¼Œå°±æ˜¯å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œæˆ‘ä»¬åªéœ€è¦åˆ¤æ–­è¯¥è·¯å¾„å’Œæ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼‰ã€‚è‹¥å½“å‰èŠ‚ç‚¹ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬åªéœ€è¦é€’å½’åœ°è¯¢é—®å®ƒçš„å­èŠ‚ç‚¹æ˜¯å¦èƒ½æ»¡è¶³æ¡ä»¶å³å¯ã€‚\n\n**ä»£ç **\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode *root, int sum) {\n        if (root == nullptr) {\n            return false;\n        }\n        if (root->left == nullptr && root->right == nullptr) {\n            return sum == root->val;\n        }\n        return hasPathSum(root->left, sum - root->val) ||\n               hasPathSum(root->right, sum - root->val);\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if (root == null) {\n            return false;\n        }\n        if (root.left == null && root.right == null) {\n            return sum == root.val;\n        }\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\n    }\n}\n```\n\n```golang [sol2-Golang]\nfunc hasPathSum(root *TreeNode, sum int) bool {\n    if root == nil {\n        return false\n    }\n    if root.Left == nil && root.Right == nil {\n        return sum == root.Val\n    }\n    return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val)\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\n        if not root:\n            return False\n        if not root.left and not root.right:\n            return sum == root.val\n        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\n```\n\n```C [sol2-C]\nbool hasPathSum(struct TreeNode *root, int sum) {\n    if (root == NULL) {\n        return false;\n    }\n    if (root->left == NULL && root->right == NULL) {\n        return sum == root->val;\n    }\n    return hasPathSum(root->left, sum - root->val) ||\n           hasPathSum(root->right, sum - root->val);\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ æ˜¯æ ‘çš„èŠ‚ç‚¹æ•°ã€‚å¯¹æ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡ã€‚\n  \n- ç©ºé—´å¤æ‚åº¦ï¼š$O(H)$ï¼Œå…¶ä¸­ $H$ æ˜¯æ ‘çš„é«˜åº¦ã€‚ç©ºé—´å¤æ‚åº¦ä¸»è¦å–å†³äºé€’å½’æ—¶æ ˆç©ºé—´çš„å¼€é”€ï¼Œæœ€åæƒ…å†µä¸‹ï¼Œæ ‘å‘ˆç°é“¾çŠ¶ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(N)$ã€‚å¹³å‡æƒ…å†µä¸‹æ ‘çš„é«˜åº¦ä¸èŠ‚ç‚¹æ•°çš„å¯¹æ•°æ­£ç›¸å…³ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(\\log N)$ã€‚",
      "createdAt": "2020-07-06T12:31:47.646895+00:00",
      "hitCount": 121421,
      "identifier": "az2r55",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "lu-jing-zong-he-de-si-chong-jie-fa-dfs-hui-su-bfs-",
        "title": "è·¯å¾„æ€»å’Œçš„å››ç§è§£æ³•ï¼šDFSã€å›æº¯ã€BFSã€æ ˆ"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "path-sum"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 123,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 11,
          "reactionType": "AWESOME"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 4,
          "reactionType": "THUMBS_DOWN"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 3,
          "reactionType": "CONFUSED"
        }
      ],
      "rewardEnabled": null,
      "slug": "lu-jing-zong-he-by-leetcode-solution",
      "status": "PUBLISHED",
      "summary": "ğŸ“º è§†é¢‘é¢˜è§£ ğŸ“– æ–‡å­—é¢˜è§£ å†™åœ¨å‰é¢ æ³¨æ„åˆ°æœ¬é¢˜çš„è¦æ±‚æ˜¯ï¼Œè¯¢é—®æ˜¯å¦æœ‰ä»ã€Œæ ¹èŠ‚ç‚¹ã€åˆ°æŸä¸ªã€Œå¶å­èŠ‚ç‚¹ã€ç»è¿‡çš„è·¯å¾„ä¸Šçš„èŠ‚ç‚¹ä¹‹å’Œç­‰äºç›®æ ‡å’Œã€‚æ ¸å¿ƒæ€æƒ³æ˜¯å¯¹æ ‘è¿›è¡Œä¸€æ¬¡éå†ï¼Œåœ¨éå†æ—¶è®°å½•ä»æ ¹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„å’Œï¼Œä»¥é˜²æ­¢é‡å¤è®¡ç®—ã€‚ éœ€è¦ç‰¹åˆ«æ³¨æ„çš„æ˜¯ï¼Œç»™å®šçš„ root å¯èƒ½ä¸ºç©ºã€‚ æ–¹æ³•ä¸€ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢ æ€è·¯åŠç®—æ³• é¦–å…ˆæˆ‘ä»¬å¯ä»¥æƒ³åˆ°ä½¿ç”¨",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Tree",
          "nameTranslated": "æ ‘",
          "slug": "tree",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Depth-First Search",
          "nameTranslated": "æ·±åº¦ä¼˜å…ˆæœç´¢",
          "slug": "depth-first-search",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Breadth-First Search",
          "nameTranslated": "å¹¿åº¦ä¼˜å…ˆæœç´¢",
          "slug": "breadth-first-search",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C",
          "nameTranslated": "",
          "slug": "c",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Go",
          "nameTranslated": "",
          "slug": "golang",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python",
          "nameTranslated": "",
          "slug": "python",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "è·¯å¾„æ€»å’Œ",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 178,
        "id": 318487,
        "viewCount": 85658
      },
      "uuid": "az2r55",
      "videosInfo": [
        {
          "__typename": "VideoInfoNode",
          "coverUrl": "https://video.leetcode-cn.com/image/cover/3A24C49C7D6246F18DBC5A7DFAF24A25-6-2.png",
          "duration": 439.2533,
          "videoId": "141b4ef2d6ce4d239bfd4b59232cf9cc"
        }
      ]
    }
  }
}
