{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "力扣官方题解",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/leetcode-solution/avatar_1582018938.png",
          "userSlug": "leetcode-solution"
        },
        "username": "LeetCode-Solution"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "### 📺 视频题解  \n![...0. 只出现一次的数字 III-.mp4](127eb690-16fb-4f09-b414-4775f73c41fc)\n\n### 📖 文字题解\n\n#### 方法一：哈希表\n\n**思路与算法**\n\n我们可以使用一个哈希映射统计数组中每一个元素出现的次数。\n\n在统计完成后，我们对哈希映射进行遍历，将所有只出现了一次的数放入答案中。\n\n**代码**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        unordered_map<int, int> freq;\n        for (int num: nums) {\n            ++freq[num];\n        }\n        vector<int> ans;\n        for (const auto& [num, occ]: freq) {\n            if (occ == 1) {\n                ans.push_back(num);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n        int[] ans = new int[2];\n        int index = 0;\n        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {\n            if (entry.getValue() == 1) {\n                ans[index++] = entry.getKey();\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    public int[] SingleNumber(int[] nums) {\n        Dictionary<int, int> freq = new Dictionary<int, int>();\n        foreach (int num in nums) {\n            if (freq.ContainsKey(num)) {\n                ++freq[num];\n            } else {\n                freq.Add(num, 1);\n            }\n        }\n        int[] ans = new int[2];\n        int index = 0;\n        foreach (KeyValuePair<int, int> pair in freq) {\n            if (pair.Value == 1) {\n                ans[index++] = pair.Key;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        freq = Counter(nums)\n        return [num for num, occ in freq.items() if occ == 1]\n```\n\n```JavaScript [sol1-JavaScript]\nvar singleNumber = function(nums) {\n    const freq = new Map();\n    for (const num of nums) {\n        freq.set(num, (freq.get(num) || 0) + 1);\n    }\n    const ans = [];\n    for (const [num, occ] of freq.entries()) {\n        if (occ === 1) {\n            ans.push(num);\n        }\n    }\n    return ans;\n};\n```\n\n```TypeScript [sol1-TypeScript]\nfunction singleNumber(nums: number[]): number[] {\n    const freq = new Map();\n    for (const num of nums) {\n        freq.set(num, (freq.get(num) || 0) + 1);\n    }\n    const ans: number[] = [];\n    for (const [num, occ] of freq.entries()) {\n        if (occ === 1) {\n            ans.push(num);\n        }\n    }\n    return ans;\n};\n```\n\n```go [sol1-Golang]\nfunc singleNumber(nums []int) (ans []int) {\n    freq := map[int]int{}\n    for _, num := range nums {\n        freq[num]++\n    }\n    for num, occ := range freq {\n        if occ == 1 {\n            ans = append(ans, num)\n        }\n    }\n    return\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(n)$，即为哈希映射需要使用的空间。\n\n#### 方法二：位运算\n\n**思路与算法**\n\n在理解如何使用位运算解决本题前，读者需要首先掌握[「136. 只出现一次的数字」](https://leetcode-cn.com/problems/single-number/)中的位运算做法。\n\n假设数组 $\\textit{nums}$ 中只出现一次的元素分别是 $x_1$ 和 $x_2$。如果把 $\\textit{nums}$ 中的所有元素全部异或起来，得到结果 $x$，那么一定有：\n\n$$\nx = x_1 \\oplus x_2\n$$\n\n其中 $\\oplus$ 表示异或运算。这是因为 $\\textit{nums}$ 中出现两次的元素都会因为异或运算的性质 $a \\oplus b \\oplus b = a$ 抵消掉，那么最终的结果就只剩下 $x_1$ 和 $x_2$ 的异或和。\n\n$x$ 显然不会等于 $0$，因为如果 $x=0$，那么说明 $x_1 = x_2$，这样 $x_1$ 和 $x_2$ 就不是只出现一次的数字了。因此，我们可以使用位运算 $\\texttt{x \\& -x}$ 取出 $x$ 的二进制表示中最低位那个 $1$，设其为第 $l$ 位，那么 $x_1$ 和 $x_2$ 中的某一个数的二进制表示的第 $l$ 位为 $0$，另一个数的二进制表示的第 $l$ 位为 $1$。在这种情况下，$x_1 \\oplus x_2$ 的二进制表示的第 $l$ 位才能为 $1$。\n\n这样一来，我们就可以把 $\\textit{nums}$ 中的所有元素分成两类，其中一类包含所有二进制表示的第 $l$ 位为 $0$ 的数，另一类包含所有二进制表示的第 $l$ 位为 $1$ 的数。可以发现：\n\n- 对于任意一个在数组 $\\textit{nums}$ 中出现两次的元素，该元素的两次出现会被包含在同一类中；\n\n- 对于任意一个在数组 $\\textit{nums}$ 中只出现了一次的元素，即 $x_1$ 和 $x_2$，它们会被包含在不同类中。\n\n因此，如果我们将每一类的元素全部异或起来，那么其中一类会得到 $x_1$，另一类会得到 $x_2$。这样我们就找出了这两个只出现一次的元素。\n\n**代码**\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        int xorsum = 0;\n        for (int num: nums) {\n            xorsum ^= num;\n        }\n        // 防止溢出\n        int lsb = (xorsum == INT_MIN ? xorsum : xorsum & (-xorsum));\n        int type1 = 0, type2 = 0;\n        for (int num: nums) {\n            if (num & lsb) {\n                type1 ^= num;\n            }\n            else {\n                type2 ^= num;\n            }\n        }\n        return {type1, type2};\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        int xorsum = 0;\n        for (int num : nums) {\n            xorsum ^= num;\n        }\n        // 防止溢出\n        int lsb = (xorsum == Integer.MIN_VALUE ? xorsum : xorsum & (-xorsum));\n        int type1 = 0, type2 = 0;\n        for (int num : nums) {\n            if ((num & lsb) != 0) {\n                type1 ^= num;\n            } else {\n                type2 ^= num;\n            }\n        }\n        return new int[]{type1, type2};\n    }\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    public int[] SingleNumber(int[] nums) {\n        int xorsum = 0;\n        foreach (int num in nums) {\n            xorsum ^= num;\n        }\n        // 防止溢出\n        int lsb = (xorsum == int.MinValue ? xorsum : xorsum & (-xorsum));\n        int type1 = 0, type2 = 0;\n        foreach (int num in nums) {\n            if ((num & lsb) != 0) {\n                type1 ^= num;\n            } else {\n                type2 ^= num;\n            }\n        }\n        return new int[]{type1, type2};\n    }\n}\n```\n\n```Python [sol2-Python3]\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xorsum = 0\n        for num in nums:\n            xorsum ^= num\n        \n        lsb = xorsum & (-xorsum)\n        type1 = type2 = 0\n        for num in nums:\n            if num & lsb:\n                type1 ^= num\n            else:\n                type2 ^= num\n        \n        return [type1, type2]\n```\n\n```JavaScript [sol2-JavaScript]\nvar singleNumber = function(nums) {\n    let xorsum = 0;\n    \n    for (const num of nums) {\n        xorsum ^= num;\n    }\n    let type1 = 0, type2 = 0;\n    const lsb = xorsum & (-xorsum);\n    for (const num of nums) {\n        if (num & lsb) {\n            type1 ^= num;\n        } else {\n            type2 ^= num;\n        }\n    }\n    return [type1, type2];\n};\n```\n\n```go [sol2-Golang]\nfunc singleNumber(nums []int) []int {\n    xorSum := 0\n    for _, num := range nums {\n        xorSum ^= num\n    }\n    lsb := xorSum & -xorSum\n    type1, type2 := 0, 0\n    for _, num := range nums {\n        if num&lsb > 0 {\n            type1 ^= num\n        } else {\n            type2 ^= num\n        }\n    }\n    return []int{type1, type2}\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 空间复杂度：$O(1)$。",
      "createdAt": "2021-02-02T03:46:41.085591+00:00",
      "hitCount": 43899,
      "identifier": "faJKzL",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "cai-yong-fen-zhi-de-si-xiang-jiang-wen-ti-jiang-we",
        "title": "采用分治的思想将问题降维"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "single-number-iii"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 76,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 11,
          "reactionType": "AWESOME"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 2,
          "reactionType": "CONFUSED"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 1,
          "reactionType": "THUMBS_DOWN"
        }
      ],
      "rewardEnabled": null,
      "slug": "zhi-chu-xian-yi-ci-de-shu-zi-iii-by-leet-4i8e",
      "status": "PREPUBLISH",
      "summary": "📺 视频题解 📖 文字题解 方法一：哈希表 思路与算法 我们可以使用一个哈希映射统计数组中每一个元素出现的次数。 在统计完成后，我们对哈希映射进行遍历，将所有只出现了一次的数放入答案中。 代码 C++ [sol1-C++] class Solution { public:     vector<int> singleN",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Bit Manipulation",
          "nameTranslated": "位运算",
          "slug": "bit-manipulation",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Array",
          "nameTranslated": "数组",
          "slug": "array",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Hash Table",
          "nameTranslated": "哈希表",
          "slug": "hash-table",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C#",
          "nameTranslated": "",
          "slug": "csharp",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Go",
          "nameTranslated": "",
          "slug": "golang",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "JavaScript",
          "nameTranslated": "",
          "slug": "javascript",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python",
          "nameTranslated": "",
          "slug": "python",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "TypeScript",
          "nameTranslated": "",
          "slug": "typescript",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "只出现一次的数字 III",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 137,
        "id": 587516,
        "viewCount": 29713
      },
      "uuid": "faJKzL",
      "videosInfo": [
        {
          "__typename": "VideoInfoNode",
          "coverUrl": "https://video.leetcode-cn.com/image/cover/D917F6394E104C9CB89D4ED1AF172D4A-6-2.png",
          "duration": 212.2667,
          "videoId": "6c09e7ee7d6c4f3db503583ccd1f2afc"
        }
      ]
    }
  }
}
