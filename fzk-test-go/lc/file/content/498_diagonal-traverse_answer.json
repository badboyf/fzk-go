{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "力扣 (LeetCode)",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2021/03/73c9f099-abbe-4d94-853f-f8abffd459cd/leetcode.png",
          "userSlug": "leetcode"
        },
        "username": "LeetCode"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "#### 方法一：对角线迭代和翻转\n\n**思路**\n\n解决许多复杂问题的常见策略是首先解决该问题的简化问题，然后考虑从简化问题到原始问题需要做哪些修改，方法一就是这种思路。首先考虑按照逐条对角线打印元素，而不考虑翻转的情况。\n\n![](https://pic.leetcode-cn.com/Figures/498/img1.png)\n\n在第一行最后一列的元素作为起点的对角线上，对于给定元素 $[i, j]$，可以向右移动一行向上移动一列沿对角线向上移动 $[i - 1, j + 1]$，也可以向左移动一行向下移动一列沿对角线向下移动 $[i + 1, j - 1]$。*注意：这种移动方式仅适用于从右往左的对角线。*\n\n该问题比原始问题简单，没有考虑对角线打印顺序的情况。因此，这就是简化问题需要修改的地方。\n\n> 将元素添加到最终结果数组之前，只需要翻转奇数对角线上的元素顺序即可。例如：从左边开始的第三条对角线 [3, 7, 11]，将这些元素添加到最后结果之前先翻转为 [11, 7, 3] 再添加即可。\n\n**算法**\n\n1. 初始化数组 `result`，用于存储最后结果。\n\n2. 使用一个外层循环遍历所有的对角线。第一行和最后一列的元素都是对角线的起点。\n\n3. 使用一个内层 while 循环遍历对角线上的所有元素。可以计算指定对角线上的元素数量，也可以简单迭代直到索引超出范围。\n\n4. 因为不知道每条对角线上的元素数量，需要为每条对角线分配一个列表或动态数组。但是同样也可以通过计算得到当前对角线上的元素数量。\n\n5. 对于奇数编号的对角线，只需要将迭代结果翻转再加入结果数组即可。\n\n![](https://pic.leetcode-cn.com/Figures/498/img2.png)\n\n```java [solution1-Java]\nclass Solution {\n    public int[] findDiagonalOrder(int[][] matrix) {\n        \n        // Check for empty matrices\n        if (matrix == null || matrix.length == 0) {\n            return new int[0];\n        }\n        \n        // Variables to track the size of the matrix\n        int N = matrix.length;\n        int M = matrix[0].length;\n        \n        // The two arrays as explained in the algorithm\n        int[] result = new int[N*M];\n        int k = 0;\n        ArrayList<Integer> intermediate = new ArrayList<Integer>();\n        \n        // We have to go over all the elements in the first\n        // row and the last column to cover all possible diagonals\n        for (int d = 0; d < N + M - 1; d++) {\n            \n            // Clear the intermediate array every time we start\n            // to process another diagonal\n            intermediate.clear();\n            \n            // We need to figure out the \"head\" of this diagonal\n            // The elements in the first row and the last column\n            // are the respective heads.\n            int r = d < M ? 0 : d - M + 1;\n            int c = d < M ? d : M - 1;\n            \n            // Iterate until one of the indices goes out of scope\n            // Take note of the index math to go down the diagonal\n            while (r < N && c > -1) {\n                \n                intermediate.add(matrix[r][c]);\n                ++r;\n                --c;\n            }\n                \n            // Reverse even numbered diagonals. The\n            // article says we have to reverse odd \n            // numbered articles but here, the numbering\n            // is starting from 0 :P\n            if (d % 2 == 0) {\n                Collections.reverse(intermediate);\n            }\n            \n            for (int i = 0; i < intermediate.size(); i++) {\n                result[k++] = intermediate.get(i);\n            }\n        }\n        return result;\n    }\n}\n```\n\n```python [solution1-Python]\nclass Solution:\n    \n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\n        \n        # Check for empty matrices\n        if not matrix or not matrix[0]:\n            return []\n        \n        # Variables to track the size of the matrix\n        N, M = len(matrix), len(matrix[0])\n        \n        # The two arrays as explained in the algorithm\n        result, intermediate = [], []\n        \n        # We have to go over all the elements in the first\n        # row and the last column to cover all possible diagonals\n        for d in range(N + M - 1):\n            \n            # Clear the intermediate array everytime we start\n            # to process another diagonal\n            intermediate.clear()\n            \n            # We need to figure out the \"head\" of this diagonal\n            # The elements in the first row and the last column\n            # are the respective heads.\n            r, c = 0 if d < M else d - M + 1, d if d < M else M - 1\n            \n            # Iterate until one of the indices goes out of scope\n            # Take note of the index math to go down the diagonal\n            while r < N and c > -1:\n                intermediate.append(matrix[r][c])\n                r += 1\n                c -= 1\n            \n            # Reverse even numbered diagonals. The\n            # article says we have to reverse odd \n            # numbered articles but here, the numbering\n            # is starting from 0 :P\n            if d % 2 == 0:\n                result.extend(intermediate[::-1])\n            else:\n                result.extend(intermediate)\n        return result        \n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(N \\cdot M)$，数组有 $N$ 行 $M$ 列。对于所有奇数对角线上的元素，需要两次处理，迭代和翻转。为了节省空间，需要遍历新对角线之前清除中间使用的空间，该操作需要 $O(K)$ 的复杂度度，其中 $K$ 是数组长度。因此至少处理两次数组中的元素，渐进复杂度为 $O(N \\cdot M)$。\n\n* 空间复杂度：$O(min(N, M))$，额外空间用于存储每条对角线的中间数组，该数组长度为 $N$ 和 $M$ 的最小值。注意：对角线延伸到索引超出范围结束。\n\n\n#### 方法二：模拟\n\n**思路**\n\n按照题目要求，模拟在数组中的行走路线，得到想要的遍历顺序。为了实现此模拟，必须清楚数组内部的行走策略。对每条对角线需要明确两件事情：\n\n1. 知道该对角线的行走方向。\n\n2. 确定对角线的起点元素，这取决于对角线的行走方向。\n\n下图中标注了每条对角线的这两个信息。\n\n![](https://pic.leetcode-cn.com/Figures/498/img3.png)\n\n确定对角线的方向很简单。只需要设置一个布尔型变量，保持交替来确定对角线方向即可。棘手的是如何确定对角线的起始位置。\n\n好消息是我们已经知道上一个对角线的尾部，可以以此来确定下一条对角线的首部。\n\n**向上行走时的下一条对角线首部**\n\n位于向下行走对角线尾端时，找出下一个向上行走对角线头部有两种情况。\n\n![](https://pic.leetcode-cn.com/Figures/498/img4.png)\n\n找出向上行走对角线头部需要遵循两个规则：\n\n> 如果当前尾部不在矩阵最后一行，则下一个对角线的头部是当前尾部的正下方元素；否则，下一条对角线首部是当前尾部的右边元素。\n\n**向下行走时的下一条对角线尾部** \n\n位于向上行走对角线尾部时，找出下一个向下行走对角线首部有两种情况。\n\n![](https://pic.leetcode-cn.com/Figures/498/img5.png)\n\n找出向下行走对角线头部需要遵循两个规则：\n\n> 如果当前尾部不在矩阵最后一行，下一条对角线的首部是当前尾部正下方元素；否则，下一条对角线首部是当前尾部的右边元素。\n\n**算法**\n\n1. 初始化一个布尔变量 `direction` 表示当前对角线的方向。根据当前方向和尾部位置确定下一条对角线首部。最初 `direction` 为 1，方向向上。每条对角线遍历完成后更新 `direction`。\n\n2. 假设当前对角线首部为 $matrix[i][j]$，根据方向遍历该对角线。\n\n    - 向上的对角线，下一个元素是 $matrix[i - 1][j + 1]$。\n\n    - 向下的对角线，下一个元素是 $matrix[i + 1][j - 1]$。\n\n3. 遍历当前对角线元素直到到达矩阵边界结束。\n\n4. 假设现在到达当前对角线的最后一个元素，寻找下一条对角线首部。注意：下面伪代码中方向是当前对角线方向。如果当前对角线方向是向上的，则下一条对角线是向下的；否则是下一条对角线是向上的。\n\n   ```python [snippet1-Python]\n   tail = [i, j]\n   if direction == up, then {\n      if [i, j + 1] is within bounds, then {\n          next_head = [i, j + 1]\n      } else { \n          next_head = [i + 1, j]\n      }\n   } else {\n      if [i + 1, j] is within bounds, then {\n          next_head = [i + 1, j]\n      } else { \n          next_head = [i, j + 1]\n      }\n   }\n    ```\n\n5. 继续处理对角线元素，当前对角线遍历结束时，使用当前方向和尾部位置找出下一条对角线首部。然后翻转方向，处理下一条对角线。\n\n```java [solution1-Java]\nclass Solution {\n    public int[] findDiagonalOrder(int[][] matrix) {\n        \n        // Check for empty matrices\n        if (matrix == null || matrix.length == 0) {\n            return new int[0];\n        }\n        \n        // Variables to track the size of the matrix\n        int N = matrix.length;\n        int M = matrix[0].length;\n        \n        // Incides that will help us progress through \n        // the matrix, one element at a time.\n        int row = 0, column = 0;\n        \n        // As explained in the article, this is the variable\n        // that helps us keep track of what direction we are\n        // processing the current diaonal\n        int direction = 1;\n        \n         // The final result array\n        int[] result = new int[N*M];\n        int r = 0;\n        \n        // The uber while loop which will help us iterate over all\n        // the elements in the array.\n        while (row < N && column < M) {\n            \n            // First and foremost, add the current element to \n            // the result matrix. \n            result[r++] = matrix[row][column];\n            \n            // Move along in the current diagonal depending upon\n            // the current direction.[i, j] -> [i - 1, j + 1] if \n            // going up and [i, j] -> [i + 1][j - 1] if going down.\n            int new_row = row + (direction == 1 ? -1 : 1);\n            int new_column = column + (direction == 1 ? 1 : -1);\n            \n            // Checking if the next element in the diagonal is within the\n            // bounds of the matrix or not. If it's not within the bounds,\n            // we have to find the next head. \n            if (new_row < 0 || new_row == N || new_column < 0 || new_column == M) {\n                \n                // If the current diagonal was going in the upwards\n                // direction.\n                if (direction == 1) {\n                    \n                    // For an upwards going diagonal having [i, j] as its tail\n                    // If [i, j + 1] is within bounds, then it becomes\n                    // the next head. Otherwise, the element directly below\n                    // i.e. the element [i + 1, j] becomes the next head\n                    row += (column == M - 1 ? 1 : 0) ;\n                    column += (column < M - 1 ? 1 : 0);\n                        \n                } else {\n                    \n                    // For a downwards going diagonal having [i, j] as its tail\n                    // if [i + 1, j] is within bounds, then it becomes\n                    // the next head. Otherwise, the element directly below\n                    // i.e. the element [i, j + 1] becomes the next head\n                    column += (row == N - 1 ? 1 : 0);\n                    row += (row < N - 1 ? 1 : 0);\n                }\n                    \n                // Flip the direction\n                direction = 1 - direction;        \n                        \n            } else {\n                \n                row = new_row;\n                column = new_column;\n            }\n        }\n        return result;      \n    }\n}\n```\n\n```python [solution1-Python]\nclass Solution:\n    \n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\n        \n        # Check for an empty matrix\n        if not matrix or not matrix[0]:\n            return []\n        \n        # The dimensions of the matrix\n        N, M = len(matrix), len(matrix[0])\n        \n        # Incides that will help us progress through \n        # the matrix, one element at a time.\n        row, column = 0, 0\n        \n        # As explained in the article, this is the variable\n        # that helps us keep track of what direction we are\n        # processing the current diaonal\n        direction = 1\n        \n        # Final result array that will contain all the elements\n        # of the matrix\n        result = []\n        \n        # The uber while loop which will help us iterate over all\n        # the elements in the array.\n        while row < N and column < M:\n            \n            # First and foremost, add the current element to \n            # the result matrix. \n            result.append(matrix[row][column])\n            \n            # Move along in the current diagonal depending upon\n            # the current direction.[i, j] -> [i - 1, j + 1] if \n            # going up and [i, j] -> [i + 1][j - 1] if going down.\n            new_row = row + (-1 if direction == 1 else 1)\n            new_column = column + (1 if direction == 1 else -1)\n            \n            # Checking if the next element in the diagonal is within the\n            # bounds of the matrix or not. If it's not within the bounds,\n            # we have to find the next head. \n            if new_row < 0 or new_row == N or new_column < 0 or new_column == M:\n                \n                # If the current diagonal was going in the upwards\n                # direction.\n                if direction:\n                    \n                    # For an upwards going diagonal having [i, j] as its tail\n                    # If [i, j + 1] is within bounds, then it becomes\n                    # the next head. Otherwise, the element directly below\n                    # i.e. the element [i + 1, j] becomes the next head\n                    row += (column == M - 1)\n                    column += (column < M - 1)\n                else:\n                    \n                    # For a downwards going diagonal having [i, j] as its tail\n                    # if [i + 1, j] is within bounds, then it becomes\n                    # the next head. Otherwise, the element directly below\n                    # i.e. the element [i, j + 1] becomes the next head\n                    column += (row == N - 1)\n                    row += (row < N - 1)\n                    \n                # Flip the direction\n                direction = 1 - direction        \n            else:\n                row = new_row\n                column = new_column\n                        \n        return result                 \n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(N \\cdot M)$，每个元素只处理一次。\n\n* 空间复杂度：$O(1)$，不使用额外空间。注意：输出数组空间不计入空间复杂度，因为这是题目要求的空间。空间复杂度应该指除了最终数组以外的空间。上一个方法中是中间数组，该方法中只有几个变量。",
      "createdAt": "2020-02-28T02:51:21.652898+00:00",
      "hitCount": 35838,
      "identifier": "Zy9m7N",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "dui-jiao-xian-bian-li-fen-xi-ti-mu-zhao-zhun-gui-l",
        "title": "【对角线遍历】 分析题目-找准规律-代码清晰易读-不要让自己迷失在随意的ifelse中"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "diagonal-traverse"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 32,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 4,
          "reactionType": "AWESOME"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 2,
          "reactionType": "THUMBS_DOWN"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 1,
          "reactionType": "CONFUSED"
        }
      ],
      "rewardEnabled": null,
      "slug": "dui-jiao-xian-bian-li-by-leetcode",
      "status": "PUBLISHED",
      "summary": "方法一：对角线迭代和翻转 思路 解决许多复杂问题的常见策略是首先解决该问题的简化问题，然后考虑从简化问题到原始问题需要做哪些修改，方法一就是这种思路。首先考虑按照逐条对角线打印元素，而不考虑翻转的情况。 在第一行最后一列的元素作为起点的对角线上，对于给定元素 $[i, j]$，可以向右移动一行向上移动一列沿对角线向上移",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python",
          "nameTranslated": "",
          "slug": "python",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "对角线遍历",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 43,
        "id": 112657,
        "viewCount": 26004
      },
      "uuid": "Zy9m7N",
      "videosInfo": []
    }
  }
}
