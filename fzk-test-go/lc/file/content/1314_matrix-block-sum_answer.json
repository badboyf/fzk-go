{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "力扣官方题解",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/leetcode-solution/avatar_1582018938.png",
          "userSlug": "leetcode-solution"
        },
        "username": "LeetCode-Solution"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "#### 预备知识\n\n本题需要用到一些二维前缀和（Prefix Sum）的知识，它是一维前缀和的延伸。\n\n具体可以参考力扣 [1292 题的官方题解](https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/solution/yuan-su-he-xiao-yu-deng-yu-yu-zhi-de-zheng-fang-xi/) 中的「预备知识」和「注意事项」部分。\n\n#### 方法一：二维前缀和\n\n我们用数组 `P` 表示数组 `mat` 的二维前缀和，`P` 的维数为 `(m + 1) * (n + 1)`，其中 `P[i][j]` 表示数组 `mat` 中以 `(0, 0)` 为左上角，`(i - 1, j - 1)` 为右下角的矩形子数组的元素之和。\n\n题目需要对数组 `mat` 中的每个位置，计算以 `(i - K, j - K)` 为左上角，`(i + K, j + K)` 为右下角的矩形子数组的元素之和，我们可以在前缀和数组的帮助下，通过：\n\n```\nsum = P[i + K + 1][j + K + 1] - P[i - K][j + K + 1] - P[i + K + 1][j - K] + P[i - K][j - K]\n```\n\n得到元素之和。注意到 `i + K + 1`、`j + K - 1`、`i - K` 和 `j - K` 这些下标有可能不在矩阵内，因此对于所有的横坐标，我们需要将其规范在 `[0, m]` 的区间内；对于所有的纵坐标，我们需要将其规范在 `[0, n]` 的区间内。具体地：\n\n- `i + K + 1` 和 `j + K - 1` 分别可能超过 `m` 和 `n`，因此我们需要对这两个坐标与 `m` 和 `n` 取较小值，忽略不在矩阵内的部分；\n\n- `i - K` 和 `j - K` 可能小于 `0`，因此我们需要对这两个坐标与 `0` 取较大值，忽略不在矩阵内的部分。\n\n更一般的做法是，我们对所有的横坐标与 `m` 取较小值，纵坐标与 `n` 取较小值，再将所有坐标与 `0` 取较大值，就可以将这些坐标规范在前缀和数组 `P` 的范围内。\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    int get(const vector<vector<int>>& pre, int m, int n, int x, int y) {\n        x = max(min(x, m), 0);\n        y = max(min(y, n), 0);\n        return pre[x][y];\n    }\n    \n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\n        int m = mat.size(), n = mat[0].size();\n        vector<vector<int>> P(m + 1, vector<int>(n + 1));\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                P[i][j] = P[i - 1][j] + P[i][j - 1] - P[i - 1][j - 1] + mat[i - 1][j - 1];\n            }\n        }\n        \n        vector<vector<int>> ans(m, vector<int>(n));\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                ans[i][j] = get(P, m, n, i + K + 1, j + K + 1) - get(P, m, n, i - K, j + K + 1) - get(P, m, n, i + K + 1, j - K) + get(P, m, n, i - K, j - K);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        P = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                P[i][j] = P[i - 1][j] + P[i][j - 1] - P[i - 1][j - 1] + mat[i - 1][j - 1]\n        \n        def get(x, y):\n            x = max(min(x, m), 0)\n            y = max(min(y, n), 0)\n            return P[x][y]\n\n        ans = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                ans[i][j] = get(i + K + 1, j + K + 1) - get(i - K, j + K + 1) - get(i + K + 1, j - K) + get(i - K, j - K);\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(MN)$。\n\n- 空间复杂度：$O(MN)$。",
      "createdAt": "2020-02-18T13:18:33.570003+00:00",
      "hitCount": 18128,
      "identifier": "wxpc5d",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "er-wei-qian-zhui-he-by-jiao-chun-peng-avrj",
        "title": "二维前缀和"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "matrix-block-sum"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 32,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 4,
          "reactionType": "THUMBS_DOWN"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 1,
          "reactionType": "AWESOME"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 1,
          "reactionType": "CONFUSED"
        }
      ],
      "rewardEnabled": null,
      "slug": "ju-zhen-qu-yu-he-by-leetcode-solution",
      "status": "PUBLISHED",
      "summary": " 预备知识\n本题需要用到一些二维前缀和（Prefix Sum）的知识，它是一维前缀和的延伸。\n具体可以参考力扣 1292 题的官方题解 中的「预备知识」和「注意事项」部分。\n 方法一：二维前缀和\n我们用数组 P 表示数组 mat 的二维前缀和，P 的维数为 (m + 1) * (n + 1)，其中 P[i][j] 表示",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python3",
          "nameTranslated": "",
          "slug": "python3",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "矩阵区域和",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 25,
        "id": 101300,
        "viewCount": 12395
      },
      "uuid": "wxpc5d",
      "videosInfo": []
    }
  }
}
