{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "liuyubobobo",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/liuyubobobo/avatar_1566694057.png",
          "userSlug": "liuyubobobo"
        },
        "username": "liuyubobobo"
      },
      "byLeetcode": false,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "这个问题空间复杂度是 O(n) 的解法太简单了，不多说了。说说空间复杂度为 O(1) 的做法，原地完成：）\n\n实际上，有两个思路可以完成这一点。\n\n以下解析可能结合代码看会更好理解。\n\n<br/>\n\n**思路一**\n\n因为题目限制了每一个元素 nums[i] 最大只有可能是 1000，这就意味着每一个元素只占据了 10 个 bit。（2^10 - 1 = 1023 > 1000）\n\n而一个 int 有 32 个 bit，所以我们还可以使用剩下的 22 个 bit 做存储。实际上，每个 int，我们再借 10 个 bit 用就好了。\n\n因此，在下面的代码中，每一个 nums[i] 的最低的十个 bit（0-9 位），我们用来存储原来 nums[i] 的数字；再往前的十个 bit（10-19 位），我们用来存储重新排列后正确的数字是什么。\n\n在循环中，我们每次首先计算 nums[i] 对应的重新排列后的索引 j，之后，取 nums[i] 的低 10 位（``nums[i] & 1023``），即 nums[i] 的原始信息，把他放到 nums[j] 的高十位上。\n\n最后，每个元素都取高 10 位的信息(``e >> 10``)，即是答案。\n\n我的参考代码（C++）：\n\n```\nclass Solution {\npublic:\n    vector<int> shuffle(vector<int>& nums, int n) {\n\n        for(int i = 0; i < 2 * n; i ++){\n            int j = i < n ? 2 * i : 2 * (i - n) + 1;\n            nums[j] |= (nums[i] & 1023) << 10;\n        }\n        for(int& e: nums) e >>= 10;\n        return nums;\n    }\n};\n```\n\n---\n\n**思路二**\n\n利用题目中限制每一个元素 nums[i] 都大于 0。我们可以使用负数做标记。\n\n标记什么？标记当前 nums[i] 存储的数字，是不是重新排列后的正确数字。如果是，存负数；如果不是，存正数（即原本的数字，还需处理）。\n\n我们每次处理一个 nums[i]，计算这个 nums[i] 应该放置的正确位置 j。但是，nums[j] 还没有排列好，所以我们暂时把 nums[j] 放到 nums[i] 的位置上来，并且记录上，此时 nums[i] 的元素本来的索引是 j。现在，我们就可以安心地把 nums[i] 放到 j 的位置了。同时，因为这已经是 nums[i] 正确的位置，取负数，即标记这个位置已经存放了正确的元素。\n\n之后，我们继续处理当前的 nums[i]，注意，此时这个新的 nums[i]，本来的索引是 j。所以我们根据 j 算出它应该存放的位置，然后把这个位置的元素放到 nums[i] 中，取负做标记。\n\n这个过程以此类推。这就是代码中 ``while`` 循环做的事情。\n\n直到 nums[i] 的值也是负数，说明 i 的位置也已经是重新排列后的正确元素了，我们就可以看下一个位置了。\n\n在 ``for`` 循环中，如果某一个元素已经是小于零了，说明这个位置已经是正确元素了，可以忽略。\n\n这个算法虽然有两重循环，但是时间复杂度是 O(n) 的，因为每个元素最多会被重新排列一次，然后会被最外面的 for 循环访问一次。一旦重新排列过，for 的访问只是一次 ``if`` 判断而已。\n\n当然，最后，数组中的所有元素还需要从负数转换回正数。\n\n我的参考代码（C++）：\n\n```\nclass Solution {\npublic:\n    vector<int> shuffle(vector<int>& nums, int n) {\n\n        for(int i = 0; i < 2 * n; i ++)\n            if(nums[i] > 0){\n                \n                // j 描述当前的 nums[i] 对应的索引，初始为 i\n                int j = i; \n\n                while(nums[i] > 0){\n\n                    // 计算 j 索引的元素，也就是现在的 nums[i]，应该放置的索引\n                    j = j < n ? 2 * j : 2 * (j - n) + 1; \n\n                    // 把 nums[i] 放置到 j 的位置，\n                    // 同时，把 nums[j] 放到 i 的位置，在下一轮循环继续处理\n                    swap(nums[i], nums[j]); \n\n                    // 使用负号标记上，现在 j 位置存储的元素已经是正确的元素了 \n                    nums[j] = -nums[j]; \n                }\n            }\n\n        for(int& e: nums) e = -e;\n        return nums;\n    }\n};\n```\n\n---\n\n觉得有帮助请点赞哇！\n\n```\n",
      "createdAt": "2020-06-09T01:22:29.240082+00:00",
      "hitCount": 16199,
      "identifier": "EXZHZy",
      "isEditorsPick": false,
      "isMostPopular": true,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "2-xing-dai-ma-xiao-lu-100-by-liu-yong-qi-zhfp",
        "title": "2 行代码。。。效率100%"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "shuffle-the-array"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 109,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 9,
          "reactionType": "AWESOME"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 0,
          "reactionType": "CONFUSED"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 0,
          "reactionType": "THUMBS_DOWN"
        }
      ],
      "rewardEnabled": null,
      "slug": "kong-jian-fu-za-du-wei-o1-de-liang-chong-jie-fa-by",
      "status": "PUBLISHED",
      "summary": "这个问题空间复杂度是 O(n) 的解法太简单了，不多说了。说说空间复杂度为 O(1) 的做法，原地完成：）\n实际上，有两个思路可以完成这一点。\n以下解析可能结合代码看会更好理解。\n思路一\n因为题目限制了每一个元素 nums[i] 最大只有可能是 1000，这就意味着每一个元素只占据了 10 个 bit。（2^10 -",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Bit Manipulation",
          "nameTranslated": "位运算",
          "slug": "bit-manipulation",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "空间复杂度为 O(1) 的两种解法（时间依然O(n)）",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 42,
        "id": 280779,
        "viewCount": 13209
      },
      "uuid": "EXZHZy",
      "videosInfo": []
    }
  }
}
