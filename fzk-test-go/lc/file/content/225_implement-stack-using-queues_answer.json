{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "åŠ›æ‰£å®˜æ–¹é¢˜è§£",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/leetcode-solution/avatar_1582018938.png",
          "userSlug": "leetcode-solution"
        },
        "username": "LeetCode-Solution"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "### ğŸ“º è§†é¢‘é¢˜è§£  \n![225. ç”¨é˜Ÿåˆ—å®ç°æ ˆ 2.mp4](904c0b3d-b8cc-4560-95d2-a5cd2d59effd)\n\n### ğŸ“– æ–‡å­—é¢˜è§£\n#### ç»ªè®º\n\nè¿™é“é¢˜ç›®æ˜¯ä¸ºåˆçº§è¯»è€…å‡†å¤‡çš„ï¼Œé¢˜ç›®æ¶‰åŠåˆ°æ ˆå’Œé˜Ÿåˆ—ä¸¤ç§æ•°æ®ç»“æ„ã€‚\n\næ ˆæ˜¯ä¸€ç§åè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ï¼Œå…ƒç´ ä»é¡¶ç«¯å…¥æ ˆï¼Œç„¶åä»é¡¶ç«¯å‡ºæ ˆã€‚\n\né˜Ÿåˆ—æ˜¯ä¸€ç§å…ˆè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ï¼Œå…ƒç´ ä»åç«¯å…¥é˜Ÿï¼Œç„¶åä»å‰ç«¯å‡ºé˜Ÿã€‚\n\n#### æ–¹æ³•ä¸€ï¼šä¸¤ä¸ªé˜Ÿåˆ—\n\nä¸ºäº†æ»¡è¶³æ ˆçš„ç‰¹æ€§ï¼Œå³æœ€åå…¥æ ˆçš„å…ƒç´ æœ€å…ˆå‡ºæ ˆï¼Œåœ¨ä½¿ç”¨é˜Ÿåˆ—å®ç°æ ˆæ—¶ï¼Œåº”æ»¡è¶³é˜Ÿåˆ—å‰ç«¯çš„å…ƒç´ æ˜¯æœ€åå…¥æ ˆçš„å…ƒç´ ã€‚å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—å®ç°æ ˆçš„æ“ä½œï¼Œå…¶ä¸­ $\\textit{queue}_1$ ç”¨äºå­˜å‚¨æ ˆå†…çš„å…ƒç´ ï¼Œ$\\textit{queue}_2$ ä½œä¸ºå…¥æ ˆæ“ä½œçš„è¾…åŠ©é˜Ÿåˆ—ã€‚\n\nå…¥æ ˆæ“ä½œæ—¶ï¼Œé¦–å…ˆå°†å…ƒç´ å…¥é˜Ÿåˆ° $\\textit{queue}_2$ï¼Œç„¶åå°† $\\textit{queue}_1$ çš„å…¨éƒ¨å…ƒç´ ä¾æ¬¡å‡ºé˜Ÿå¹¶å…¥é˜Ÿåˆ° $\\textit{queue}_2$ï¼Œæ­¤æ—¶ $\\textit{queue}_2$ çš„å‰ç«¯çš„å…ƒç´ å³ä¸ºæ–°å…¥æ ˆçš„å…ƒç´ ï¼Œå†å°† $\\textit{queue}_1$ å’Œ $\\textit{queue}_2$ äº’æ¢ï¼Œåˆ™ $\\textit{queue}_1$ çš„å…ƒç´ å³ä¸ºæ ˆå†…çš„å…ƒç´ ï¼Œ$\\textit{queue}_1$ çš„å‰ç«¯å’Œåç«¯åˆ†åˆ«å¯¹åº”æ ˆé¡¶å’Œæ ˆåº•ã€‚\n\nç”±äºæ¯æ¬¡å…¥æ ˆæ“ä½œéƒ½ç¡®ä¿ $\\textit{queue}_1$ çš„å‰ç«¯å…ƒç´ ä¸ºæ ˆé¡¶å…ƒç´ ï¼Œå› æ­¤å‡ºæ ˆæ“ä½œå’Œè·å¾—æ ˆé¡¶å…ƒç´ æ“ä½œéƒ½å¯ä»¥ç®€å•å®ç°ã€‚å‡ºæ ˆæ“ä½œåªéœ€è¦ç§»é™¤ $\\textit{queue}_1$ çš„å‰ç«¯å…ƒç´ å¹¶è¿”å›å³å¯ï¼Œè·å¾—æ ˆé¡¶å…ƒç´ æ“ä½œåªéœ€è¦è·å¾— $\\textit{queue}_1$ çš„å‰ç«¯å…ƒç´ å¹¶è¿”å›å³å¯ï¼ˆä¸ç§»é™¤å…ƒç´ ï¼‰ã€‚\n\nç”±äº $\\textit{queue}_1$ ç”¨äºå­˜å‚¨æ ˆå†…çš„å…ƒç´ ï¼Œåˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºæ—¶ï¼Œåªéœ€è¦åˆ¤æ–­ $\\textit{queue}_1$ æ˜¯å¦ä¸ºç©ºå³å¯ã€‚\n\n![fig1](https://assets.leetcode-cn.com/solution-static/225/225_fig1.gif)\n\n```Java [sol1-Java]\nclass MyStack {\n    Queue<Integer> queue1;\n    Queue<Integer> queue2;\n\n    /** Initialize your data structure here. */\n    public MyStack() {\n        queue1 = new LinkedList<Integer>();\n        queue2 = new LinkedList<Integer>();\n    }\n    \n    /** Push element x onto stack. */\n    public void push(int x) {\n        queue2.offer(x);\n        while (!queue1.isEmpty()) {\n            queue2.offer(queue1.poll());\n        }\n        Queue<Integer> temp = queue1;\n        queue1 = queue2;\n        queue2 = temp;\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n        return queue1.poll();\n    }\n    \n    /** Get the top element. */\n    public int top() {\n        return queue1.peek();\n    }\n    \n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n        return queue1.isEmpty();\n    }\n}\n```\n\n```cpp [sol1-C++]\nclass MyStack {\npublic:\n    queue<int> queue1;\n    queue<int> queue2;\n\n    /** Initialize your data structure here. */\n    MyStack() {\n\n    }\n\n    /** Push element x onto stack. */\n    void push(int x) {\n        queue2.push(x);\n        while (!queue1.empty()) {\n            queue2.push(queue1.front());\n            queue1.pop();\n        }\n        swap(queue1, queue2);\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        int r = queue1.front();\n        queue1.pop();\n        return r;\n    }\n    \n    /** Get the top element. */\n    int top() {\n        int r = queue1.front();\n        return r;\n    }\n    \n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return queue1.empty();\n    }\n};\n```\n\n```Python [sol1-Python3]\nclass MyStack:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.queue1 = collections.deque()\n        self.queue2 = collections.deque()\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x onto stack.\n        \"\"\"\n        self.queue2.append(x)\n        while self.queue1:\n            self.queue2.append(self.queue1.popleft())\n        self.queue1, self.queue2 = self.queue2, self.queue1\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element on top of the stack and returns that element.\n        \"\"\"\n        return self.queue1.popleft()\n\n\n    def top(self) -> int:\n        \"\"\"\n        Get the top element.\n        \"\"\"\n        return self.queue1[0]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the stack is empty.\n        \"\"\"\n        return not self.queue1\n```\n\n```Golang [sol1-Golang]\ntype MyStack struct {\n    queue1, queue2 []int\n}\n\n/** Initialize your data structure here. */\nfunc Constructor() (s MyStack) {\n    return\n}\n\n/** Push element x onto stack. */\nfunc (s *MyStack) Push(x int) {\n    s.queue2 = append(s.queue2, x)\n    for len(s.queue1) > 0 {\n        s.queue2 = append(s.queue2, s.queue1[0])\n        s.queue1 = s.queue1[1:]\n    }\n    s.queue1, s.queue2 = s.queue2, s.queue1\n}\n\n/** Removes the element on top of the stack and returns that element. */\nfunc (s *MyStack) Pop() int {\n    v := s.queue1[0]\n    s.queue1 = s.queue1[1:]\n    return v\n}\n\n/** Get the top element. */\nfunc (s *MyStack) Top() int {\n    return s.queue1[0]\n}\n\n/** Returns whether the stack is empty. */\nfunc (s *MyStack) Empty() bool {\n    return len(s.queue1) == 0\n}\n```\n\n```C [sol1-C]\n#define LEN 20\ntypedef struct queue {\n    int *data;\n    int head;\n    int rear;\n    int size;\n} Queue;\n\ntypedef struct {\n    Queue *queue1, *queue2;\n} MyStack;\n\nQueue *initQueue(int k) {\n    Queue *obj = (Queue *)malloc(sizeof(Queue));\n    obj->data = (int *)malloc(k * sizeof(int));\n    obj->head = -1;\n    obj->rear = -1;\n    obj->size = k;\n    return obj;\n}\n\nvoid enQueue(Queue *obj, int e) {\n    if (obj->head == -1) {\n        obj->head = 0;\n    }\n    obj->rear = (obj->rear + 1) % obj->size;\n    obj->data[obj->rear] = e;\n}\n\nint deQueue(Queue *obj) {\n    int a = obj->data[obj->head];\n    if (obj->head == obj->rear) {\n        obj->rear = -1;\n        obj->head = -1;\n        return a;\n    }\n    obj->head = (obj->head + 1) % obj->size;\n    return a;\n}\n\nint isEmpty(Queue *obj) {\n    return obj->head == -1;\n}\n\nMyStack *myStackCreate() {\n    MyStack *obj = (MyStack *)malloc(sizeof(MyStack));\n    obj->queue1 = initQueue(LEN);\n    obj->queue2 = initQueue(LEN);\n    return obj;\n}\n\nvoid myStackPush(MyStack *obj, int x) {\n    if (isEmpty(obj->queue1)) {\n        enQueue(obj->queue2, x);\n    } else {\n        enQueue(obj->queue1, x);\n    }\n}\n\nint myStackPop(MyStack *obj) {\n    if (isEmpty(obj->queue1)) {\n        while (obj->queue2->head != obj->queue2->rear) {\n            enQueue(obj->queue1, deQueue(obj->queue2));\n        }\n        return deQueue(obj->queue2);\n    }\n    while (obj->queue1->head != obj->queue1->rear) {\n        enQueue(obj->queue2, deQueue(obj->queue1));\n    }\n    return deQueue(obj->queue1);\n}\n\nint myStackTop(MyStack *obj) {\n    if (isEmpty(obj->queue1)) {\n        return obj->queue2->data[obj->queue2->rear];\n    }\n    return obj->queue1->data[obj->queue1->rear];\n}\n\nbool myStackEmpty(MyStack *obj) {\n    if (obj->queue1->head == -1 && obj->queue2->head == -1) {\n        return true;\n    }\n    return false;\n}\n\nvoid myStackFree(MyStack *obj) {\n    free(obj->queue1->data);\n    obj->queue1->data = NULL;\n    free(obj->queue1);\n    obj->queue1 = NULL;\n    free(obj->queue2->data);\n    obj->queue2->data = NULL;\n    free(obj->queue2);\n    obj->queue2 = NULL;\n    free(obj);\n    obj = NULL;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šå…¥æ ˆæ“ä½œ $O(n)$ï¼Œå…¶ä½™æ“ä½œéƒ½æ˜¯ $O(1)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ ˆå†…çš„å…ƒç´ ä¸ªæ•°ã€‚\n  å…¥æ ˆæ“ä½œéœ€è¦å°† $\\textit{queue}_1$ ä¸­çš„ $n$ ä¸ªå…ƒç´ å‡ºé˜Ÿï¼Œå¹¶å…¥é˜Ÿ $n+1$ ä¸ªå…ƒç´ åˆ° $\\textit{queue}_2$ï¼Œå…±æœ‰ $2n+1$ æ¬¡æ“ä½œï¼Œæ¯æ¬¡å‡ºé˜Ÿå’Œå…¥é˜Ÿæ“ä½œçš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ $O(1)$ï¼Œå› æ­¤å…¥æ ˆæ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ã€‚\n  å‡ºæ ˆæ“ä½œå¯¹åº”å°† $\\textit{queue}_1$ çš„å‰ç«¯å…ƒç´ å‡ºé˜Ÿï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(1)$ã€‚\n  è·å¾—æ ˆé¡¶å…ƒç´ æ“ä½œå¯¹åº”è·å¾— $\\textit{queue}_1$ çš„å‰ç«¯å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(1)$ã€‚\n  åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºæ“ä½œåªéœ€è¦åˆ¤æ–­ $\\textit{queue}_1$ æ˜¯å¦ä¸ºç©ºï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(1)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ ˆå†…çš„å…ƒç´ ä¸ªæ•°ã€‚éœ€è¦ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—å­˜å‚¨æ ˆå†…çš„å…ƒç´ ã€‚\n\n#### æ–¹æ³•äºŒï¼šä¸€ä¸ªé˜Ÿåˆ—\n\næ–¹æ³•ä¸€ä½¿ç”¨äº†ä¸¤ä¸ªé˜Ÿåˆ—å®ç°æ ˆçš„æ“ä½œï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—å®ç°æ ˆçš„æ“ä½œã€‚\n\nä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ—¶ï¼Œä¸ºäº†æ»¡è¶³æ ˆçš„ç‰¹æ€§ï¼Œå³æœ€åå…¥æ ˆçš„å…ƒç´ æœ€å…ˆå‡ºæ ˆï¼ŒåŒæ ·éœ€è¦æ»¡è¶³é˜Ÿåˆ—å‰ç«¯çš„å…ƒç´ æ˜¯æœ€åå…¥æ ˆçš„å…ƒç´ ã€‚\n\nå…¥æ ˆæ“ä½œæ—¶ï¼Œé¦–å…ˆè·å¾—å…¥æ ˆå‰çš„å…ƒç´ ä¸ªæ•° $n$ï¼Œç„¶åå°†å…ƒç´ å…¥é˜Ÿåˆ°é˜Ÿåˆ—ï¼Œå†å°†é˜Ÿåˆ—ä¸­çš„å‰ $n$ ä¸ªå…ƒç´ ï¼ˆå³é™¤äº†æ–°å…¥æ ˆçš„å…ƒç´ ä¹‹å¤–çš„å…¨éƒ¨å…ƒç´ ï¼‰ä¾æ¬¡å‡ºé˜Ÿå¹¶å…¥é˜Ÿåˆ°é˜Ÿåˆ—ï¼Œæ­¤æ—¶é˜Ÿåˆ—çš„å‰ç«¯çš„å…ƒç´ å³ä¸ºæ–°å…¥æ ˆçš„å…ƒç´ ï¼Œä¸”é˜Ÿåˆ—çš„å‰ç«¯å’Œåç«¯åˆ†åˆ«å¯¹åº”æ ˆé¡¶å’Œæ ˆåº•ã€‚\n\nç”±äºæ¯æ¬¡å…¥æ ˆæ“ä½œéƒ½ç¡®ä¿é˜Ÿåˆ—çš„å‰ç«¯å…ƒç´ ä¸ºæ ˆé¡¶å…ƒç´ ï¼Œå› æ­¤å‡ºæ ˆæ“ä½œå’Œè·å¾—æ ˆé¡¶å…ƒç´ æ“ä½œéƒ½å¯ä»¥ç®€å•å®ç°ã€‚å‡ºæ ˆæ“ä½œåªéœ€è¦ç§»é™¤é˜Ÿåˆ—çš„å‰ç«¯å…ƒç´ å¹¶è¿”å›å³å¯ï¼Œè·å¾—æ ˆé¡¶å…ƒç´ æ“ä½œåªéœ€è¦è·å¾—é˜Ÿåˆ—çš„å‰ç«¯å…ƒç´ å¹¶è¿”å›å³å¯ï¼ˆä¸ç§»é™¤å…ƒç´ ï¼‰ã€‚\n\nç”±äºé˜Ÿåˆ—ç”¨äºå­˜å‚¨æ ˆå†…çš„å…ƒç´ ï¼Œåˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºæ—¶ï¼Œåªéœ€è¦åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºå³å¯ã€‚\n\n![fig2](https://assets.leetcode-cn.com/solution-static/225/225_fig2.gif)\n\n```Java [sol2-Java]\nclass MyStack {\n    Queue<Integer> queue;\n\n    /** Initialize your data structure here. */\n    public MyStack() {\n        queue = new LinkedList<Integer>();\n    }\n    \n    /** Push element x onto stack. */\n    public void push(int x) {\n        int n = queue.size();\n        queue.offer(x);\n        for (int i = 0; i < n; i++) {\n            queue.offer(queue.poll());\n        }\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n        return queue.poll();\n    }\n    \n    /** Get the top element. */\n    public int top() {\n        return queue.peek();\n    }\n    \n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n```\n\n```cpp [sol2-C++]\nclass MyStack {\npublic:\n    queue<int> q;\n\n    /** Initialize your data structure here. */\n    MyStack() {\n\n    }\n\n    /** Push element x onto stack. */\n    void push(int x) {\n        int n = q.size();\n        q.push(x);\n        for (int i = 0; i < n; i++) {\n            q.push(q.front());\n            q.pop();\n        }\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        int r = q.front();\n        q.pop();\n        return r;\n    }\n    \n    /** Get the top element. */\n    int top() {\n        int r = q.front();\n        return r;\n    }\n    \n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return q.empty();\n    }\n};\n```\n\n```Python [sol2-Python3]\nclass MyStack:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.queue = collections.deque()\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x onto stack.\n        \"\"\"\n        n = len(self.queue)\n        self.queue.append(x)\n        for _ in range(n):\n            self.queue.append(self.queue.popleft())\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element on top of the stack and returns that element.\n        \"\"\"\n        return self.queue.popleft()\n\n\n    def top(self) -> int:\n        \"\"\"\n        Get the top element.\n        \"\"\"\n        return self.queue[0]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the stack is empty.\n        \"\"\"\n        return not self.queue\n```\n\n```Golang [sol2-Golang]\ntype MyStack struct {\n    queue []int\n}\n\n/** Initialize your data structure here. */\nfunc Constructor() (s MyStack) {\n    return\n}\n\n/** Push element x onto stack. */\nfunc (s *MyStack) Push(x int) {\n    n := len(s.queue)\n    s.queue = append(s.queue, x)\n    for ; n > 0; n-- {\n        s.queue = append(s.queue, s.queue[0])\n        s.queue = s.queue[1:]\n    }\n}\n\n/** Removes the element on top of the stack and returns that element. */\nfunc (s *MyStack) Pop() int {\n    v := s.queue[0]\n    s.queue = s.queue[1:]\n    return v\n}\n\n/** Get the top element. */\nfunc (s *MyStack) Top() int {\n    return s.queue[0]\n}\n\n/** Returns whether the stack is empty. */\nfunc (s *MyStack) Empty() bool {\n    return len(s.queue) == 0\n}\n```\n\n```C [sol2-C]\ntypedef struct tagListNode {\n    struct tagListNode* next;\n    int val;\n} ListNode;\n\ntypedef struct {\n    ListNode* top;\n} MyStack;\n\nMyStack* myStackCreate() {\n    MyStack* stk = calloc(1, sizeof(MyStack));\n    return stk;\n}\n\nvoid myStackPush(MyStack* obj, int x) {\n    ListNode* node = malloc(sizeof(ListNode));\n    node->val = x;\n    node->next = obj->top;\n    obj->top = node;\n}\n\nint myStackPop(MyStack* obj) {\n    ListNode* node = obj->top;\n    int val = node->val;\n    obj->top = node->next;\n    free(node);\n\n    return val;\n}\n\nint myStackTop(MyStack* obj) {\n    return obj->top->val;\n}\n\nbool myStackEmpty(MyStack* obj) {\n    return (obj->top == NULL);\n}\n\nvoid myStackFree(MyStack* obj) {\n    while (obj->top != NULL) {\n        ListNode* node = obj->top;\n        obj->top = obj->top->next;\n        free(node);\n    }\n    free(obj);\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šå…¥æ ˆæ“ä½œ $O(n)$ï¼Œå…¶ä½™æ“ä½œéƒ½æ˜¯ $O(1)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ ˆå†…çš„å…ƒç´ ä¸ªæ•°ã€‚\n  å…¥æ ˆæ“ä½œéœ€è¦å°†é˜Ÿåˆ—ä¸­çš„ $n$ ä¸ªå…ƒç´ å‡ºé˜Ÿï¼Œå¹¶å…¥é˜Ÿ $n+1$ ä¸ªå…ƒç´ åˆ°é˜Ÿåˆ—ï¼Œå…±æœ‰ $2n+1$ æ¬¡æ“ä½œï¼Œæ¯æ¬¡å‡ºé˜Ÿå’Œå…¥é˜Ÿæ“ä½œçš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ $O(1)$ï¼Œå› æ­¤å…¥æ ˆæ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ã€‚\n  å‡ºæ ˆæ“ä½œå¯¹åº”å°†é˜Ÿåˆ—çš„å‰ç«¯å…ƒç´ å‡ºé˜Ÿï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(1)$ã€‚\n  è·å¾—æ ˆé¡¶å…ƒç´ æ“ä½œå¯¹åº”è·å¾—é˜Ÿåˆ—çš„å‰ç«¯å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(1)$ã€‚\n  åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºæ“ä½œåªéœ€è¦åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(1)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ ˆå†…çš„å…ƒç´ ä¸ªæ•°ã€‚éœ€è¦ä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—å­˜å‚¨æ ˆå†…çš„å…ƒç´ ã€‚",
      "createdAt": "2020-09-29T14:44:43.510357+00:00",
      "hitCount": 68911,
      "identifier": "ogqNo5",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "wu-tu-guan-fang-tui-jian-ti-jie-yong-dui-63d4",
        "title": "ã€é˜Ÿåˆ—ã€‘ç”¨é˜Ÿåˆ—å®ç°æ ˆ"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "implement-stack-using-queues"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 66,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 13,
          "reactionType": "AWESOME"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 2,
          "reactionType": "CONFUSED"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 2,
          "reactionType": "THUMBS_DOWN"
        }
      ],
      "rewardEnabled": null,
      "slug": "yong-dui-lie-shi-xian-zhan-by-leetcode-solution",
      "status": "PUBLISHED",
      "summary": "ğŸ“º è§†é¢‘é¢˜è§£ ğŸ“– æ–‡å­—é¢˜è§£ ç»ªè®º è¿™é“é¢˜ç›®æ˜¯ä¸ºåˆçº§è¯»è€…å‡†å¤‡çš„ï¼Œé¢˜ç›®æ¶‰åŠåˆ°æ ˆå’Œé˜Ÿåˆ—ä¸¤ç§æ•°æ®ç»“æ„ã€‚ æ ˆæ˜¯ä¸€ç§åè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ï¼Œå…ƒç´ ä»é¡¶ç«¯å…¥æ ˆï¼Œç„¶åä»é¡¶ç«¯å‡ºæ ˆã€‚ é˜Ÿåˆ—æ˜¯ä¸€ç§å…ˆè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ï¼Œå…ƒç´ ä»åç«¯å…¥é˜Ÿï¼Œç„¶åä»å‰ç«¯å‡ºé˜Ÿã€‚ æ–¹æ³•ä¸€ï¼šä¸¤ä¸ªé˜Ÿåˆ— ä¸ºäº†æ»¡è¶³æ ˆçš„ç‰¹æ€§ï¼Œå³æœ€åå…¥æ ˆçš„å…ƒç´ æœ€å…ˆå‡ºæ ˆï¼Œåœ¨ä½¿ç”¨é˜Ÿåˆ—å®ç°æ ˆæ—¶ï¼Œåº”æ»¡è¶³é˜Ÿåˆ—å‰ç«¯çš„",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Stack",
          "nameTranslated": "æ ˆ",
          "slug": "stack",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Design",
          "nameTranslated": "è®¾è®¡",
          "slug": "design",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Queue",
          "nameTranslated": "é˜Ÿåˆ—",
          "slug": "queue",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C",
          "nameTranslated": "",
          "slug": "c",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Go",
          "nameTranslated": "",
          "slug": "golang",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python",
          "nameTranslated": "",
          "slug": "python",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "https://assets.leetcode-cn.com/solution-static/225/225_fig1.gif",
      "title": "ç”¨é˜Ÿåˆ—å®ç°æ ˆ",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 77,
        "id": 432204,
        "viewCount": 46919
      },
      "uuid": "ogqNo5",
      "videosInfo": [
        {
          "__typename": "VideoInfoNode",
          "coverUrl": "https://video.leetcode-cn.com/image/cover/E287D7AC371C4233A9BF3CDAD320602A-6-2.png",
          "duration": 442.4107,
          "videoId": "fe50e0de3f35412e9f546ac8455fe345"
        }
      ]
    }
  }
}
