{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "Krahets",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/jyd/avatar_1589712294.png",
          "userSlug": "jyd"
        },
        "username": "jyd"
      },
      "byLeetcode": false,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "#### 解题思路：\r\n\r\n利用 HashMap 可以通过遍历数组找到数字组合，时间和空间复杂度均为 $O(N)$ ；\r\n注意本题的 $nums$ 是 **排序数组** ，因此可使用 **双指针法** 将空间复杂度降低至 $O(1)$ 。\r\n\r\n##### 算法流程：\r\n\r\n1. **初始化：** 双指针 $i$ , $j$ 分别指向数组 $nums$ 的左右两端 *（俗称对撞双指针）*。\r\n2. **循环搜索：** 当双指针相遇时跳出；\r\n   1. 计算和 $s = nums[i] + nums[j]$ ；\r\n   2. 若 $s > target$ ，则指针 $j$ 向左移动，即执行 $j = j - 1$ ；\r\n   3. 若 $s < target$ ，则指针 $i$ 向右移动，即执行 $i = i + 1$ ；\r\n   4. 若 $s = target$ ，立即返回数组 $[nums[i], nums[j]]$ ；\r\n3. 返回空数组，代表无和为 $target$ 的数字组合。\r\n\r\n<![Picture2.png](https://pic.leetcode-cn.com/9529dc9ecf7a885a8abdd842806e8499309f5bd4cafc62c663fa5e190626d48d-Picture2.png),![Picture3.png](https://pic.leetcode-cn.com/8c3ea4bb5dd0db25dac85f6e4636ea64af55634864e9492f9fb4ae86ad84f969-Picture3.png),![Picture4.png](https://pic.leetcode-cn.com/ac370df5c580230e906958c4e6a5cb1e7bcab1efc711f12388266e968c4bf489-Picture4.png),![Picture5.png](https://pic.leetcode-cn.com/7b0e3f66a0175ba7e56accb7c4c35b300e14a5cdd251e08eb795b5f34bbaa246-Picture5.png)>\r\n\r\n##### 正确性证明：\r\n\r\n> 记每个状态为 $S(i, j)$ ，即 $S(i, j) = nums[i] + nums[j]$ 。假设 $S(i, j) < target$ ，则执行 $i = i + 1$ ，即状态切换至 $S(i + 1, j)$ 。\r\n\r\n- 状态 $S(i, j)$ 切换至 $S(i + 1, j)$ ，则会消去一行元素，相当于 **消去了状态集合** {$S(i, i + 1), S(i, i + 2), ..., S(i, j - 2), S(i, j - 1), S(i, j)$ } 。（由于双指针都是向中间收缩，因此这些状态之后不可能再遇到）。\r\n- 由于 $nums$ 是排序数组，因此这些 **消去的状态** 都一定满足 $S(i, j) < target$ ，即这些状态都 **不是解** 。\r\n- **结论：** 以上分析已证明 “每次指针 $i$ 的移动操作，都不会导致解的丢失” ，即指针 $i$ 的移动操作是 **安全的** ；同理，对于指针 $j$ 可得出同样推论；因此，此双指针法是正确的。\r\n\r\n![Picture1.png](https://pic.leetcode-cn.com/25bb748e0fc6f829056caf07716b96d02121625350afc012f2c351da73945f65-Picture1.png){:width=550}\r\n\r\n##### 复杂度分析：\r\n\r\n- **时间复杂度 $O(N)$ ：** $N$ 为数组 $nums$ 的长度；双指针共同线性遍历整个数组。\r\n- **空间复杂度 $O(1)$ ：** 变量 $i$, $j$ 使用常数大小的额外空间。\r\n\r\n#### 代码：\r\n\r\n```python []\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        i, j = 0, len(nums) - 1\r\n        while i < j:\r\n            s = nums[i] + nums[j]\r\n            if s > target: j -= 1\r\n            elif s < target: i += 1\r\n            else: return nums[i], nums[j]\r\n        return []\r\n```\r\n\r\n```java []\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        int i = 0, j = nums.length - 1;\r\n        while(i < j) {\r\n            int s = nums[i] + nums[j];\r\n            if(s < target) i++;\r\n            else if(s > target) j--;\r\n            else return new int[] { nums[i], nums[j] };\r\n        }\r\n        return new int[0];\r\n    }\r\n}\r\n```",
      "createdAt": "2020-03-22T07:16:09.427803+00:00",
      "hitCount": 74325,
      "identifier": "kQDkwV",
      "isEditorsPick": true,
      "isMostPopular": true,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "jian-zhi-offer-57-he-wei-sde-liang-ge-sh-qj4t",
        "title": "剑指 Offer 57. 和为s的两个数字（双指针）"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "he-wei-sde-liang-ge-shu-zi-lcof"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 178,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 18,
          "reactionType": "AWESOME"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 3,
          "reactionType": "CONFUSED"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 1,
          "reactionType": "THUMBS_DOWN"
        }
      ],
      "rewardEnabled": null,
      "slug": "mian-shi-ti-57-he-wei-s-de-liang-ge-shu-zi-shuang-",
      "status": "PUBLISHED",
      "summary": " 解题思路：\n利用 HashMap 可以通过遍历数组找到数字组合，时间和空间复杂度均为 O(N) ；\n注意本题的 nums 是 排序数组 ，因此可使用 双指针法 将空间复杂度降低至 O(1) 。\n 算法流程：\n\n初始化： 双指针 i , j 分别指向数组 nums 的左右两端 （俗称对撞双指针）。\n循环搜索： 当双指针",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Two Pointers",
          "nameTranslated": "双指针",
          "slug": "two-pointers",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python",
          "nameTranslated": "",
          "slug": "python",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python3",
          "nameTranslated": "",
          "slug": "python3",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "https://pic.leetcode-cn.com/25bb748e0fc6f829056caf07716b96d02121625350afc012f2c351da73945f65-Picture1.png",
      "title": "面试题57. 和为 s 的两个数字（双指针 + 证明，清晰图解）",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 137,
        "id": 164083,
        "viewCount": 60077
      },
      "uuid": "kQDkwV",
      "videosInfo": []
    }
  }
}
