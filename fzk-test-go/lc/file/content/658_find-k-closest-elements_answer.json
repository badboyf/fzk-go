{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "力扣 (LeetCode)",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2021/03/73c9f099-abbe-4d94-853f-f8abffd459cd/leetcode.png",
          "userSlug": "leetcode"
        },
        "username": "LeetCode"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "#### 方法 1： 使用 Collection.sort()\n\n**算法**\n\n直观地，我们可以将数组中的元素按照与目标 `x` 的差的绝对值排序，排好序后前 k 个元素就是我们需要的答案。\n\n```Java []\nclass Solution {\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\n        List<Integer> ret = Arrays.stream(arr).boxed().collect(Collectors.toList());\n        Collections.sort(ret, (a,b) -> a == b ? a - b : Math.abs(a-x) - Math.abs(b-x));\n        ret = ret.subList(0, k);\n        Collections.sort(ret);\n        return ret;\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度： $O(n\\log n)$。 Collections.sort() 使用二叉排序所以时间复杂度是 $O(n\\log n)$。\n\n* 空间复杂度： $O(k)$。就地排序不需要额外的空间。但是生成长度为 $k$ 的子列表需要消耗空间。\n\n#### 方法 2：二叉查找和双指针\n\n**算法**\n原本的数组是有序的，所以我们可以像如下步骤利用这一特点。\n1. 如果目标 `x` 小于等于有序数组的第一个元素，那么前 `k` 个元素就是答案。\n2. 类似的，如果目标 `x` 大于等于有序数组的最后一个元素，那么最后 `k` 个元素就是答案。\n3. 其他情况，我们可以使用二分查找来找到恰好大于 `x` 一点点的元素的索引 `index` 。然后让 `low` 等于 `index` 左边 `k-1` 个位置的索引，`high` 等于 `index` 右边 `k-1` 个位置的索引。我们需要的 $k$ 个数字肯定在范围 [index-k-1, index+k-1] 里面。所以我们可以根据以下规则缩小范围以得到答案。\n    * 如果 `low` 小于 `0` 或者 `low` 对应的元素比 `high` 对应的元素更接近 `x` ，那么减小 `high` 索引。\n    * 如果 `high` 大于最后一个元素的索引 `arr.size()-1` 或者它比起 `low` 对应的元素更接近 `x` ，那么增加 `low` 索引。\n    * 当且仅当 [low, high] 之间恰好有 k 个元素，循环终止，此时范围内的数就是答案。\n\n```Java []\npublic class Solution {\n \tpublic List<Integer> findClosestElements(int[] arr, int k, int x) {\n        List<Integer> ret = Arrays.stream(arr).boxed().collect(Collectors.toList());\n\t\tint n = ret.size();\n\t\tif (x <= ret.get(0)) {\n\t\t\treturn ret.subList(0, k);\n\t\t} else if (ret.get(n - 1) <= x) {\n\t\t\treturn ret.subList(n - k, n);\n\t\t} else {\n\t\t\tint index = Collections.binarySearch(ret, x);\n\t\t\tif (index < 0)\n\t\t\t\tindex = -index - 1;\n\t\t\tint low = Math.max(0, index - k - 1), high = Math.min(ret.size() - 1, index + k - 1);\n\n\t\t\twhile (high - low > k - 1) {\n\t\t\t\tif ((x - ret.get(low)) <= (ret.get(high) - x))\n\t\t\t\t\thigh--;\n\t\t\t\telse if ((x - ret.get(low)) > (ret.get(high) - x))\n\t\t\t\t\tlow++;\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"unhandled case: \" + low + \" \" + high);\n\t\t\t}\n\t\t\treturn ret.subList(low, high + 1);\n\t\t}\n\t}\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度： $O(\\log n +k)$。$O(\\log n)$ 是二分查找的时间，$O(k)$ 是压缩剩 $k$ 个元素的时间。\n\n* 空间复杂度： $O(k)$。产生结果数组所需要的空间。\n",
      "createdAt": "2019-09-25T16:56:28.759011+00:00",
      "hitCount": 22330,
      "identifier": "Wqdopd",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma",
        "title": "排除法（双指针）+ 二分法（Java、Python）"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "find-k-closest-elements"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 18,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 2,
          "reactionType": "CONFUSED"
        }
      ],
      "rewardEnabled": null,
      "slug": "zhao-dao-kge-zui-jie-jin-de-yuan-su-by-leetcode",
      "status": "PUBLISHED",
      "summary": " 方法 1： 使用 Collection.sort()\n算法\n直观地，我们可以将数组中的元素按照与目标 x 的差的绝对值排序，排好序后前 k 个元素就是我们需要的答案。\n复杂度分析\n\n\n时间复杂度： O(n\\log n)。 Collections.sort() 使用二叉排序所以时间复杂度是 O(n\\log n)。\n\n\n",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Two Pointers",
          "nameTranslated": "双指针",
          "slug": "two-pointers",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Binary Search",
          "nameTranslated": "二分查找",
          "slug": "binary-search",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "找到K个最接近的元素",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 41,
        "id": 30091,
        "viewCount": 15902
      },
      "uuid": "Wqdopd",
      "videosInfo": []
    }
  }
}
