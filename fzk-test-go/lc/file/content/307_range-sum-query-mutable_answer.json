{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "力扣 (LeetCode)",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2021/03/73c9f099-abbe-4d94-853f-f8abffd459cd/leetcode.png",
          "userSlug": "leetcode"
        },
        "username": "LeetCode"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "##  摘要：\n本文面向中级读者。它引入了以下概念：区域和检索、sqrt 分解、线段树。 \n\n##  解决方法：\n####  方法一：暴力解法（超时）\n区域和检索的一个简单的解决方案 - `RSQ(i, j)` 是将数组从索引 $i$ 迭代到 $j$ 并对每个元素求和。 \n\n```Java [ ]\nclass NumArray {\n\n    private int[] nums;\n\n    public NumArray(int[] nums) {\n        this.nums = nums;\n    }\n\n    public int sumRange(int i, int j) {\n        int sum = 0;\n        for (int l = i; l <= j; l++) {\n            sum += nums[l];\n        }\n        return sum;\n    }\n\n    public void update(int i, int val) {\n        nums[i] = val;\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(n)$。区域和检索 $O(1)$ 的更新查询\n 对于区域和检索，我们从数组中访问每个元素的时间是固定的，在最坏的情况下，我们访问 $n$ 元素。因此，时间复杂度为 $O(n)$。更新查询的时间复杂度为 $O(1)$。 \n* 空间复杂度：$O(1)$\n\n\n####  方法二：sqrt 分解 \n其思想是将数组分割成块，块的长度为 $\\sqrt n$。然后我们计算每个块的和，并将其存储在辅助存储器 `b` 中。要查询 `RSQ(i, j)`，我们将添加位于内部的所有块和部分在范围 $[i\\ldots j]$ 重叠的块的总和。 \n\n**算法：**\n\n![在这里插入图片描述](https://pic.leetcode-cn.com/78228fc5dd4fc247edd104eed32351f25e449f858b67acf96845474981bbf451-file_1561890424409){:width=\"500\"}\n{:align=center}\n\n 在上面的示例中，数组 `nums` 的长度为 9，它被拆分为大小为 $\\sqrt 9$ 的块。为了得到 `RSQ(1, 7)`，我们添加 `b[1]`。它存储范围 `[3，5]` 的和，以及 `块0` 和 `块2` 的部分和，它们是重叠的边界块。 \n \n\n```Java [ ]\nclass NumArray {\n\n    private int[] b;\n    private int len;\n    private int[] nums;\n\n    public NumArray(int[] nums) {\n        this.nums = nums;\n        double l = Math.sqrt(nums.length);\n        len = (int) Math.ceil(nums.length / l);\n        b = new int[len];\n        for (int i = 0; i < nums.length; i++) {\n            b[i / len] += nums[i];\n        }\n    }\n\n    public int sumRange(int i, int j) {\n        int sum = 0;\n        int startBlock = i / len;\n        int endBlock = j / len;\n        if (startBlock == endBlock) {\n            for (int k = i; k <= j; k++) {\n                sum += nums[k];\n            }\n        } else {\n            for (int k = i; k <= (startBlock + 1) * len - 1; k++) {\n                sum += nums[k];\n            }\n            for (int k = startBlock + 1; k <= endBlock - 1; k++) {\n                sum += b[k];\n            }\n            for (int k = endBlock * len; k <= j; k++) {\n                sum += nums[k];\n            }\n        }\n        return sum;\n    }\n\n    public void update(int i, int val) {\n        int b_l = i / len;\n        b[b_l] = b[b_l] - nums[i] + val;\n        nums[i] = val;\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(n)$ 预处理，$O(\\sqrt n)$ 区域和检索，$O(1)$ 更新查询 \n* 空间复杂度：$O(\\sqrt{n})$，我们需要额外的 $\\sqrt {n}$ 内存来存储所有块和。\n\n\n####  方法三：线段树\n**算法：**\n线段树是一种非常灵活的数据结构，它可以用于解决多种范围查询问题，比如在对数时间内从数组中找到最小值、最大值、总和、最大公约数、最小公倍数等。\n\n![image.png](https://pic.leetcode-cn.com/1612755542-DwOLuj-image.png){:width=\"350\"}{:align=center}\n\n\n\n\n数组 $A[0,1,\\ldots,n-1]$ 的线段树是一个二叉树，其中每个节点都包含数组的一个子范围 $[i\\ldots j]$ 上的**聚合**信息（最小值、最大值、总和等），其左、右子节点分别包含范围 $[i \\ldots \\frac{i+j}{2}]$ 和 $[\\frac{i + j}{2} + 1, j]$ 上的信息。 \n\n线段树既可以用数组也可以用树来实现。对于数组实现，如果索引 $i$ 处的元素不是一个叶节点，那么其左子节点和右子节点分别存储在索引为 $2i$ 和 $2i+1$ 的元素处。 \n\n在上图所给出的示例中，每个叶节点都包含初始的数组元素 `{2,4,5,7,8,9}`。内部节点包含范围内相应元素的总和 -  `(11)` 是从索引 0 到索引 2 的元素之和。而根节点 `(35)` 是它的两个子节点 `(6)` 和 `(29)` 的和,也是整个数组的和。\n\n线段树可以分为以下三个步骤： \n 1. 从给定数组构建线段树的预处理步骤。\n 2. 修改元素时更新线段树。\n 3. 使用线段树进行区域和检索。\n\n\n**构建线段树 :**\n我们将使用一种非常有效的自下而上的方法来构建线段树。从上面我们已经知道，如果某个节点 $p$ 包含范围 $[i\\ldots j]$ 的和，那么其左、右子节点分别包含范围 $[i \\ldots \\frac{i + j}{2}]$ 和 $[\\frac{i + j}{2} + 1, j]$ 上的和。 \n\n因此，为了找到节点 $p$ 的和，我们需要提前计算其左、右子节点的和。 \n\n我们从叶节点开始，用输入数组的元素 $a[0,1,\\ldots,n-1]$ 初始化它们。然后我们逐步向上移动到更高一层来计算父节点的和，直到最后到达线段树的根节点。\n\n```Java [ ]\nint[] tree;\nint n;\npublic NumArray(int[] nums) {\n    if (nums.length > 0) {\n        n = nums.length;\n        tree = new int[n * 2];\n        buildTree(nums);\n    }\n}\nprivate void buildTree(int[] nums) {\n    for (int i = n, j = 0;  i < 2 * n; i++,  j++)\n        tree[i] = nums[j];\n    for (int i = n - 1; i > 0; --i)\n        tree[i] = tree[i * 2] + tree[i * 2 + 1];\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(n)$。\n 1. 因为我们在 `for` 循环的每次迭代中计算一个节点的和。而一个线段树中大约有 $2n$ 个节点。 \n 2. 这可以通过以下方式证明：具有 $n$ 个元素的数组线段树有 $n$ 个叶节点（数组元素本身）。每一层中的节点数是下面一层中节点数的一半。 \n 3. 因此，如果我们按层对节点数求和，我们将得到：\n$$\nn + n/2  + n/4 + n/8 + \\ldots + 1 \\approx 2n\n$$\n* 空间复杂度：$O(n)$，我们用了 $2n$ 的额外空间来存储整个线段树。\n\n**更新线段树 :**\n当我们更新数组中某个索引 $i$ 处的元素时，我们需要重建线段树，因为一些树节点上的和值也会随之产生变化。我们将再次使用自下而上的方法。首先更新存储 $a[i]$ 元素的叶节点。从那里我们将一路向上，直到根节点，并用其子节点值的总和来更新每个父节点的值。 \n\n```Java [ ]\nvoid update(int pos, int val) {\n    pos += n;\n    tree[pos] = val;\n    while (pos > 0) {\n        int left = pos;\n        int right = pos;\n        if (pos % 2 == 0) {\n            right = pos + 1;\n        } else {\n            left = pos - 1;\n        }\n        // parent is updated after child is updated\n        tree[pos / 2] = tree[left] + tree[right];\n        pos /= 2;\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(\\log n)$。算法的时间复杂度为 $O(\\log n)$，因为有几个树节点的范围包括第 $i$ 个数组元素，每个层上都有一个。共有 $\\log(n)$ 层。 \n* 空间复杂度：$O(1)$。\n\n**区域和检索：**\n\n我们可以通过以下方式使用线段树进行区域和检索 $[L, R]$：算法保持循环不变：$l \\le r$ 以及已经算出 $[L \\ldots l]$ 和 $[r \\ldots R]$ 的总和，其中 $l$ 和 $r$ 分别是计算总和时的左边界和右边界。每次迭代的范围 $[l,r]$ 都会缩小，直到在算法的大约 $log n$ 次迭代后两个边界相遇为止。 \n\n```Java [ ]\npublic int sumRange(int l, int r) {\n    // get leaf with value 'l'\n    l += n;\n    // get leaf with value 'r'\n    r += n;\n    int sum = 0;\n    while (l <= r) {\n        if ((l % 2) == 1) {\n           sum += tree[l];\n           l++;\n        }\n        if ((r % 2) == 0) {\n           sum += tree[r];\n           r--;\n        }\n        l /= 2;\n        r /= 2;\n    }\n    return sum;\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(\\log n)$。因为在算法的每次迭代中，我们会向上移动一层，要么移动到当前节点的父节点，要么移动到父节点的左侧或者右侧的兄弟节点，直到两个边界相交为止。在最坏的情况下，这种情况会在算法进行 $\\log n$ 次迭代后发生在根节点。 \n* 空间复杂度：$O(1)$。",
      "createdAt": "2019-06-30T09:50:26.143337+00:00",
      "hitCount": 28491,
      "identifier": "j0XtMW",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "cong-wei-yun-suan-kai-shi-de-shu-zhuang-k6dqb",
        "title": "从位运算开始的树状数组入门篇 （原理，机制与实现）"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "range-sum-query-mutable"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 63,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 7,
          "reactionType": "AWESOME"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 1,
          "reactionType": "CONFUSED"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 1,
          "reactionType": "THUMBS_DOWN"
        }
      ],
      "rewardEnabled": null,
      "slug": "qu-yu-he-jian-suo-shu-zu-ke-xiu-gai-by-leetcode",
      "status": "PREPUBLISH",
      "summary": "摘要：\n本文面向中级读者。它引入了以下概念：区域和检索、sqrt 分解、线段树。\n解决方法：\n 方法一：暴力解法（超时）\n区域和检索的一个简单的解决方案 - RSQ(i, j) 是将数组从索引 i 迭代到 j 并对每个元素求和。\n复杂度分析\n\n时间复杂度：O(n)。区域和检索 O(1) 的更新查询\n对于区域和检索，我们",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "https://pic.leetcode-cn.com/78228fc5dd4fc247edd104eed32351f25e449f858b67acf96845474981bbf451-file_1561890424409",
      "title": "区域和检索 - 数组可修改",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 79,
        "id": 11539,
        "viewCount": 19085
      },
      "uuid": "j0XtMW",
      "videosInfo": []
    }
  }
}
