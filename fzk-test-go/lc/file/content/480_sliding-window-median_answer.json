{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "力扣官方题解",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/leetcode-solution/avatar_1582018938.png",
          "userSlug": "leetcode-solution"
        },
        "username": "LeetCode-Solution"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "#### 前言\n\n本题是「[295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)」的进阶版本。\n\n我们首先思考一下完成本题需要做哪些事情：\n\n- 初始时，我们需要将数组 $\\textit{nums}$ 中的前 $k$ 个元素放入一个滑动窗口，并且求出它们的中位数；\n\n- 随后滑动窗口会向右进行移动。每一次移动后，会将一个新的元素放入滑动窗口，并且将一个旧的元素移出滑动窗口，最后再求出它们的中位数。\n\n因此，我们需要设计一个「数据结构」，用来维护滑动窗口，并且需要提供如下的三个接口：\n\n- $\\texttt{insert(num)}$：将一个数 $\\textit{num}$ 加入数据结构；\n\n- $\\texttt{erase(num)}$：将一个数 $\\textit{num}$ 移出数据结构；\n\n- $\\texttt{getMedian()}$：返回当前数据结构中所有数的中位数。\n\n#### 方法一：双优先队列 + 延迟删除\n\n**思路与算法**\n\n我们可以使用两个优先队列（堆）维护所有的元素，第一个优先队列 $\\textit{small}$ 是一个大根堆，它负责维护所有元素中较小的那一半；第二个优先队列 $\\textit{large}$ 是一个小根堆，它负责维护所有元素中较大的那一半。具体地，如果当前需要维护的元素个数为 $x$，那么 $\\textit{small}$ 中维护了 $\\lceil \\frac{x}{2} \\rceil$ 个元素，$\\textit{large}$ 中维护了 $\\lfloor \\frac{x}{2} \\rfloor$ 个元素，其中 $\\lceil y \\rceil$ 和 $\\lfloor y \\rfloor$ 分别表示将 $y$ 向上取整和向下取整。也就是说：\n\n> $\\textit{small}$ 中的元素个数要么与 $\\textit{large}$ 中的元素个数相同，要么比 $\\textit{large}$ 中的元素个数恰好多 $1$ 个。\n\n这样设计的好处在于：当二者包含的元素个数相同时，它们各自的堆顶元素的平均值即为中位数；而当 $\\textit{small}$ 包含的元素多了一个时，$\\textit{small}$ 的堆顶元素即为中位数。这样 $\\texttt{getMedian()}$ 就设计完成了。\n\n而对于 $\\texttt{insert(num)}$ 而言，如果当前两个优先队列都为空，那么根据元素个数的要求，我们必须将这个元素加入 $\\textit{small}$；如果 $\\textit{small}$ 非空（显然不会存在 $\\textit{small}$ 空而 $\\textit{large}$ 非空的情况），我们就可以将 $\\textit{num}$ 与 $\\textit{small}$ 的堆顶元素 $\\textit{top}$ 比较：\n\n- 如果 $\\textit{num} \\leq \\textit{top}$，我们就将其加入 $\\textit{small}$ 中；\n\n- 如果 $\\textit{num} > \\textit{top}$，我们就将其加入 $\\textit{large}$ 中。\n\n在成功地加入元素 $\\textit{num}$ 之后，两个优先队列的元素个数可能会变得不符合要求。由于我们只加入了一个元素，那么不符合要求的情况只能是下面的二者之一：\n\n- $\\textit{small}$ 比 $\\textit{large}$ 的元素个数多了 $2$ 个；\n\n- $\\textit{small}$ 比 $\\textit{large}$ 的元素个数少了 $1$ 个。\n\n对于第一种情况，我们将 $\\textit{small}$ 的堆顶元素放入 $\\textit{large}$；对于第二种情况，我们将 $\\textit{large}$ 的堆顶元素放入 $\\textit{small}$，这样就可以解决问题了，$\\texttt{insert(num)}$ 也就设计完成了。\n\n然而对于 $\\texttt{erase(num)}$ 而言，设计起来就不是那么容易了，因为我们知道，**优先队列是不支持移出非堆顶元素**这一操作的，因此我们可以考虑使用「延迟删除」的技巧，即：\n\n> 当我们需要移出优先队列中的某个元素时，我们只将这个删除操作「记录」下来，而不去真的删除这个元素。当这个元素出现在 $\\textit{small}$ 或者 $\\textit{large}$ 的堆顶时，我们再去将其移出对应的优先队列。\n\n「延迟删除」使用到的辅助数据结构一般为哈希表 $\\textit{delayed}$，其中的每个键值对 $(\\textit{num}, \\textit{freq})$，表示元素 $\\textit{num}$ 还需要被删除 $\\textit{freq}$ 次。「优先队列 + 延迟删除」有非常多种设计方式，体现在「延迟删除」的时机选择。在本题解中，我们使用一种比较容易编写代码的设计方式，即：\n\n> 我们保证在任意操作 $\\texttt{insert(num)}$，$\\texttt{erase(num)}$，$\\texttt{getMedian()}$ 完成之后（或者说任意操作开始之前），$\\textit{small}$ 和 $\\textit{large}$ 的堆顶元素都是不需要被「延迟删除」的。这样设计的好处在于：我们无需更改 $\\texttt{getMedian()}$ 的设计，只需要略加修改 $\\texttt{insert(num)}$ 即可。\n\n我们首先设计一个辅助函数 $\\texttt{prune(heap)}$，它的作用很简单，就是对 $\\textit{heap}$ 这个优先队列（$\\textit{small}$ 或者 $\\textit{large}$ 之一），不断地弹出其需要被删除的堆顶元素，并且减少 $\\textit{delayed}$ 中对应项的值。在 $\\texttt{prune(heap)}$ 完成之后，我们就可以保证 **$\\textit{heap}$ 的堆顶元素是不需要被「延迟删除」的**。\n\n这样我们就可以在 $\\texttt{prune(heap)}$ 的基础上设计另一个辅助函数 $\\texttt{makeBalance()}$，它的作用即为调整 $\\textit{small}$ 和 $\\textit{large}$ 中的元素个数，使得二者的元素个数满足要求。由于有了 $\\texttt{erase(num)}$ 以及「延迟删除」，我们在将一个优先队列的堆顶元素放入另一个优先队列时，第一个优先队列的堆顶元素可能是需要删除的。因此我们就可以用 $\\texttt{makeBalance()}$ 将 $\\texttt{prune(heap)}$ 封装起来，它的逻辑如下：\n\n- 如果 $\\textit{small}$ 和 $\\textit{large}$ 中的元素个数满足要求，则不进行任何操作；\n\n- 如果 $\\textit{small}$ 比 $\\textit{large}$ 的元素个数多了 $2$ 个，那么我们我们将 $\\textit{small}$ 的堆顶元素放入 $\\textit{large}$。此时 $\\textit{small}$ 的对应元素可能是需要删除的，因此我们调用 $\\texttt{prune(small)}$；\n\n- 如果 $\\textit{small}$ 比 $\\textit{large}$ 的元素个数少了 $1$ 个，那么我们将 $\\textit{large}$ 的堆顶元素放入 $\\textit{small}$。此时 $\\textit{large}$ 的对应的元素可能是需要删除的，因此我们调用 $\\texttt{prune(large)}$。\n\n此时，我们只需要在原先 $\\texttt{insert(num)}$ 的设计的最后加上一步 $\\texttt{makeBalance()}$ 即可。然而对于 $\\texttt{erase(num)}$，我们还是需要进行一些思考的：\n\n- 如果 $\\textit{num}$ 与 $\\textit{small}$ 和 $\\textit{large}$ 的堆顶元素都不相同，那么 $\\textit{num}$ 是需要被「延迟删除」的，我们将其在哈希表中的值增加 $1$；\n\n- 否则，例如 $\\textit{num}$ 与 $\\textit{small}$ 的堆顶元素相同，那么该元素是可以理解被删除的。虽然我们没有实现「立即删除」这个辅助函数，但只要我们将 $\\textit{num}$ 在哈希表中的值增加 $1$，并且调用「延迟删除」的辅助函数 $\\texttt{prune(small)}$，那么就相当于实现了「立即删除」的功能。\n\n无论是「立即删除」还是「延迟删除」，其中一个优先队列中的元素个数发生了变化（减少了 $1$），因此我们还需要用 $\\texttt{makeBalance()}$ 调整元素的个数。\n\n此时，所有的接口都已经设计完成了。由于 $\\texttt{insert(num)}$ 和 $\\texttt{erase(num)}$ 的最后一步都是 $\\texttt{makeBalance()}$，而 $\\texttt{makeBalance()}$ 的最后一步是 $\\texttt{prune(heap)}$，因此我们就保证了任意操作完成之后，$\\textit{small}$ 和 $\\textit{large}$ 的堆顶元素都是不需要被「延迟删除」的。\n\n具体实现的细节相对较多，读者可以参考下面的代码和注释进一步理解。\n\n**代码**\n\n```C++ [sol1-C++]\nclass DualHeap {\nprivate:\n    // 大根堆，维护较小的一半元素\n    priority_queue<int> small;\n    // 小根堆，维护较大的一半元素\n    priority_queue<int, vector<int>, greater<int>> large;\n    // 哈希表，记录「延迟删除」的元素，key 为元素，value 为需要删除的次数\n    unordered_map<int, int> delayed;\n\n    int k;\n    // small 和 large 当前包含的元素个数，需要扣除被「延迟删除」的元素\n    int smallSize, largeSize;\n\npublic:\n    DualHeap(int _k): k(_k), smallSize(0), largeSize(0) {}\n\nprivate:\n    // 不断地弹出 heap 的堆顶元素，并且更新哈希表\n    template<typename T>\n    void prune(T& heap) {\n        while (!heap.empty()) {\n            int num = heap.top();\n            if (delayed.count(num)) {\n                --delayed[num];\n                if (!delayed[num]) {\n                    delayed.erase(num);\n                }\n                heap.pop();\n            }\n            else {\n                break;\n            }\n        }\n    }\n\n    // 调整 small 和 large 中的元素个数，使得二者的元素个数满足要求\n    void makeBalance() {\n        if (smallSize > largeSize + 1) {\n            // small 比 large 元素多 2 个\n            large.push(small.top());\n            small.pop();\n            --smallSize;\n            ++largeSize;\n            // small 堆顶元素被移除，需要进行 prune\n            prune(small);\n        }\n        else if (smallSize < largeSize) {\n            // large 比 small 元素多 1 个\n            small.push(large.top());\n            large.pop();\n            ++smallSize;\n            --largeSize;\n            // large 堆顶元素被移除，需要进行 prune\n            prune(large);\n        }\n    }\n\npublic:\n    void insert(int num) {\n        if (small.empty() || num <= small.top()) {\n            small.push(num);\n            ++smallSize;\n        }\n        else {\n            large.push(num);\n            ++largeSize;\n        }\n        makeBalance();\n    }\n\n    void erase(int num) {\n        ++delayed[num];\n        if (num <= small.top()) {\n            --smallSize;\n            if (num == small.top()) {\n                prune(small);\n            }\n        }\n        else {\n            --largeSize;\n            if (num == large.top()) {\n                prune(large);\n            }\n        }\n        makeBalance();\n    }\n\n    double getMedian() {\n        return k & 1 ? small.top() : ((double)small.top() + large.top()) / 2;\n    }\n};\n\nclass Solution {\npublic:\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\n        DualHeap dh(k);\n        for (int i = 0; i < k; ++i) {\n            dh.insert(nums[i]);\n        }\n        vector<double> ans = {dh.getMedian()};\n        for (int i = k; i < nums.size(); ++i) {\n            dh.insert(nums[i]);\n            dh.erase(nums[i - k]);\n            ans.push_back(dh.getMedian());\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    public double[] medianSlidingWindow(int[] nums, int k) {\n        DualHeap dh = new DualHeap(k);\n        for (int i = 0; i < k; ++i) {\n            dh.insert(nums[i]);\n        }\n        double[] ans = new double[nums.length - k + 1];\n        ans[0] = dh.getMedian();\n        for (int i = k; i < nums.length; ++i) {\n            dh.insert(nums[i]);\n            dh.erase(nums[i - k]);\n            ans[i - k + 1] = dh.getMedian();\n        }\n        return ans;\n    }\n}\n\nclass DualHeap {\n    // 大根堆，维护较小的一半元素\n    private PriorityQueue<Integer> small;\n    // 小根堆，维护较大的一半元素\n    private PriorityQueue<Integer> large;\n    // 哈希表，记录「延迟删除」的元素，key 为元素，value 为需要删除的次数\n    private Map<Integer, Integer> delayed;\n\n    private int k;\n    // small 和 large 当前包含的元素个数，需要扣除被「延迟删除」的元素\n    private int smallSize, largeSize;\n\n    public DualHeap(int k) {\n        this.small = new PriorityQueue<Integer>(new Comparator<Integer>() {\n            public int compare(Integer num1, Integer num2) {\n                return num2.compareTo(num1);\n            }\n        });\n        this.large = new PriorityQueue<Integer>(new Comparator<Integer>() {\n            public int compare(Integer num1, Integer num2) {\n                return num1.compareTo(num2);\n            }\n        });\n        this.delayed = new HashMap<Integer, Integer>();\n        this.k = k;\n        this.smallSize = 0;\n        this.largeSize = 0;\n    }\n\n    public double getMedian() {\n        return (k & 1) == 1 ? small.peek() : ((double) small.peek() + large.peek()) / 2;\n    }\n\n    public void insert(int num) {\n        if (small.isEmpty() || num <= small.peek()) {\n            small.offer(num);\n            ++smallSize;\n        } else {\n            large.offer(num);\n            ++largeSize;\n        }\n        makeBalance();\n    }\n\n    public void erase(int num) {\n        delayed.put(num, delayed.getOrDefault(num, 0) + 1);\n        if (num <= small.peek()) {\n            --smallSize;\n            if (num == small.peek()) {\n                prune(small);\n            }\n        } else {\n            --largeSize;\n            if (num == large.peek()) {\n                prune(large);\n            }\n        }\n        makeBalance();\n    }\n\n    // 不断地弹出 heap 的堆顶元素，并且更新哈希表\n    private void prune(PriorityQueue<Integer> heap) {\n        while (!heap.isEmpty()) {\n            int num = heap.peek();\n            if (delayed.containsKey(num)) {\n                delayed.put(num, delayed.get(num) - 1);\n                if (delayed.get(num) == 0) {\n                    delayed.remove(num);\n                }\n                heap.poll();\n            } else {\n                break;\n            }\n        }\n    }\n\n    // 调整 small 和 large 中的元素个数，使得二者的元素个数满足要求\n    private void makeBalance() {\n        if (smallSize > largeSize + 1) {\n            // small 比 large 元素多 2 个\n            large.offer(small.poll());\n            --smallSize;\n            ++largeSize;\n            // small 堆顶元素被移除，需要进行 prune\n            prune(small);\n        } else if (smallSize < largeSize) {\n            // large 比 small 元素多 1 个\n            small.offer(large.poll());\n            ++smallSize;\n            --largeSize;\n            // large 堆顶元素被移除，需要进行 prune\n            prune(large);\n        }\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass DualHeap:\n    def __init__(self, k: int):\n        # 大根堆，维护较小的一半元素，注意 python 没有大根堆，需要将所有元素取相反数并使用小根堆\n        self.small = list()\n        # 小根堆，维护较大的一半元素\n        self.large = list()\n        # 哈希表，记录「延迟删除」的元素，key 为元素，value 为需要删除的次数\n        self.delayed = collections.Counter()\n\n        self.k = k\n        # small 和 large 当前包含的元素个数，需要扣除被「延迟删除」的元素\n        self.smallSize = 0\n        self.largeSize = 0\n\n\n    # 不断地弹出 heap 的堆顶元素，并且\u0008更新哈希表\n    def prune(self, heap: List[int]):\n        while heap:\n            num = heap[0]\n            if heap is self.small:\n                num = -num\n            if num in self.delayed:\n                self.delayed[num] -= 1\n                if self.delayed[num] == 0:\n                    self.delayed.pop(num)\n                heapq.heappop(heap)\n            else:\n                break\n    \n    # 调整 small 和 large 中的元素个数，使得二者的元素个数满足要求\n    def makeBalance(self):\n        if self.smallSize > self.largeSize + 1:\n            # small 比 large 元素多 2 个\n            heapq.heappush(self.large, -self.small[0])\n            heapq.heappop(self.small)\n            self.smallSize -= 1\n            self.largeSize += 1\n            # small 堆顶元素被移除，需要进行 prune\n            self.prune(self.small)\n        elif self.smallSize < self.largeSize:\n            # large 比 small 元素多 1 个\n            heapq.heappush(self.small, -self.large[0])\n            heapq.heappop(self.large)\n            self.smallSize += 1\n            self.largeSize -= 1\n            # large 堆顶元素被移除，需要进行 prune\n            self.prune(self.large)\n\n    def insert(self, num: int):\n        if not self.small or num <= -self.small[0]:\n            heapq.heappush(self.small, -num)\n            self.smallSize += 1\n        else:\n            heapq.heappush(self.large, num)\n            self.largeSize += 1\n        self.makeBalance()\n\n    def erase(self, num: int):\n        self.delayed[num] += 1\n        if num <= -self.small[0]:\n            self.smallSize -= 1\n            if num == -self.small[0]:\n                self.prune(self.small)\n        else:\n            self.largeSize -= 1\n            if num == self.large[0]:\n                self.prune(self.large)\n        self.makeBalance()\n\n    def getMedian(self) -> float:\n        return float(-self.small[0]) if self.k % 2 == 1 else (-self.small[0] + self.large[0]) / 2\n\n\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        dh = DualHeap(k)\n        for num in nums[:k]:\n            dh.insert(num)\n        \n        ans = [dh.getMedian()]\n        for i in range(k, len(nums)):\n            dh.insert(nums[i])\n            dh.erase(nums[i - k])\n            ans.append(dh.getMedian())\n        \n        return ans\n```\n\n```go [sol1-Golang]\ntype hp struct {\n    sort.IntSlice\n    size int\n}\nfunc (h *hp) Push(v interface{}) { h.IntSlice = append(h.IntSlice, v.(int)) }\nfunc (h *hp) Pop() interface{}   { a := h.IntSlice; v := a[len(a)-1]; h.IntSlice = a[:len(a)-1]; return v }\nfunc (h *hp) push(v int)         { h.size++; heap.Push(h, v) }\nfunc (h *hp) pop() int           { h.size--; return heap.Pop(h).(int) }\nfunc (h *hp) prune() {\n    for h.Len() > 0 {\n        num := h.IntSlice[0]\n        if h == small {\n            num = -num\n        }\n        if d, has := delayed[num]; has {\n            if d > 1 {\n                delayed[num]--\n            } else {\n                delete(delayed, num)\n            }\n            heap.Pop(h)\n        } else {\n            break\n        }\n    }\n}\n\nvar delayed map[int]int\nvar small, large *hp\n\nfunc medianSlidingWindow(nums []int, k int) []float64 {\n    delayed = map[int]int{} // 哈希表，记录「延迟删除」的元素，key 为元素，value 为需要删除的次数\n    small = &hp{}           // 大根堆，维护较小的一半元素\n    large = &hp{}           // 小根堆，维护较大的一半元素\n    makeBalance := func() {\n        // 调整 small 和 large 中的元素个数，使得二者的元素个数满足要求\n        if small.size > large.size+1 { // small 比 large 元素多 2 个\n            large.push(-small.pop())\n            small.prune() // small 堆顶元素被移除，需要进行 prune\n        } else if small.size < large.size { // large 比 small 元素多 1 个\n            small.push(-large.pop())\n            large.prune() // large 堆顶元素被移除，需要进行 prune\n        }\n    }\n    insert := func(num int) {\n        if small.Len() == 0 || num <= -small.IntSlice[0] {\n            small.push(-num)\n        } else {\n            large.push(num)\n        }\n        makeBalance()\n    }\n    erase := func(num int) {\n        delayed[num]++\n        if num <= -small.IntSlice[0] {\n            small.size--\n            if num == -small.IntSlice[0] {\n                small.prune()\n            }\n        } else {\n            large.size--\n            if num == large.IntSlice[0] {\n                large.prune()\n            }\n        }\n        makeBalance()\n    }\n    getMedian := func() float64 {\n        if k&1 > 0 {\n            return float64(-small.IntSlice[0])\n        }\n        return float64(-small.IntSlice[0]+large.IntSlice[0]) / 2\n    }\n\n    for _, num := range nums[:k] {\n        insert(num)\n    }\n    n := len(nums)\n    ans := make([]float64, 1, n-k+1)\n    ans[0] = getMedian()\n    for i := k; i < n; i++ {\n        insert(nums[i])\n        erase(nums[i-k])\n        ans = append(ans, getMedian())\n    }\n    return ans\n}\n```\n\n```C [sol1-C]\nstruct Heap {\n    int* heap;\n    int heapSize;\n    int realSize;\n    bool (*cmp)(int, int);\n};\n\nvoid init(struct Heap* obj, int n, bool (*cmp)(int, int)) {\n    obj->heap = malloc(sizeof(int) * (n + 1));\n    obj->heapSize = 0;\n    obj->cmp = cmp;\n}\n\nbool cmp1(int a, int b) {\n    return a < b;\n}\n\nbool cmp2(int a, int b) {\n    return a > b;\n}\n\nvoid swap(int* a, int* b) {\n    int tmp = *a;\n    *a = *b, *b = tmp;\n}\n\nvoid push(struct Heap* obj, int x) {\n    int p = ++(obj->heapSize), q = p >> 1;\n    obj->heap[p] = x;\n    while (q) {\n        if (!obj->cmp(obj->heap[q], obj->heap[p])) {\n            break;\n        }\n        swap(&(obj->heap[q]), &(obj->heap[p]));\n        p = q, q = p >> 1;\n    }\n}\n\nvoid pop(struct Heap* obj) {\n    swap(&(obj->heap[1]), &(obj->heap[(obj->heapSize)--]));\n    int p = 1, q = p << 1;\n    while (q <= obj->heapSize) {\n        if (q + 1 <= obj->heapSize) {\n            if (obj->cmp(obj->heap[q], obj->heap[q + 1])) {\n                q++;\n            }\n        }\n        if (!obj->cmp(obj->heap[p], obj->heap[q])) {\n            break;\n        }\n        swap(&(obj->heap[q]), &(obj->heap[p]));\n        p = q, q = p << 1;\n    }\n}\n\nint top(struct Heap* obj) {\n    return obj->heap[1];\n}\n\nbool empty(struct Heap* obj) {\n    return obj->heapSize == 0;\n}\n\nstruct HashTable {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} * hashtable;\n\nvoid prune(struct Heap* obj) {\n    while (!empty(obj)) {\n        int num = top(obj);\n        struct HashTable* tmp;\n        HASH_FIND_INT(hashtable, &num, tmp);\n        if (tmp == NULL) {\n            break;\n        }\n        tmp->val--;\n        if (!(tmp->val)) {\n            HASH_DEL(hashtable, tmp);\n            free(tmp);\n        }\n        pop(obj);\n    }\n}\n\nvoid makeBalance(struct Heap* small, struct Heap* large) {\n    if (small->realSize > large->realSize + 1) {\n        push(large, top(small));\n        pop(small);\n        --(small->realSize);\n        ++(large->realSize);\n        prune(small);\n    } else if (small->realSize < large->realSize) {\n        push(small, top(large));\n        pop(large);\n        ++(small->realSize);\n        --(large->realSize);\n        prune(large);\n    }\n}\n\nvoid insert(struct Heap* small, struct Heap* large, int num) {\n    if (empty(small) || num <= top(small)) {\n        push(small, num);\n        ++(small->realSize);\n    } else {\n        push(large, num);\n        ++(large->realSize);\n    }\n    makeBalance(small, large);\n}\n\nvoid erase(struct Heap* small, struct Heap* large, int num) {\n    struct HashTable* tmp;\n    HASH_FIND_INT(hashtable, &num, tmp);\n    if (tmp == NULL) {\n        tmp = malloc(sizeof(struct HashTable));\n        tmp->key = num;\n        tmp->val = 1;\n        HASH_ADD_INT(hashtable, key, tmp);\n    } else {\n        tmp->val++;\n    }\n    if (num <= top(small)) {\n        --(small->realSize);\n        if (num == top(small)) {\n            prune(small);\n        }\n    } else {\n        --(large->realSize);\n        if (num == top(large)) {\n            prune(large);\n        }\n    }\n    makeBalance(small, large);\n}\n\ndouble getMedian(struct Heap* small, struct Heap* large, int k) {\n    return (k & 1) ? top(small) : (((double)top(small) + top(large)) / 2);\n}\n\ndouble* medianSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\n    hashtable = NULL;\n    struct Heap* small = malloc(sizeof(struct Heap));\n    init(small, numsSize, cmp1);\n    struct Heap* large = malloc(sizeof(struct Heap));\n    init(large, numsSize, cmp2);\n    for (int i = 0; i < k; ++i) {\n        insert(small, large, nums[i]);\n    }\n    double* ans = malloc(sizeof(double) * (numsSize - k + 1));\n    *returnSize = 0;\n    ans[(*returnSize)++] = getMedian(small, large, k);\n    for (int i = k; i < numsSize; ++i) {\n        insert(small, large, nums[i]);\n        erase(small, large, nums[i - k]);\n        ans[(*returnSize)++] = getMedian(small, large, k);\n    }\n    return ans;\n}\n```\n\n**复杂度分析**\n\n由于「延迟删除」的存在，$\\textit{small}$ 比 $\\textit{large}$ 在最坏情况下可能包含所有的 $n$ 个元素，即没有一个元素被真正删除了。因此优先队列的大小是 $O(n)$ 而不是 $O(k)$ 的，其中 $n$ 是数组 $\\textit{nums}$ 的长度。\n\n- 时间复杂度：$O(n\\log n)$。$\\texttt{insert(num)}$ 和 $\\texttt{erase(num)}$ 的单次时间复杂度为 $O(\\log n)$，$\\texttt{getMedian()}$ 的单次时间复杂度为 $O(1)$。因此总时间复杂度为 $O(n\\log n)$。\n\n- 空间复杂度：$O(n)$。即为 $\\textit{small}$，$\\textit{large}$ 和 $\\textit{delayed}$ 需要使用的空间。\n\n#### 结语\n\n读者可以尝试回答如下的两个问题来检验自己是否掌握了该方法：\n\n- 在 $\\texttt{insert(num)}$ 的最后我们加上了一步 $\\texttt{makeBalance()}$，其中包括可能进行的 $\\texttt{prune(heap)}$ 操作，这对于 $\\texttt{insert(num)}$ 操作而言是否是必要的？\n\n- 在 $\\texttt{insert(num)}$ 的过程中，如果我们将 $\\texttt{insert(num)}$ 放入了 $\\textit{large}$ 中，并且 $\\textit{num}$ 恰好出现在 $\\textit{large}$ 的堆顶位置，且两个优先队列的元素个数满足要求，不需要进行调整。此时会不会出现 $\\textit{num}$ 是一个需要被「延迟删除」的元素的情况，这样就不满足在 $\\texttt{insert(num)}$ 操作完成之后 $\\textit{large}$ 的堆顶是不需要被「延迟删除」的要求了？\n\n**答案**\n\n- 是必要的。举个例子：在 $\\texttt{insert(num)}$ 操作之前，$\\textit{large}$ 的堆顶元素是有效的，但其中第二小的元素是需要被删除的。此时，如果我们将一个很大的元素加入 $\\textit{large}$ 中，并且 $\\textit{large}$ 包含的元素数量超过了 $\\textit{small}$，那么我们就需要将 $\\textit{large}$ 的堆顶元素放入 $\\textit{small}$ 中。这样一来，$\\textit{large}$ 的堆顶元素就变成了那个需要被删除的第二小的元素了，所以 $\\texttt{prune(heap)}$ 操作是必要的。\n\n- 不可能会出现这种情况，假设出现了这种情况，那么 $\\textit{num}$ 显然不会等于 $\\textit{large}$ 原先的堆顶元素，因为 $\\textit{large}$ 原先的堆顶元素一定是不需要被删除的。那么 $\\textit{num}$ 满足：\n\n    $$\n    \\textit{small} ~的堆顶元素 < \\textit{num} < \\textit{large} ~的堆顶元素\n    $$\n\n    由于 $\\textit{small}$ 是大根堆，$\\textit{large}$ 是小根堆，因此**根本就不存在与 $\\textit{num}$ 值相同的元素**，也就不可能会被延迟删除了。",
      "createdAt": "2021-02-02T14:52:50.641966+00:00",
      "hitCount": 40446,
      "identifier": "uQLEfX",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "itcharge-480-hua-dong-chuang-kou-zhong-w-vigs",
        "title": "「ITCharge」480. 滑动窗口中位数「滑动窗口」「堆」"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "sliding-window-median"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 70,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 7,
          "reactionType": "CONFUSED"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 4,
          "reactionType": "AWESOME"
        }
      ],
      "rewardEnabled": null,
      "slug": "hua-dong-chuang-kou-zhong-wei-shu-by-lee-7ai6",
      "status": "PREPUBLISH",
      "summary": "前言 本题是「295. 数据流的中位数」的进阶版本。 我们首先思考一下完成本题需要做哪些事情： 初始时，我们需要将数组 $\\textit{nums}$ 中的前 $k$ 个元素放入一个滑动窗口，并且求出它们的中位数； 随后滑动窗口会向右进行移动。每一次移动后，会将一个新的元素放入滑动窗口，并且将一个旧的元素移出滑动窗口，",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Hash Table",
          "nameTranslated": "哈希表",
          "slug": "hash-table",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C",
          "nameTranslated": "",
          "slug": "c",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Go",
          "nameTranslated": "",
          "slug": "golang",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python",
          "nameTranslated": "",
          "slug": "python",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "滑动窗口中位数",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 260,
        "id": 588643,
        "viewCount": 26926
      },
      "uuid": "uQLEfX",
      "videosInfo": []
    }
  }
}
