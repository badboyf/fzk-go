{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "力扣 (LeetCode)",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2021/03/73c9f099-abbe-4d94-853f-f8abffd459cd/leetcode.png",
          "userSlug": "leetcode"
        },
        "username": "LeetCode"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "#### 概述\n\n我们对字符串 `A` 和 `B` 构造一个包含 `6` 个节点 `a`, `b`, `c`, `d`, `e`, `f` 的基础图。对于字符串中的第 `i` 位 `A[i]` 和 `B[i]`，我们在基础图中连一条 `A[i] -> B[i]` 的有向边，允许重边和自环。如果字符串 `A` 和 `B` 相等，那么基础图中就只有自环。\n\n我们来考虑交换 `A[i]` 和 `A[j]` 会导致图如何变化。例如当 `A` 为 `ca...`，`B` 为 `ab...` 时，基础图中有边 `c -> a` 和 `a -> b`。如果我们交换 `A[0]` 和 `A[1]`，那么图中会剩下边 `c -> b` 和 `a` 的自环。我们把这种“把两条首尾相连的边变成一条新边和一个自环”的操作称为“截断”。可以证明，最优的操作中，所有的操作都是截断操作（证明的方法大致为：首先在任意时刻，图中必须有两条首尾相连的边存在；其次我们的目标是把所有的边变成自环，那么除了 `a -> b` 和 `b -> a` 这种情况之外，其它所有的一次操作最多只能使得图中多出一个自环，因此截断操作是最优的）。\n\n最后我们考虑将基础图拆分为若干个环，拆分的方法并不是唯一的。对于一个长度为 `k` 的环，我们可以用 `k - 1` 次截断操作，把环上所有的边变为自环。因此，如果基础图被拆分为长度为 $C_1, \\cdots, C_k$ 的 `k` 个环，需要的截断操作次数为 $\\sum_k (C_k - 1)$，这个求和也等于基础图中非自环的边数 `n0` 减去环的个数 `k`。因此，我们的目标对基础图进行一个环数最多的拆分。\n\n#### 方法一：动态规划\n\n我们用 $P_1, P_2, \\cdots$ 表示在基础图 $G$ 上所有可能的环，那么 $G$ 可以表示为 $\\sum k_i P_i$，其中 $k_i$ 为常数，表示 $P_i$ 出现（被拆分得到）的次数，环的总数为 $\\sum k_i$。\n\n对于一个环 $P_i$，我们可以用一个 `01` 数组表示每条边是否出现，例如对于环 `a -> b -> d -> e -> a`，它有 `4` 条边 `a -> b`，`b -> d`，`d -> e` 和 `e -> a`，那么它对应的数组中，有 `4` 个位置（这 `4` 条边对应的位置）的值为 `1`，其它值为 `0`。同样地，基础图 $G$ 也可以用这种方式来表示。\n\n因此我们可以使用动态规划来解决这个问题，令 `numCycles(G)` 表示基础图 $G$ 最多拆分的环的数目。我们枚举环 $C$，检查 $C$ 是否包含于 $G$。状态转移方程为 `numCycles(G) = max{1 + numcycles(G - C)}`。\n\n```Java [sol1]\nclass Solution {\n    String[] alphabet = new String[]{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\n    Map<String, Integer> memo;\n\n    public int kSimilarity(String A, String B) {\n        if (A.equals(B)) return 0;\n        int N = A.length();\n        memo = new HashMap();\n        int ans = 0;\n\n        int[] count = new int[alphabet.length * alphabet.length];\n        for (int i = 0; i < N; ++i)\n            if (A.charAt(i) != B.charAt(i)) {\n                count[alphabet.length * (A.charAt(i) - 'a') + (B.charAt(i) - 'a')]++;\n                ans++;\n            }\n\n        List<int[]> possibles = new ArrayList();\n        // Enumerate over every cycle\n        for (int size = 2; size <= alphabet.length; ++size)\n            search: for (String cycle: permutations(alphabet, 0, size)) {\n                // Check if cycle is canonical\n                for (int i = 1; i < size; ++i)\n                    if (cycle.charAt(i) < cycle.charAt(0))\n                        continue search;\n\n                // Add count to possibles\n                int[] row = new int[count.length];\n                for (int i = 0; i < size; ++i) {\n                    int u = cycle.charAt(i) - 'a';\n                    int v = cycle.charAt((i+1) % size) - 'a';\n                    row[alphabet.length * u + v]++;\n                }\n                possibles.add(row);\n            }\n\n        int[] ZERO = new int[count.length];\n        memo.put(Arrays.toString(ZERO), 0);\n        return ans - numCycles(possibles, count);\n    }\n\n    public int numCycles(List<int[]> possibles, int[] count) {\n        String countS = Arrays.toString(count);\n        if (memo.containsKey(countS)) return memo.get(countS);\n\n        int ans = Integer.MIN_VALUE;\n        search: for (int[] row: possibles) {\n            int[] count2 = count.clone();\n            for (int i = 0; i < row.length; ++i) {\n                if (count2[i] >= row[i])\n                    count2[i] -= row[i];\n                else\n                    continue search;\n            }\n            ans = Math.max(ans, 1 + numCycles(possibles, count2));\n        }\n\n        memo.put(countS, ans);\n        return ans;\n    }\n\n    public List<String> permutations(String[] alphabet, int used, int size) {\n        List<String> ans = new ArrayList();\n        if (size == 0) {\n            ans.add(new String(\"\"));\n            return ans;\n        }\n\n        for (int b = 0; b < alphabet.length; ++b)\n            if (((used >> b) & 1) == 0)\n                for (String rest: permutations(alphabet, used | (1 << b), size - 1))\n                    ans.add(alphabet[b] + rest);\n        return ans;\n    }\n}\n```\n\n```Python [sol1]\nclass Solution(object):\n    def kSimilarity(self, A, B):\n        if A == B: return 0\n\n        N = len(A)\n        alphabet = 'abcdef'\n        pairs = [(a, b) for a in alphabet for b in alphabet if a != b]\n        index = {p: i for i, p in enumerate(pairs)}\n\n        count = [0] * len(index)\n        for a, b in itertools.izip(A, B):\n            if a != b:\n                count[index[a, b]] += 1\n\n        seen = set()\n        for size in xrange(2, len(alphabet) + 1):\n            for cand in itertools.permutations(alphabet, size):\n                i = cand.index(min(cand))\n                seen.add(cand[i:] + cand[:i])\n\n        possibles = []\n        for cand in seen:\n            row = [0] * len(alphabet) * (len(alphabet) - 1)\n            for a, b in itertools.izip(cand, cand[1:] + cand[:1]):\n                row[index[a, b]] += 1\n            possibles.append(row)\n\n        ZERO = tuple([0] * len(row))\n        memo = {ZERO: 0}\n        def solve(count):\n            if count in memo: return memo[count]\n\n            ans = float('-inf')\n            for row in possibles:\n                count2 = list(count)\n                for i, x in enumerate(row):\n                    if count2[i] >= x:\n                        count2[i] -= x\n                    else: break\n                else:\n                    ans = max(ans, 1 + solve(tuple(count2)))\n\n            memo[count] = ans\n            return ans\n\n        return sum(count) - solve(tuple(count))\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(2^{N+W})$，其中 $N$ 是字符串的长度，$W$ 是字母的数量。\n\n* 空间复杂度：$O(2^{N+W})$。\n\n#### 方法二：广度优先搜索\n\n当我们把基础图 `G` 拆分为环并进行截断操作时，我们可以每次截断从左到右第一个 `A[i] != B[i]` 对应的那条边。即在字符串 `A` 和 `B` 中，我们每次找到最左侧满足 `A[i] != B[i]` 的 `i`，并搜索满足 `j > i` 且 `A[j] == B[i]` 的 `j`。\n\n通过这种做法，我们可以使用广度优先搜索遍历所有的状态。可以大致估计出，状态的数量为 $\\sum_k \\binom{N}{k} 2^k = 3^N$，如果考虑重复的字符，还需要将状态数除以 $\\prod (N_i)!$，其中 $N_i$ 表示 `A[i]` 在整个字符串中出现的次数。当 $N \\leq 20$ 时，状态数量可以进行广度优先搜索。\n\n```Java [sol2]\nclass Solution {\n    public int kSimilarity(String A, String B) {\n        Queue<String> queue = new ArrayDeque();\n        queue.offer(A);\n\n        Map<String, Integer> dist = new HashMap();\n        dist.put(A, 0);\n\n        while (!queue.isEmpty()) {\n            String S = queue.poll();\n            if (S.equals(B)) return dist.get(S);\n            for (String T: neighbors(S, B)) {\n                if (!dist.containsKey(T)) {\n                    dist.put(T, dist.get(S) + 1);\n                    queue.offer(T);\n                }\n            }\n        }\n\n        throw null;\n    }\n\n    public List<String> neighbors(String S, String target) {\n        List<String> ans = new ArrayList();\n        int i = 0;\n        for (; i < S.length(); ++i) {\n            if (S.charAt(i) != target.charAt(i)) break;\n        }\n\n        char[] T = S.toCharArray();\n        for (int j = i+1; j < S.length(); ++j)\n            if (S.charAt(j) == target.charAt(i)) {\n                swap(T, i, j);\n                ans.add(new String(T));\n                swap(T, i, j);\n            }\n\n        return ans;\n    }\n\n    public void swap(char[] T, int i, int j) {\n        char tmp = T[i];\n        T[i] = T[j];\n        T[j] = tmp;\n    }\n}\n```\n\n```Python [sol2]\nclass Solution(object):\n    def kSimilarity(self, A, B):\n        def neighbors(S):\n            for i, c in enumerate(S):\n                if c != B[i]:\n                    break\n\n            T = list(S)\n            for j in xrange(i+1, len(S)):\n                if S[j] == B[i]:\n                    T[i], T[j] = T[j], T[i]\n                    yield \"\".join(T)\n                    T[j], T[i] = T[i], T[j]\n\n        queue = collections.deque([A])\n        seen = {A: 0}\n        while queue:\n            S = queue.popleft()\n            if S == B: return seen[S]\n            for T in neighbors(S):\n                if T not in seen:\n                    seen[T] = seen[S] + 1\n                    queue.append(T)\n```\n\n**复杂度分析**\n\n* 时间复杂度：$O(\\sum_{k=0}^n \\binom{N}{k} \\frac{\\min(2^k, (N-k)!)}{W * (\\frac{N-k}{W})!})$，其中 $N$ 是字符串的长度，$W$ 是字母的数量。\n\n* 空间复杂度：$O(N * t)$，其中 $t$ 为时间复杂度。",
      "createdAt": "2019-08-12T17:08:23.670490+00:00",
      "hitCount": 9337,
      "identifier": "7kTn6x",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "ji-yi-hua-sou-suo-by-xiaowufeixia-rni1",
        "title": "记忆化搜索"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "k-similar-strings"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 17,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 1,
          "reactionType": "AWESOME"
        }
      ],
      "rewardEnabled": null,
      "slug": "xiang-si-du-wei-k-de-zi-fu-chuan-by-leetcode",
      "status": "PUBLISHED",
      "summary": "§ 概述\n我们对字符串 A 和 B 构造一个包含 6 个节点 a, b, c, d, e, f 的基础图。对于字符串中的第 i 位 A[i] 和 B[i]，我们在基础图中连一条 A[i] -> B[i] 的有向边，允许重边和自环。如果字符串 A 和 B 相等，那么基础图中就只有自环。\n我们来考虑交换 A[i] 和 A[",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Breadth-First Search",
          "nameTranslated": "广度优先搜索",
          "slug": "breadth-first-search",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Design",
          "nameTranslated": "设计",
          "slug": "design",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Dynamic Programming",
          "nameTranslated": "动态规划",
          "slug": "dynamic-programming",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python",
          "nameTranslated": "",
          "slug": "python",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "相似度为 K 的字符串",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 15,
        "id": 20106,
        "viewCount": 6623
      },
      "uuid": "7kTn6x",
      "videosInfo": []
    }
  }
}
