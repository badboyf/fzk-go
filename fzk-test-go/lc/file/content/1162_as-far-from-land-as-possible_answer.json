{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "åŠ›æ‰£å®˜æ–¹é¢˜è§£",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/leetcode-solution/avatar_1582018938.png",
          "userSlug": "leetcode-solution"
        },
        "username": "LeetCode-Solution"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "#### é¢˜ç›®åˆ†æ\n\nã€Œç¦»é™†åœ°åŒºåŸŸæœ€è¿œã€è¦æ±‚æµ·æ´‹åŒºåŸŸè·ç¦»å®ƒæœ€è¿‘çš„é™†åœ°åŒºåŸŸçš„æ›¼å“ˆé¡¿è·ç¦»æ˜¯æœ€å¤§çš„ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦æ‰¾ä¸€ä¸ªæµ·æ´‹åŒºåŸŸï¼Œæ»¡è¶³å®ƒåˆ°é™†åœ°çš„æœ€å°è·ç¦»æ˜¯æœ€å¤§çš„ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢\n\n**æ€è·¯**\n\nè€ƒè™‘æœ€æœ´ç´ çš„æ–¹æ³•ï¼Œå³æ±‚å‡ºæ¯ä¸€ä¸ªæµ·æ´‹åŒºåŸŸï¼ˆ`grid[i][j] == 0` çš„åŒºåŸŸï¼‰çš„ã€Œæœ€è¿‘é™†åœ°åŒºåŸŸã€ï¼Œç„¶åè®°å½•ä¸‹å®ƒä»¬çš„è·ç¦»ï¼Œç„¶ååœ¨è¿™äº›è·ç¦»é‡Œé¢å–ä¸€ä¸ªæœ€å¤§å€¼ã€‚\n\n![fig1](https://assets.leetcode-cn.com/solution-static/1162_fig1.gif)\n\nå¯¹äºä¸€ä¸ªç»™å®šçš„åŒºåŸŸ $(x, y)$ ï¼Œæ±‚å®ƒçš„ã€Œæœ€è¿‘é™†åœ°åŒºåŸŸã€ï¼Œå¯ä»¥ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢æ€æƒ³ã€‚æˆ‘ä»¬æŠŠæ¯ä¸ªåŒºåŸŸçš„åæ ‡ä½œä»¥åŠè¿™ä¸ªåŒºåŸŸä¸ $(x, y)$ çš„æ›¼å“ˆé¡¿è·ç¦»ä¸ºæœç´¢çŠ¶æ€ï¼Œå³ `Coordinate` ç»“æ„ä½“çš„ `x`ã€`y` å’Œ `step` å±æ€§ã€‚`findNearestLand` æ–¹æ³•å®ç°äº†å¹¿åº¦ä¼˜å…ˆæœç´¢çš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ª `vis[u][v]` æ•°ç»„è®°å½• $(u, v)$ åŒºåŸŸæ˜¯å¦è¢«è®¿é—®è¿‡ï¼Œåœ¨æ‹“å±•æ–°çŠ¶æ€çš„æ—¶å€™æŒ‰ç…§å¦‚ä¸‹å››ä¸ªæ–¹å‘ï¼š\n\n+ $(x - 1, y)$\n+ $(x, y + 1)$\n+ $(x + 1, y)$\n+ $(x, y - 1)$\n\nåœ¨è¿™é‡Œæˆ‘ä»¬å¯ä»¥æŠŠå››ä¸ªæ–¹å‘å®šä¹‰ä¸ºå¸¸é‡å¢é‡æ•°ç»„ `dx` å’Œ `dy`ã€‚\n\n**æ€è€ƒï¼šæˆ‘ä»¬éœ€ä¸éœ€è¦æœç´¢åˆ°é˜Ÿåˆ—ä¸ºç©ºæ‰åœæ­¢ BFS ï¼Ÿ** ç­”æ¡ˆæ˜¯ä¸éœ€è¦ã€‚å½“æˆ‘ä»¬æœç´¢åˆ°ä¸€ä¸ªæ–°å…¥é˜Ÿçš„åŒºåŸŸå®ƒçš„ `grid` å€¼ä¸º `1`ï¼Œå³è¿™ä¸ªåŒºåŸŸæ˜¯é™†åœ°åŒºåŸŸçš„æ—¶å€™æˆ‘ä»¬å°±å¯ä»¥åœæ­¢æœç´¢ï¼Œå› ä¸º BFS èƒ½ä¿è¯å½“å‰çš„è¿™ä¸ªåŒºåŸŸæ˜¯æœ€è¿‘çš„é™†åœ°åŒºåŸŸï¼ˆBFS çš„æ€§è´¨å†³å®šäº†è¿™é‡Œæ±‚å‡ºæ¥çš„ä¸€å®šæ˜¯æœ€çŸ­è·¯ï¼‰ã€‚\n\n`findNearestLand`å¦‚æœæˆ‘ä»¬æ‰¾ä¸ä¸åˆ°ä»»ä½•ä¸€ä¸ªç‚¹æ˜¯é™†åœ°åŒºåŸŸåˆ™è¿”å› `-1`ã€‚æœ€ç»ˆæˆ‘ä»¬æŠŠ `ans` çš„åˆå§‹å€¼ç½®ä¸º `-1`ï¼Œç„¶åä¸æ‰€æœ‰çš„ BFS ç»“æœå–æœ€å¤§ã€‚\n\nä»£ç å®ç°å¦‚ä¸‹ã€‚\n\n**ä»£ç å®ç°**\n\n```C++ [sol1-C++]\nclass Solution {\npublic:\n    static constexpr int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n    static constexpr int MAX_N = 100 + 5;\n\n    struct Coordinate {\n        int x, y, step;\n    };\n\n    int n, m;\n    vector<vector<int>> a;\n\n    bool vis[MAX_N][MAX_N];\n\n    int findNearestLand(int x, int y) {\n        memset(vis, 0, sizeof vis);\n        queue <Coordinate> q;\n        q.push({x, y, 0});\n        vis[x][y] = 1;\n        while (!q.empty()) {\n            auto f = q.front(); q.pop();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f.x + dx[i], ny = f.y + dy[i];\n                if (!(nx >= 0 && nx <= n - 1 && ny >= 0 && ny <= m - 1)) {\n                    continue;\n                }\n                if (!vis[nx][ny]) {\n                    q.push({nx, ny, f.step + 1});\n                    vis[nx][ny] = 1;\n                    if (a[nx][ny]) {\n                        return f.step + 1;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n    \n    int maxDistance(vector<vector<int>>& grid) {\n        this->n = grid.size();\n        this->m = grid.at(0).size();\n        a = grid;\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!a[i][j]) {\n                    ans = max(ans, findNearestLand(i, j));\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, 1, 0, -1};\n    int n;\n    int[][] grid;\n\n    public int maxDistance(int[][] grid) {\n        this.n = grid.length;\n        this.grid = grid;\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 0) {\n                    ans = Math.max(ans, findNearestLand(i, j));\n                }\n            }\n        }\n        return ans;\n    }\n\n    public int findNearestLand(int x, int y) {\n        boolean[][] vis = new boolean[n][n];\n        Queue<int[]> queue = new LinkedList<int[]>();\n        queue.offer(new int[]{x, y, 0});\n        vis[x][y] = true;\n        while (!queue.isEmpty()) {\n            int[] f = queue.poll();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f[0] + dx[i], ny = f[1] + dy[i];\n                if (!(nx >= 0 && nx < n && ny >= 0 && ny < n)) {\n                    continue;\n                }\n                if (!vis[nx][ny]) {\n                    queue.offer(new int[]{nx, ny, f[2] + 1});\n                    vis[nx][ny] = true;\n                    if (grid[nx][ny] == 1) {\n                        return f[2] + 1;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šè¯¥ç®—æ³•æœ€å¤šæ‰§è¡Œ $n^2$ æ¬¡ BFSï¼Œå³æˆ‘ä»¬è€ƒè™‘æœ€åæƒ…å†µæ‰€æœ‰çš„åŒºåŸŸéƒ½æ˜¯æµ·æ´‹ï¼Œé‚£ä¹ˆæ¯ä¸€ä¸ªåŒºåŸŸéƒ½ä¼šè¿›è¡Œ BFSã€‚å¯¹äºæ¯ä¸€æ¬¡ BFSï¼Œæœ€åçš„æƒ…å†µæ˜¯æ‰¾ä¸åˆ°é™†åœ°åŒºåŸŸï¼Œæˆ‘ä»¬åªèƒ½éå†å®Œå‰©ä¸‹çš„ $n^2 - 1$ ä¸ªæµ·æ´‹åŒºåŸŸï¼Œç”±äº `vis` æ•°ç»„ç¡®ä¿æ¯ä¸ªåŒºåŸŸåªè¢«è®¿é—®ä¸€æ¬¡ï¼Œæ‰€ä»¥å•æ¬¡ BFS çš„æ¸è¿›æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^2)$ï¼Œç¨‹åºçš„æ€»çš„æ¸è¿›æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^4)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼šè¯¥ç®—æ³•ä½¿ç”¨äº† `vis` æ•°ç»„ï¼Œæ¸è¿›ç©ºé—´å¤æ‚åº¦ä¸º $O(n^2)$ã€‚\n\n\n#### æ–¹æ³•äºŒï¼šå¤šæºæœ€çŸ­è·¯\n\n**æ€è·¯**\n\nå…¶å®åœ¨æ–¹æ³•ä¸€ä¸­æˆ‘ä»¬å·²ç»å‘ç°æˆ‘ä»¬ BFS çš„è¿‡ç¨‹æ˜¯æ±‚æœ€çŸ­è·¯çš„è¿‡ç¨‹ï¼Œä½†æ˜¯è¿™é‡Œä¸æ˜¯æ±‚æŸä¸€ä¸ªæµ·æ´‹åŒºåŸŸåˆ°é™†åœ°åŒºåŸŸçš„æœ€çŸ­è·¯ï¼Œè€Œæ˜¯æ±‚æ‰€æœ‰çš„æµ·æ´‹åŒºåŸŸåˆ°é™†åœ°åŒºåŸŸè¿™ä¸ªã€Œç‚¹é›†ã€çš„æœ€çŸ­è·¯ã€‚æ˜¾ç„¶è¿™ä¸æ˜¯ä¸€ä¸ªã€Œå•æºã€æœ€çŸ­è·¯é—®é¢˜ï¼ˆSSSPï¼‰ã€‚åœ¨æˆ‘ä»¬å­¦ä¹ è¿‡çš„æœ€çŸ­è·¯ç®—æ³•ä¸­ï¼Œæ±‚è§£ SSSP é—®é¢˜çš„æ–¹æ³•æœ‰ Dijkstra ç®—æ³•å’Œ SPFAç®—æ³•ï¼Œè€Œæ±‚è§£ä»»æ„ä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯ä¸€èˆ¬ä½¿ç”¨ Floyd ç®—æ³•ã€‚é‚£æˆ‘ä»¬åœ¨è¿™é‡Œå°±åº”è¯¥ä½¿ç”¨ Floyd ç®—æ³•å—ï¼Ÿè¦è€ƒè™‘è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦åˆ†æä¸€ä¸‹è¿™é‡Œä½¿ç”¨ Floyd ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ã€‚æˆ‘ä»¬çŸ¥é“åœ¨ç½‘æ ¼å›¾ä¸­æ±‚æœ€çŸ­è·¯ï¼Œæ¯ä¸ªåŒºåŸŸï¼ˆæ ¼å­ï¼‰ç›¸å½“äºå›¾ä¸­çš„é¡¶ç‚¹ï¼Œè€Œæ¯ä¸ªæ ¼å­å’Œä¸Šä¸‹å·¦å³å››ä¸ªæ ¼å­çš„ç›¸é‚»å…³ç³»ç›¸å½“äºè¾¹ï¼Œæˆ‘ä»¬è®°é¡¶ç‚¹çš„ä¸ªæ•°ä¸º $V$ï¼ŒFloyd ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(V^3)$ï¼Œè€Œè¿™é‡Œ $V = n^2$ï¼Œæ‰€ä»¥ $O(V^3) = O(n^6)$ï¼Œæ˜¾ç„¶æ˜¯ä¸ç°å®çš„ã€‚\n\nè€ƒè™‘ SSSP æ˜¯æ±‚ä¸€ä¸ªæºç‚¹åˆ°ä¸€ä¸ªç‚¹é›†ä¸­æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯ï¼Œè€Œè¿™ä¸ªé—®é¢˜çš„æœ¬è´¨æ˜¯æ±‚æŸä¸ªç‚¹é›†åˆ°å¦ä¸€ä¸ªç‚¹é›†ä¸­æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯ï¼Œå³ã€Œå¤šæºæœ€çŸ­è·¯ã€ï¼Œæˆ‘ä»¬åªéœ€è¦å¯¹ Dijkstra ç®—æ³•æˆ–è€… SPFA ç®—æ³•ç¨ä½œä¿®æ”¹ã€‚è¿™é‡Œä»¥ Dijkstra ç®—æ³•ä¸ºä¾‹ï¼Œæˆ‘ä»¬çŸ¥é“å †ä¼˜åŒ–çš„ Dijkstra ç®—æ³•å®é™…ä¸Šæ˜¯ BFS çš„ä¸€ä¸ªå˜å½¢ï¼ŒæŠŠ BFS ä¸­çš„é˜Ÿåˆ—å˜æˆäº†ä¼˜å…ˆé˜Ÿåˆ—ï¼Œåœ¨æ‹“å±•æ–°çŠ¶æ€çš„æ—¶å€™åŠ å…¥äº†æ¾å¼›æ“ä½œã€‚Dijkstra çš„å †ä¼˜åŒ–ç‰ˆæœ¬ç¬¬ä¸€æ­¥æ˜¯æºç‚¹å…¥é˜Ÿï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠå®ƒæ”¹æˆæºç‚¹é›†åˆä¸­çš„æ‰€æœ‰çš„ç‚¹å…¥é˜Ÿå°±å¯ä»¥å®ç°æ±‚ã€Œå¤šæºæœ€çŸ­è·¯ã€ã€‚\n\n**æ€è€ƒï¼šä¸ºä»€ä¹ˆï¼Ÿ** å› ä¸ºæˆ‘ä»¬è¿™æ ·åšç›¸å½“äºå»ºç«‹äº†ä¸€ä¸ªè¶…çº§æºç‚¹ $S$ï¼Œè¿™ä¸ªç‚¹ä¸æºç‚¹é›†ä¸­çš„ $s_0, s_1, s_2 \\cdots s_{|V|}$ éƒ½æœ‰è¾¹ï¼Œå¹¶ä¸”æƒéƒ½ä¸º 0ã€‚è¿™æ ·æ±‚æºç‚¹é›†åˆ°ç›®æ ‡ç‚¹é›†çš„æœ€çŸ­è·¯å°±å˜æˆäº†æ±‚è¶…çº§æºç‚¹ $S$ åˆ°å®ƒä»¬çš„æœ€çŸ­è·¯ï¼Œäºæ˜¯åˆè½¬åŒ–æˆäº† SSSP é—®é¢˜ã€‚\n\n![fig2](https://assets.leetcode-cn.com/solution-static/1162_fig2.png)\n\n**æ€è€ƒï¼šæµ·æ´‹åŒºåŸŸå’Œé™†åœ°åŒºåŸŸï¼Œåº”è¯¥å“ªä¸€ä¸ªä½œä¸ºæºç‚¹é›†ï¼Ÿ** ä¹Ÿè®¸ä½ åˆ†æå‡ºã€Œæˆ‘ä»¬éœ€è¦æ‰¾ä¸€ä¸ªæµ·æ´‹åŒºåŸŸï¼Œæ»¡è¶³å®ƒåˆ°é™†åœ°çš„æœ€å°è·ç¦»æ˜¯æœ€å¤§ã€ä¼šæŠŠæµ·æ´‹åŒºåŸŸä½œä¸ºæºç‚¹é›†ã€‚æˆ‘ä»¬å¯ä»¥è€ƒè™‘åç»­çš„å®ç°ï¼Œæˆ‘ä»¬çŸ¥é“ Dijkstra ä¸­ä¸€ä¸ª `d` æ•°ç»„ç”¨æ¥ç»´æŠ¤å½“å‰æºç‚¹é›†åˆ°å…¶ä»–ç‚¹çš„æœ€çŸ­è·¯ï¼Œè€Œå¯¹äºæºç‚¹é›†ä¸­çš„ä»»æ„ä¸€ä¸ªç‚¹ $s$ï¼Œ`d[s_x][s_y] = 0`ï¼Œè¿™å¾ˆå¥½ç†è§£ï¼Œæºç‚¹åˆ°æºç‚¹çš„æœ€çŸ­è·¯å°±æ˜¯ 0ã€‚å¦‚æœæˆ‘ä»¬æŠŠæµ·æ´‹åŒºåŸŸä½œä¸ºæºç‚¹é›†ã€é™†åœ°åŒºåŸŸä½œä¸ºç›®æ ‡ç‚¹é›†ï¼Œå‡è®¾ $t$ æ˜¯ç›®æ ‡ç‚¹é›†ä¸­çš„ä¸€ä¸ªç‚¹ï¼Œç®—æ³•æ‰§è¡Œç»“æŸå `d[t_x][t_y]` å°±æ˜¯æµ·æ´‹åŒºåŸŸä¸­çš„ç‚¹åˆ° $t$ çš„æœ€çŸ­è·ç¦»ï¼Œä½†æ˜¯æˆ‘ä»¬å´ä¸çŸ¥é“å“ªäº› $t$ æ˜¯æµ·æ´‹åŒºåŸŸçš„è¿™äº›ç‚¹çš„ã€Œæœ€è¿‘é™†åœ°åŒºåŸŸã€ï¼Œæˆ‘ä»¬ä¹Ÿä¸çŸ¥é“æ¯ä¸ª $s$ è·ç¦»å®ƒçš„ã€Œæœ€è¿‘é™†åœ°åŒºåŸŸã€çš„æ›¼å“ˆé¡¿è·ç¦»ã€‚è€ƒè™‘æˆ‘ä»¬æŠŠé™†åœ°åŒºåŸŸä½œä¸ºæºç‚¹é›†ã€æµ·æ´‹åŒºåŸŸä½œä¸ºç›®æ ‡ç‚¹é›†ï¼Œç›®æ ‡ç‚¹é›†ä¸­çš„ç‚¹ $t$ å¯¹åº”çš„ `d[t_x][t_y]` å°±æ˜¯æµ·æ´‹åŒºåŸŸ $t$ å¯¹åº”çš„è·ç¦»å®ƒçš„ã€Œæœ€è¿‘é™†åœ°åŒºåŸŸã€çš„æ›¼å“ˆé¡¿è·ç¦»ï¼Œæ­£æ˜¯æˆ‘ä»¬éœ€è¦çš„ï¼Œæ‰€ä»¥åº”è¯¥æŠŠé™†åœ°åŒºåŸŸä½œä¸ºæºç‚¹é›†ã€‚\n\næœ€ç»ˆæˆ‘ä»¬åªéœ€è¦æ¯”å‡º `d[t_x][t_y]` çš„æœ€å¤§å€¼å³å¯ã€‚Dijkstra ç®—æ³•åœ¨åˆå§‹åŒ– `d` æ•°ç»„çš„æ—¶å€™ï¼ŒæŠŠæ¯ä¸ªå…ƒç´ é¢„ç½®ä¸º `INF`ï¼Œæ‰€ä»¥å¦‚æœå‘ç°æœ€ç»ˆæ¯”å‡ºçš„æœ€å¤§å€¼ä¸º `INF`ï¼Œé‚£ä¹ˆå°±è¿”å› `-1`ã€‚\n\nç”±äºè¿™é‡Œçš„è¾¹æƒä¸º 1ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨å¤šæº BFSï¼Œåœ¨è¿™é‡Œæ¯ä¸ªç‚¹éƒ½åªä¼šè¢«æ¾å¼›ä¸€æ¬¡ã€‚\n\nä»£ç å®ç°å¦‚ä¸‹ã€‚\n\n\n**ä»£ç å®ç°**\n\n+ Dijkstra ç‰ˆ\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    static constexpr int MAX_N = 100 + 5;\n    static constexpr int INF = int(1E6);\n    static constexpr int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n\n    int n;\n    int d[MAX_N][MAX_N];\n\n    struct Status {\n        int v, x, y;\n        bool operator < (const Status &rhs) const {\n            return v > rhs.v;\n        }\n    };\n\n    priority_queue <Status> q;\n\n    int maxDistance(vector<vector<int>>& grid) {\n        this->n = grid.size();\n        auto &a = grid;\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                d[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (a[i][j]) {\n                    d[i][j] = 0;\n                    q.push({0, i, j});\n                }\n            }\n        }\n\n        while (!q.empty()) {\n            auto f = q.top(); q.pop();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f.x + dx[i], ny = f.y + dy[i];\n                if (!(nx >= 0 && nx <= n - 1 && ny >= 0 && ny <= n - 1)) {\n                    continue;\n                }\n                if (f.v + 1 < d[nx][ny]) {\n                    d[nx][ny] = f.v + 1;\n                    q.push({d[nx][ny], nx, ny});\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (!a[i][j]) {\n                    ans = max(ans, d[i][j]);\n                }\n            }\n        }\n\n        return (ans == INF) ? -1 : ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int maxDistance(int[][] grid) {\n        final int INF = 1000000;\n        int[] dx = {-1, 0, 1, 0};\n        int[] dy = {0, 1, 0, -1};\n        int n = grid.length;\n        int[][] d = new int[n][n];\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] status1, int[] status2) {\n                return status1[0] - status2[0];\n            }\n        });\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                d[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    d[i][j] = 0;\n                    queue.offer(new int[]{0, i, j});\n                }\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int[] f = queue.poll();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f[1] + dx[i], ny = f[2] + dy[i];\n                if (!(nx >= 0 && nx < n && ny >= 0 && ny < n)) {\n                    continue;\n                }\n                if (f[0] + 1 < d[nx][ny]) {\n                    d[nx][ny] = f[0] + 1;\n                    queue.offer(new int[]{d[nx][ny], nx, ny});\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 0) {\n                    ans = Math.max(ans, d[i][j]);\n                }\n            }\n        }\n\n        return ans == INF ? -1 : ans;\n    }\n}\n```\n\n+ å¤šæº BFS ç‰ˆ\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    static constexpr int MAX_N = 100 + 5;\n    static constexpr int INF = int(1E6);\n    static constexpr int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n\n    int n;\n    int d[MAX_N][MAX_N];\n\n    struct Coordinate {\n        int x, y;\n    };\n\n    queue <Coordinate> q;\n\n    int maxDistance(vector<vector<int>>& grid) {\n        this->n = grid.size();\n        auto &a = grid;\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                d[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (a[i][j]) {\n                    d[i][j] = 0;\n                    q.push({i, j});\n                }\n            }\n        }\n\n        while (!q.empty()) {\n            auto f = q.front(); q.pop();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f.x + dx[i], ny = f.y + dy[i];\n                if (!(nx >= 0 && nx <= n - 1 && ny >= 0 && ny <= n - 1)) continue;\n                if (d[nx][ny] > d[f.x][f.y] + 1) {\n                    d[nx][ny] = d[f.x][f.y] + 1;\n                    q.push({nx, ny});\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (!a[i][j]) {\n                    ans = max(ans, d[i][j]);\n                }\n            }\n        }\n\n        return (ans == INF) ? -1 : ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int maxDistance(int[][] grid) {\n        final int INF = 1000000;\n        int[] dx = {-1, 0, 1, 0};\n        int[] dy = {0, 1, 0, -1};\n        int n = grid.length;\n        int[][] d = new int[n][n];\n        Queue<int[]> queue = new LinkedList<int[]>();\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                d[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    d[i][j] = 0;\n                    queue.offer(new int[]{i, j});\n                }\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int[] f = queue.poll();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f[0] + dx[i], ny = f[1] + dy[i];\n                if (!(nx >= 0 && nx < n && ny >= 0 && ny < n)) {\n                    continue;\n                }\n                if (d[nx][ny] > d[f[0]][f[1]] + 1) {\n                    d[nx][ny] = d[f[0]][f[1]] + 1;\n                    queue.offer(new int[]{nx, ny});\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 0) {\n                    ans = Math.max(ans, d[i][j]);\n                }\n            }\n        }\n\n        return ans == INF ? -1 : ans;\n    }\n}\n```\n\n+ SPFA ç‰ˆ\n\n```C++ [sol2-C++]\nclass Solution {\npublic:\n    static constexpr int MAX_N = 100 + 5;\n    static constexpr int INF = int(1E6);\n    static constexpr int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n\n    int n;\n    int d[MAX_N][MAX_N];\n\n    struct Coordinate {\n        int x, y;\n    };\n\n    queue <Coordinate> q;\n    bool inq[MAX_N][MAX_N];\n\n    int maxDistance(vector<vector<int>>& grid) {\n        this->n = grid.size();\n        auto &a = grid;\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                d[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (a[i][j]) {\n                    d[i][j] = 0;\n                    q.push({i, j});\n                    inq[i][j] = 1;\n                }\n            }\n        }\n\n        while (!q.empty()) {\n            auto f = q.front(); q.pop(); inq[f.x][f.y] = 0;\n            for (int i = 0; i < 4; ++i) {\n                int nx = f.x + dx[i], ny = f.y + dy[i];\n                if (!(nx >= 0 && nx <= n - 1 && ny >= 0 && ny <= n - 1)) {\n                    continue;\n                }\n                if (d[nx][ny] > d[f.x][f.y] + 1) {\n                    d[nx][ny] = d[f.x][f.y] + 1;\n                    if (!inq[nx][ny]) {\n                        q.push({nx, ny});\n                        inq[nx][ny] = 1;\n                    }\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (!a[i][j]) {\n                    ans = max(ans, d[i][j]);\n                }\n            }\n        }\n\n        return (ans == INF) ? -1 : ans;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    public int maxDistance(int[][] grid) {\n        final int INF = 1000000;\n        int[] dx = {-1, 0, 1, 0};\n        int[] dy = {0, 1, 0, -1};\n        int n = grid.length;\n        int[][] d = new int[n][n];\n        Queue<int[]> queue = new LinkedList<int[]>();\n        boolean[][] inq = new boolean[n][n];\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                d[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    d[i][j] = 0;\n                    queue.offer(new int[]{i, j});\n                    inq[i][j] = true;\n                }\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int[] f = queue.poll();\n            inq[f[0]][f[1]] = false;\n            for (int i = 0; i < 4; ++i) {\n                int nx = f[0] + dx[i], ny = f[1] + dy[i];\n                if (!(nx >= 0 && nx < n && ny >= 0 && ny < n)) {\n                    continue;\n                }\n                if (d[nx][ny] > d[f[0]][f[1]] + 1) {\n                    d[nx][ny] = d[f[0]][f[1]] + 1;\n                    if (!inq[nx][ny]) {\n                        queue.offer(new int[]{nx, ny});\n                        inq[nx][ny] = true;\n                    }\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 0) {\n                    ans = Math.max(ans, d[i][j]);\n                }\n            }\n        }\n\n        return ans == INF ? -1 : ans;\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šè€ƒè™‘è¿™é‡Œçš„ã€Œå¤šæºæœ€çŸ­è·¯ã€çš„æœ¬è´¨è¿˜æ˜¯ã€Œå•æºæœ€çŸ­è·¯ã€ï¼Œå› æ­¤å°±æ˜¯ Dijkstra ç®—æ³•å †ä¼˜åŒ–ç‰ˆæœ¬çš„æ¸è¿›æ—¶é—´å¤æ‚åº¦ $O(E \\log V)$ï¼Œè¿™é‡Œ $E$ ä¸ºè¾¹çš„ä¸ªæ•°ï¼Œçº¦ç­‰äº $\\frac{4n^2}{2}$ï¼Œ$V$ ä¸ºé¡¶ç‚¹ä¸ªæ•°ï¼Œçº¦ç­‰äº $n^2$ï¼Œæ‰€ä»¥è¿™é‡Œçš„æ¸è¿›æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2 \\log n^2) = O(n^2 \\log n)$ï¼›åœ¨å¤šæº BFS å½“ä¸­ï¼Œç”±äºæ¯ä¸ªç‚¹åªèƒ½è¢«è®¿é—®ä¸€æ¬¡ï¼Œæ¸è¿›æ—¶é—´å¤æ‚åº¦ä¸º $O(V+E) = O(n^2)$ï¼›SPFA ç®—æ³•çš„ç†è®ºæ¸è¿›ä¸Šç•Œæ˜¯ $O(VE) = O(n^2)$ï¼Œä½†æ˜¯ç”±äºè¿™é‡Œçš„è¾¹æƒéƒ½ä¸º 1ï¼Œäºæ˜¯å®ƒé€€åŒ–æˆäº† BFSï¼Œæ¸è¿›æ—¶é—´å¤æ‚åº¦ $O(n^2)$ã€‚\n- ç©ºé—´å¤æ‚åº¦ï¼šè¯¥ç®—æ³•ä½¿ç”¨äº† `d` æ•°ç»„ï¼Œæ¸è¿›ç©ºé—´å¤æ‚åº¦ä¸º $O(n^2)$ã€‚\n\n#### æ–¹æ³•ä¸‰ï¼šåŠ¨æ€è§„åˆ’\n\n**æ€è·¯**\n\nè€ƒè™‘ä¼˜åŒ–æ–¹æ³•äºŒä¸­çš„ã€ŒæŠŠé™†åœ°åŒºåŸŸä½œä¸ºæºç‚¹é›†ã€æµ·æ´‹åŒºåŸŸä½œä¸ºç›®æ ‡ç‚¹é›†ï¼Œæ±‚æœ€çŸ­è·¯ã€çš„è¿‡ç¨‹ã€‚æˆ‘ä»¬çŸ¥é“å¯¹äºæ¯ä¸ªæµ·æ´‹åŒºåŸŸ $(x, y)$ï¼Œç¦»å®ƒæœ€è¿‘çš„é™†åœ°åŒºåŸŸåˆ°å®ƒçš„è·¯å¾„è¦ä¹ˆä»ä¸Šæ–¹æˆ–è€…å·¦æ–¹æ¥ï¼Œè¦ä¹ˆä»å³æ–¹æˆ–è€…ä¸‹æ–¹æ¥ã€‚è€ƒè™‘åšä¸¤æ¬¡åŠ¨æ€è§„åˆ’ï¼Œç¬¬ä¸€æ¬¡ä»å·¦ä¸Šåˆ°å³ä¸‹ï¼Œç¬¬äºŒæ¬¡ä»å³ä¸‹åˆ°å·¦ä¸Šï¼Œè®° $f(x, y)$ ä¸º $(x, y)$ è·ç¦»æœ€è¿‘çš„é™†åœ°åŒºåŸŸçš„æ›¼å“ˆé¡¿è·ç¦»ï¼Œåˆ™æˆ‘ä»¬å¯ä»¥æ¨å‡ºè¿™æ ·çš„è½¬ç§»æ–¹ç¨‹ï¼š\n\n+ ç¬¬ä¸€é˜¶æ®µ\n\n$$ f(x, y) = \\left \\{ \\begin{aligned} & 0 & , & (x, y) {\\rm \\, is\\, land}  \\\\ & \\min \\{ f(x - 1, y), f(x, y - 1) \\} + 1 & , & (x, y) {\\rm \\, is\\,ocean} \\end{aligned} \\right. $$ \n\n+ ç¬¬äºŒé˜¶æ®µ\n\n$$ f(x, y) = \\left \\{ \\begin{aligned} & 0 & , & (x, y) {\\rm \\, is\\, land}  \\\\ & \\min \\{ f(x + 1, y), f(x, y + 1) \\} + 1 & , & (x, y) {\\rm \\, is\\,ocean} \\end{aligned} \\right. $$ \n\næˆ‘ä»¬åˆå§‹åŒ–çš„æ—¶å€™æŠŠé™†åœ°çš„ `f` å€¼å…¨éƒ¨é¢„ç½®ä¸º `0`ï¼Œæµ·æ´‹çš„ `f` å…¨éƒ¨é¢„ç½®ä¸º `INF`ï¼Œåšå®Œä¸¤ä¸ªé˜¶æ®µçš„åŠ¨æ€è§„åˆ’åï¼Œæˆ‘ä»¬åœ¨æ‰€æœ‰çš„ä¸ä¸ºé›¶çš„ `f[i][j]` ä¸­æ¯”ä¸€ä¸ªæœ€å¤§å€¼å³å¯ï¼Œå¦‚æœæœ€ç»ˆæ¯”è¾ƒå‡ºçš„æœ€å¤§å€¼ä¸º `INF`ï¼Œå°±è¿”å› `-1`ã€‚\n\n**æ€è€ƒï¼šå¦‚æœç”¨ $f(x, y)$ è®°å½•å·¦ä¸Šæ–¹çš„ DP ç»“æœï¼Œ$g(x, y)$ è®°å½•å³ä¸‹æ–¹çš„DPç»“æœå¯è¡Œå—ï¼Ÿ** ç­”æ¡ˆæ˜¯ä¸å¯è¡Œã€‚å› ä¸ºè€ƒè™‘è·ç¦»ç‚¹ $(x, y)$ æœ€è¿‘çš„ç‚¹å¯èƒ½æ—¢ä¸æ¥è‡ªå·¦ä¸Šæ–¹ï¼Œä¹Ÿä¸æ¥è‡ªå³ä¸‹æ–¹ï¼Œæ¯”å¦‚å®ƒæ¥è‡ªå³ä¸Šæ–¹ï¼Œè¿™ä¸ªæ—¶å€™ï¼Œç¬¬äºŒé˜¶æ®µæˆ‘ä»¬å°±éœ€è¦ç”¨åˆ°ç¬¬ä¸€é˜¶æ®µçš„è®¡ç®—ç»“æœã€‚\n\nä»£ç å®ç°å¦‚ä¸‹ã€‚\n\n**ä»£ç å®ç°**\n\n```C++ [sol3-C++]\nclass Solution {\npublic:\n    static constexpr int MAX_N = 100 + 5;\n    static constexpr int INF = int(1E6);\n    \n    int f[MAX_N][MAX_N];\n    int n;\n\n    int maxDistance(vector<vector<int>>& grid) {\n        this->n = grid.size();\n        vector<vector<int>>& a = grid;\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                f[i][j] = (a[i][j] ? 0 : INF);\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (a[i][j]) {\n                    continue;\n                }\n                if (i - 1 >= 0) {\n                    f[i][j] = min(f[i][j], f[i - 1][j] + 1);\n                }\n                if (j - 1 >= 0) {\n                    f[i][j] = min(f[i][j], f[i][j - 1] + 1);\n                }\n            }\n        }\n\n        for (int i = n - 1; i >= 0; --i) {\n            for (int j = n - 1; j >= 0; --j) {\n                if (a[i][j]) {\n                    continue;\n                }\n                if (i + 1 < n) {\n                    f[i][j] = min(f[i][j], f[i + 1][j] + 1);\n                }\n                if (j + 1 < n) {\n                    f[i][j] = min(f[i][j], f[i][j + 1] + 1);\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (!a[i][j]) {\n                    ans = max(ans, f[i][j]);\n                }\n            }\n        }\n\n        if (ans == INF) {\n            return -1;\n        } else {\n            return ans;\n        }\n    }\n};\n```\n\n```Java [sol3-Java]\nclass Solution {\n    public int maxDistance(int[][] grid) {\n        final int INF = 1000000;\n        int n = grid.length;\n        int[][] f = new int[n][n];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                f[i][j] = grid[i][j] == 1 ? 0 : INF;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    continue;\n                }\n                if (i - 1 >= 0) {\n                    f[i][j] = Math.min(f[i][j], f[i - 1][j] + 1);\n                }\n                if (j - 1 >= 0) {\n                    f[i][j] = Math.min(f[i][j], f[i][j - 1] + 1);\n                }\n            }\n        }\n\n        for (int i = n - 1; i >= 0; --i) {\n            for (int j = n - 1; j >= 0; --j) {\n                if (grid[i][j] == 1) {\n                    continue;\n                }\n                if (i + 1 < n) {\n                    f[i][j] = Math.min(f[i][j], f[i + 1][j] + 1);\n                }\n                if (j + 1 < n) {\n                    f[i][j] = Math.min(f[i][j], f[i][j + 1] + 1);\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 0) {\n                    ans = Math.max(ans, f[i][j]);\n                }\n            }\n        }\n\n        if (ans == INF) {\n            return -1;\n        } else {\n            return ans;\n        }\n    }\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼šä»ä»£ç ä¸éš¾çœ‹å‡ºï¼Œè¿™ä¸ªç®—æ³•çš„è¿‡ç¨‹å°±æ˜¯å››ä¸ªåŒé‡ `for` å¾ªç¯ï¼Œæ¸è¿›æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼šè¯¥ç®—æ³•ä½¿ç”¨äº† `f` æ•°ç»„ï¼Œæ¸è¿›ç©ºé—´å¤æ‚åº¦ä¸º $O(n^2)$ã€‚",
      "createdAt": "2020-03-13T05:12:18.630134+00:00",
      "hitCount": 45362,
      "identifier": "3vZS6E",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "jian-dan-java-miao-dong-tu-de-bfs-by-sweetiee",
        "title": "ğŸŒŠç®€å•Java, ç§’æ‡‚å›¾çš„BFSï½"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "as-far-from-land-as-possible"
      },
      "reactionType": null,
      "reactionsV2": [
        {
          "__typename": "ReactionCountNode",
          "count": 76,
          "reactionType": "UPVOTE"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 3,
          "reactionType": "AWESOME"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 1,
          "reactionType": "THUMBS_DOWN"
        },
        {
          "__typename": "ReactionCountNode",
          "count": 0,
          "reactionType": "CONFUSED"
        }
      ],
      "rewardEnabled": null,
      "slug": "di-tu-fen-xi-by-leetcode-solution",
      "status": "PUBLISHED",
      "summary": "é¢˜ç›®åˆ†æ ã€Œç¦»é™†åœ°åŒºåŸŸæœ€è¿œã€è¦æ±‚æµ·æ´‹åŒºåŸŸè·ç¦»å®ƒæœ€è¿‘çš„é™†åœ°åŒºåŸŸçš„æ›¼å“ˆé¡¿è·ç¦»æ˜¯æœ€å¤§çš„ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦æ‰¾ä¸€ä¸ªæµ·æ´‹åŒºåŸŸï¼Œæ»¡è¶³å®ƒåˆ°é™†åœ°çš„æœ€å°è·ç¦»æ˜¯æœ€å¤§çš„ã€‚ æ–¹æ³•ä¸€ï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢ æ€è·¯ è€ƒè™‘æœ€æœ´ç´ çš„æ–¹æ³•ï¼Œå³æ±‚å‡ºæ¯ä¸€ä¸ªæµ·æ´‹åŒºåŸŸï¼ˆgrid[i][j] == 0 çš„åŒºåŸŸï¼‰çš„ã€Œæœ€è¿‘é™†åœ°åŒºåŸŸã€ï¼Œç„¶åè®°å½•ä¸‹å®ƒä»¬çš„è·ç¦»ï¼Œç„¶ååœ¨è¿™äº›è·ç¦»é‡Œé¢å–ä¸€ä¸ªæœ€",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Breadth-First Search",
          "nameTranslated": "å¹¿åº¦ä¼˜å…ˆæœç´¢",
          "slug": "breadth-first-search",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Graph",
          "nameTranslated": "å›¾",
          "slug": "graph",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Dynamic Programming",
          "nameTranslated": "åŠ¨æ€è§„åˆ’",
          "slug": "dynamic-programming",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "åœ°å›¾åˆ†æ",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 80,
        "id": 147423,
        "viewCount": 28523
      },
      "uuid": "3vZS6E",
      "videosInfo": []
    }
  }
}
