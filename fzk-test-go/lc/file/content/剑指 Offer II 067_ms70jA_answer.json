{
  "data": {
    "solutionArticle": {
      "__typename": "SolutionArticleNode",
      "author": {
        "__typename": "UserNode",
        "profile": {
          "__typename": "UserProfileNode",
          "realName": "åŠ›æ‰£å®˜æ–¹é¢˜è§£",
          "userAvatar": "https://assets.leetcode-cn.com/aliyun-lc-upload/users/leetcode-solution/avatar_1582018938.png",
          "userSlug": "leetcode-solution"
        },
        "username": "LeetCode-Solution"
      },
      "byLeetcode": true,
      "canEdit": false,
      "canEditReward": false,
      "canSee": true,
      "chargeType": "FREE",
      "content": "#### å‰è¨€\n\nå‡è®¾æˆ‘ä»¬åœ¨æ•°ç»„ä¸­é€‰æ‹©äº†å…ƒç´  $a_i$ å’Œ $a_j$ï¼ˆ$i \\neq j$ï¼‰ï¼Œä½¿å¾—å®ƒä»¬è¾¾åˆ°æœ€å¤§çš„æŒ‰ä½å¼‚æˆ–è¿ç®—ç»“æœ $x$ï¼š\n\n$$\nx = a_i \\oplus a_j\n$$\n\nå…¶ä¸­ $\\oplus$ è¡¨ç¤ºæŒ‰ä½å¼‚æˆ–è¿ç®—ã€‚è¦æƒ³æ±‚å‡º $x$ï¼Œä¸€ç§ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨äºŒé‡å¾ªç¯æšä¸¾ $i$ å’Œ $j$ï¼Œä½†è¿™æ ·åšçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ï¼Œä¼šè¶…å‡ºæ—¶é—´é™åˆ¶ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦å¯»æ±‚æ—¶é—´å¤æ‚åº¦æ›´ä½çš„åšæ³•ã€‚\n\næ ¹æ®æŒ‰ä½å¼‚æˆ–è¿ç®—çš„æ€§è´¨ï¼Œ$x = a_i \\oplus a_j$ ç­‰ä»·äº $a_j = x \\oplus a_i$ã€‚æˆ‘ä»¬å¯ä»¥æ ¹æ®è¿™ä¸€å˜æ¢ï¼Œè®¾è®¡ä¸€ç§ã€Œä»é«˜ä½åˆ°ä½ä½ä¾æ¬¡ç¡®å®š $x$ äºŒè¿›åˆ¶è¡¨ç¤ºçš„æ¯ä¸€ä½ã€çš„æ–¹æ³•ï¼Œä»¥æ­¤å¾—åˆ° $x$ çš„å€¼ã€‚è¯¥æ–¹æ³•çš„ç²¾é«“åœ¨äºï¼š\n\n- ç”±äºæ•°ç»„ä¸­çš„å…ƒç´ éƒ½åœ¨ $[0, 2^{31})$ çš„èŒƒå›´å†…ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å°†æ¯ä¸€ä¸ªæ•°è¡¨ç¤ºä¸ºä¸€ä¸ªé•¿åº¦ä¸º $31$ ä½çš„äºŒè¿›åˆ¶æ•°ï¼ˆå¦‚æœä¸æ»¡ $31$ ä½ï¼Œåœ¨æœ€é«˜ä½ä¹‹å‰è¡¥ä¸Šè‹¥å¹²ä¸ªå‰å¯¼ $0$ å³å¯ï¼‰ï¼›\n\n- è¿™ $31$ ä¸ªäºŒè¿›åˆ¶ä½ä»ä½ä½åˆ°é«˜ä½ä¾æ¬¡ç¼–å·ä¸º $0, 1, \\cdots, 30$ã€‚æˆ‘ä»¬ä»æœ€é«˜ä½ç¬¬ $30$ ä¸ªäºŒè¿›åˆ¶ä½å¼€å§‹ï¼Œä¾æ¬¡ç¡®å®š $x$ çš„æ¯ä¸€ä½æ˜¯ $0$ è¿˜æ˜¯ $1$ï¼›\n\n- ç”±äºæˆ‘ä»¬éœ€è¦æ‰¾å‡ºæœ€å¤§çš„ $x$ï¼Œå› æ­¤åœ¨æšä¸¾æ¯ä¸€ä½æ—¶ï¼Œæˆ‘ä»¬å…ˆåˆ¤æ–­ $x$ çš„è¿™ä¸€ä½æ˜¯å¦èƒ½å–åˆ° $1$ã€‚å¦‚æœèƒ½ï¼Œæˆ‘ä»¬å–è¿™ä¸€ä½ä¸º $1$ï¼Œå¦åˆ™æˆ‘ä»¬å–è¿™ä¸€ä½ä¸º $0$ã€‚\n\nã€Œåˆ¤æ–­ $x$ çš„æŸä¸€ä½æ˜¯å¦èƒ½å–åˆ° $1$ã€è¿™ä¸€æ­¥éª¤å¹¶ä¸å®¹æ˜“ã€‚ä¸‹é¢ä»‹ç»ä¸¤ç§åˆ¤æ–­çš„æ–¹æ³•ã€‚\n\n#### æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨\n\n**æ€è·¯ä¸ç®—æ³•**\n\nå‡è®¾æˆ‘ä»¬å·²ç»ç¡®å®šäº† $x$ æœ€é«˜çš„è‹¥å¹²ä¸ªäºŒè¿›åˆ¶ä½ï¼Œå½“å‰æ­£åœ¨ç¡®å®šç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ã€‚æ ¹æ®ã€Œå‰è¨€ã€éƒ¨åˆ†çš„åˆ†æï¼Œæˆ‘ä»¬å¸Œæœ›ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½èƒ½å¤Ÿå–åˆ° $1$ã€‚\n\næˆ‘ä»¬ç”¨ $\\textit{pre}^k(x)$ è¡¨ç¤º $x$ ä»æœ€é«˜ä½ç¬¬ $30$ ä¸ªäºŒè¿›åˆ¶ä½å¼€å§‹ï¼Œåˆ°ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„æ•°ï¼Œé‚£ä¹ˆ $a_j = x \\oplus a_i$ è•´å«ç€ï¼š\n\n$$\n\\textit{pre}^k (a_j) = \\textit{pre}^k (x) \\oplus \\textit{pre}^k (a_i)\n$$\n\nç”±äº $\\textit{pre}^k(x)$ å¯¹äºæˆ‘ä»¬æ¥è¯´æ˜¯å·²çŸ¥çš„ï¼Œå› æ­¤æˆ‘ä»¬å°†æ‰€æœ‰çš„ $\\textit{pre}^k (a_j)$ æ”¾å…¥å“ˆå¸Œè¡¨ä¸­ï¼Œéšåæšä¸¾ $i$ å¹¶è®¡ç®— $\\textit{pre}^k (x) \\oplus \\textit{pre}^k (a_i)$ã€‚å¦‚æœå…¶å‡ºç°åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œé‚£ä¹ˆè¯´æ˜ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½èƒ½å¤Ÿå–åˆ° $1$ï¼Œå¦åˆ™ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º $0$ã€‚\n\næœ¬æ–¹æ³•è‹¥ä»…é˜…è¯»æ–‡å­—ï¼Œç†è§£èµ·æ¥å¯èƒ½è¾ƒä¸ºå›°éš¾ï¼Œè¯»è€…å¯ä»¥å‚è€ƒä¸‹é¢çš„ä»£ç ä»¥åŠæ³¨é‡Šã€‚\n\n**ç»†èŠ‚**\n\nè®¡ç®— $\\textit{pre}^k(x)$ å¯ä»¥ä½¿ç”¨å³ç§»è¿ç®— $\\texttt{>>}$ã€‚\n\n**ä»£ç **\n\n```C++ [sol1-C++]\nclass Solution {\nprivate:\n    // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30\n    static constexpr int HIGH_BIT = 30;\n\npublic:\n    int findMaximumXOR(vector<int>& nums) {\n        int x = 0;\n        for (int k = HIGH_BIT; k >= 0; --k) {\n            unordered_set<int> seen;\n            // å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­\n            for (int num: nums) {\n                // å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n                // åªéœ€å°†å…¶å³ç§» k ä½\n                seen.insert(num >> k);\n            }\n\n            // ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n            // æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1\n            int x_next = x * 2 + 1;\n            bool found = false;\n            \n            // æšä¸¾ i\n            for (int num: nums) {\n                if (seen.count(x_next ^ (num >> k))) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (found) {\n                x = x_next;\n            }\n            else {\n                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0\n                // å³ä¸º x = x*2\n                x = x_next - 1;\n            }\n        }\n        return x;\n    }\n};\n```\n\n```Java [sol1-Java]\nclass Solution {\n    // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30\n    static final int HIGH_BIT = 30;\n\n    public int findMaximumXOR(int[] nums) {\n        int x = 0;\n        for (int k = HIGH_BIT; k >= 0; --k) {\n            Set<Integer> seen = new HashSet<Integer>();\n            // å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­\n            for (int num : nums) {\n                // å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n                // åªéœ€å°†å…¶å³ç§» k ä½\n                seen.add(num >> k);\n            }\n\n            // ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n            // æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1\n            int xNext = x * 2 + 1;\n            boolean found = false;\n            \n            // æšä¸¾ i\n            for (int num : nums) {\n                if (seen.contains(xNext ^ (num >> k))) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (found) {\n                x = xNext;\n            } else {\n                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0\n                // å³ä¸º x = x*2\n                x = xNext - 1;\n            }\n        }\n        return x;\n    }\n}\n```\n\n```C# [sol1-C#]\npublic class Solution {\n    // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30\n    const int HIGH_BIT = 30;\n\n    public int FindMaximumXOR(int[] nums) {\n        int x = 0;\n        for (int k = HIGH_BIT; k >= 0; --k) {\n            ISet<int> seen = new HashSet<int>();\n            // å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­\n            foreach (int num in nums) {\n                // å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n                // åªéœ€å°†å…¶å³ç§» k ä½\n                seen.Add(num >> k);\n            }\n\n            // ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n            // æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1\n            int xNext = x * 2 + 1;\n            bool found = false;\n            \n            // æšä¸¾ i\n            foreach (int num in nums) {\n                if (seen.Contains(xNext ^ (num >> k))) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (found) {\n                x = xNext;\n            } else {\n                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0\n                // å³ä¸º x = x*2\n                x = xNext - 1;\n            }\n        }\n        return x;\n    }\n}\n```\n\n```Python [sol1-Python3]\nclass Solution:\n    def findMaximumXOR(self, nums: List[int]) -> int:\n        # æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30\n        HIGH_BIT = 30\n\n        x = 0\n        for k in range(HIGH_BIT, -1, -1):\n            seen = set()\n            # å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­\n            for num in nums:\n                # å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n                # åªéœ€å°†å…¶å³ç§» k ä½\n                seen.add(num >> k)\n\n            # ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n            # æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1\n            x_next = x * 2 + 1\n            found = False\n            \n            # æšä¸¾ i\n            for num in nums:\n                if x_next ^ (num >> k) in seen:\n                    found = True\n                    break\n\n            if found:\n                x = x_next\n            else:\n                # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0\n                # å³ä¸º x = x*2\n                x = x_next - 1\n        \n        return x\n```\n\n```JavaScript [sol1-JavaScript]\nvar findMaximumXOR = function(nums) {\n    const HIGH_BIT = 30;\n    let x = 0;\n    for (let k = HIGH_BIT; k >= 0; --k) {\n        const seen = new Set();\n        // å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­\n        for (const num of nums) {\n            // å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n            // åªéœ€å°†å…¶å³ç§» k ä½\n            seen.add(num >> k);\n        }\n\n        // ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n        // æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1\n        const xNext = x * 2 + 1;\n        let found = false;\n        \n        // æšä¸¾ i\n        for (const num of nums) {\n            if (seen.has(xNext ^ (num >> k))) {\n                found = true;\n                break;\n            }\n        }\n\n        if (found) {\n            x = xNext;\n        } else {\n            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0\n            // å³ä¸º x = x*2\n            x = xNext - 1;\n        }\n    }\n    return x; \n};\n```\n\n```go [sol1-Golang]\nfunc findMaximumXOR(nums []int) (x int) {\n    const highBit = 30 // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30\n    for k := highBit; k >= 0; k-- {\n        // å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­\n        seen := map[int]bool{}\n        for _, num := range nums {\n            // å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n            // åªéœ€å°†å…¶å³ç§» k ä½\n            seen[num>>k] = true\n        }\n\n        // ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n        // æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1\n        xNext := x*2 + 1\n        found := false\n\n        // æšä¸¾ i\n        for _, num := range nums {\n            if seen[num>>k^xNext] {\n                found = true\n                break\n            }\n        }\n\n        if found {\n            x = xNext\n        } else {\n            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0\n            // å³ä¸º x = x*2\n            x = xNext - 1\n        }\n    }\n    return\n}\n```\n\n```C [sol1-C]\nconst int HIGH_BIT = 30;\n\nstruct HashTable {\n    int key;\n    UT_hash_handle hh;\n};\n\nint findMaximumXOR(int* nums, int numsSize) {\n    int x = 0;\n    for (int k = HIGH_BIT; k >= 0; --k) {\n        struct HashTable* hashTable = NULL;\n        // å°†æ‰€æœ‰çš„ pre^k(a_j) æ”¾å…¥å“ˆå¸Œè¡¨ä¸­\n        for (int i = 0; i < numsSize; i++) {\n            // å¦‚æœåªæƒ³ä¿ç•™ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n            // åªéœ€å°†å…¶å³ç§» k ä½\n            int x = nums[i] >> k;\n            struct HashTable* tmp;\n            HASH_FIND_INT(hashTable, &x, tmp);\n            if (tmp == NULL) {\n                tmp = malloc(sizeof(struct HashTable));\n                tmp->key = x;\n                HASH_ADD_INT(hashTable, key, tmp);\n            }\n        }\n\n        // ç›®å‰ x åŒ…å«ä»æœ€é«˜ä½å¼€å§‹åˆ°ç¬¬ k+1 ä¸ªäºŒè¿›åˆ¶ä½ä¸ºæ­¢çš„éƒ¨åˆ†\n        // æˆ‘ä»¬å°† x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ç½®ä¸º 1ï¼Œå³ä¸º x = x*2+1\n        int x_next = x * 2 + 1;\n        bool found = false;\n\n        // æšä¸¾ i\n        for (int i = 0; i < numsSize; i++) {\n            int x = x_next ^ (nums[i] >> k);\n            struct HashTable* tmp;\n            HASH_FIND_INT(hashTable, &x, tmp);\n            if (tmp != NULL) {\n                found = true;\n                break;\n            }\n        }\n\n        if (found) {\n            x = x_next;\n        } else {\n            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ»¡è¶³ç­‰å¼çš„ a_i å’Œ a_jï¼Œé‚£ä¹ˆ x çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½åªèƒ½ä¸º 0\n            // å³ä¸º x = x*2\n            x = x_next - 1;\n        }\n    }\n    return x;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \\log C)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $\\textit{nums}$ çš„é•¿åº¦ï¼Œ$C$ æ˜¯æ•°ç»„ä¸­çš„å…ƒç´ èŒƒå›´ï¼Œåœ¨æœ¬é¢˜ä¸­ $C < 2^{31}$ã€‚æšä¸¾ç­”æ¡ˆ $x$ çš„æ¯ä¸€ä¸ªäºŒè¿›åˆ¶ä½çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\\log C)$ï¼Œåœ¨æ¯ä¸€æ¬¡æšä¸¾çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ $O(n)$ çš„æ—¶é—´è¿›è¡Œåˆ¤æ–­ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n \\log C)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå³ä¸ºå“ˆå¸Œè¡¨éœ€è¦ä½¿ç”¨çš„ç©ºé—´ã€‚\n\n#### æ–¹æ³•äºŒï¼šå­—å…¸æ ‘\n\n**æ€è·¯ä¸ç®—æ³•**\n\næˆ‘ä»¬ä¹Ÿå¯ä»¥å°†æ•°ç»„ä¸­çš„å…ƒç´ çœ‹æˆé•¿åº¦ä¸º $31$ çš„å­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²ä¸­åªåŒ…å« $0$ å’Œ $1$ã€‚å¦‚æœæˆ‘ä»¬å°†å­—ç¬¦ä¸²æ”¾å…¥å­—å…¸æ ‘ä¸­ï¼Œé‚£ä¹ˆåœ¨å­—å…¸æ ‘ä¸­æŸ¥è¯¢ä¸€ä¸ªå­—ç¬¦ä¸²çš„è¿‡ç¨‹ï¼Œæ°å¥½å°±æ˜¯ä»é«˜ä½å¼€å§‹ç¡®å®šæ¯ä¸€ä¸ªäºŒè¿›åˆ¶ä½çš„è¿‡ç¨‹ã€‚å­—å…¸æ ‘çš„å…·ä½“é€»è¾‘ä»¥åŠå®ç°å¯ä»¥å‚è€ƒã€Œ[208. å®ç° Trieï¼ˆå‰ç¼€æ ‘ï¼‰çš„å®˜æ–¹é¢˜è§£](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/)ã€ï¼Œè¿™é‡Œæˆ‘ä»¬åªè¯´æ˜å¦‚ä½•ä½¿ç”¨å­—å…¸æ ‘è§£å†³æœ¬é¢˜ã€‚\n\næ ¹æ® $x = a_i \\oplus a_j$ï¼Œæˆ‘ä»¬æšä¸¾ $a_i$ï¼Œå¹¶å°† $a_0, a_1, \\cdots, a_{i-1}$ ä½œä¸º $a_j$ æ”¾å…¥å­—å…¸æ ‘ä¸­ï¼Œå¸Œæœ›æ‰¾å‡ºä½¿å¾— $x$ è¾¾åˆ°æœ€å¤§å€¼çš„ $a_j$ã€‚\n\nå¦‚ä½•æ±‚å‡º $x$ å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥ä»å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹å¼€å§‹è¿›è¡Œéå†ï¼Œéå†çš„ã€Œå‚ç…§å¯¹è±¡ã€ä¸º $a_i$ã€‚åœ¨éå†çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬æ ¹æ® $a_i$ çš„ç¬¬ $x$ ä¸ªäºŒè¿›åˆ¶ä½æ˜¯ $0$ è¿˜æ˜¯ $1$ï¼Œç¡®å®šæˆ‘ä»¬åº”å½“èµ°å‘å“ªä¸ªå­èŠ‚ç‚¹ä»¥ç»§ç»­éå†ã€‚å‡è®¾æˆ‘ä»¬å½“å‰éå†åˆ°äº†ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ï¼š\n\n- å¦‚æœ $a_i$ çš„ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸º $0$ï¼Œé‚£ä¹ˆæˆ‘ä»¬åº”å½“å¾€è¡¨ç¤º $1$ çš„å­èŠ‚ç‚¹èµ°ï¼Œè¿™æ · $0 \\oplus 1 = 1$ï¼Œå¯ä»¥ä½¿å¾— $x$ çš„ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸º $1$ã€‚å¦‚æœä¸å­˜åœ¨è¡¨ç¤º $1$ çš„å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªèƒ½å¾€è¡¨ç¤º $0$ çš„å­èŠ‚ç‚¹èµ°ï¼Œ$x$ çš„ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸º $0$ï¼›\n\n- å¦‚æœ $a_i$ çš„ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸º $1$ï¼Œé‚£ä¹ˆæˆ‘ä»¬åº”å½“å¾€è¡¨ç¤º $0$ çš„å­èŠ‚ç‚¹èµ°ï¼Œè¿™æ · $1 \\oplus 0 = 1$ï¼Œå¯ä»¥ä½¿å¾— $x$ çš„ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸º $1$ã€‚å¦‚æœä¸å­˜åœ¨è¡¨ç¤º $0$ çš„å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªèƒ½å¾€è¡¨ç¤º $1$ çš„å­èŠ‚ç‚¹èµ°ï¼Œ$x$ çš„ç¬¬ $k$ ä¸ªäºŒè¿›åˆ¶ä½ä¸º $0$ã€‚\n\nå½“éå†å®Œæ‰€æœ‰çš„ $31$ ä¸ªäºŒè¿›åˆ¶ä½åï¼Œæˆ‘ä»¬ä¹Ÿå°±å¾—åˆ°äº† $a_i$ å¯ä»¥é€šè¿‡å¼‚æˆ–è¿ç®—å¾—åˆ°çš„æœ€å¤§ $x$ã€‚è¿™æ ·ä¸€æ¥ï¼Œå¦‚æœæˆ‘ä»¬æšä¸¾äº†æ‰€æœ‰çš„ $a_i$ï¼Œä¹Ÿå°±å¾—åˆ°äº†æœ€ç»ˆçš„ç­”æ¡ˆã€‚\n\n**ç»†èŠ‚**\n\nç”±äºå­—å…¸æ ‘ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šåªæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œåˆ†åˆ«è¡¨ç¤º $0$ å’Œ $1$ï¼Œå› æ­¤æœ¬é¢˜ä¸­çš„å­—å…¸æ ‘æ˜¯ä¸€æ£µäºŒå‰æ ‘ã€‚åœ¨è®¾è®¡å­—å…¸æ ‘çš„æ•°æ®ç»“æ„æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä»¤å·¦å­èŠ‚ç‚¹ $\\textit{left}$ è¡¨ç¤º $0$ï¼Œå³å­èŠ‚ç‚¹ $\\textit{right}$ è¡¨ç¤º $1$ã€‚\n\n**ä»£ç **\n\nä¸‹é¢çš„ $\\texttt{C++}$ ä»£ç æ²¡æœ‰ææ„å­—å…¸æ ‘çš„ç©ºé—´ã€‚å¦‚æœåœ¨é¢è¯•ä¸­é‡åˆ°äº†æœ¬é¢˜ï¼Œå¯ä»¥å’Œé¢è¯•å®˜è¿›è¡Œæ²Ÿé€šï¼Œè¯¢é—®æ˜¯å¦éœ€è¦ææ„å¯¹åº”çš„ç©ºé—´ã€‚\n\n```C++ [sol2-C++]\nstruct Trie {\n    // å·¦å­æ ‘æŒ‡å‘è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹\n    Trie* left = nullptr;\n    // å³å­æ ‘æŒ‡å‘è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹\n    Trie* right = nullptr;\n\n    Trie() {}\n};\n\nclass Solution {\nprivate:\n    // å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹\n    Trie* root = new Trie();\n    // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30\n    static constexpr int HIGH_BIT = 30;\n\npublic:\n    void add(int num) {\n        Trie* cur = root;\n        for (int k = HIGH_BIT; k >= 0; --k) {\n            int bit = (num >> k) & 1;\n            if (bit == 0) {\n                if (!cur->left) {\n                    cur->left = new Trie();\n                }\n                cur = cur->left;\n            }\n            else {\n                if (!cur->right) {\n                    cur->right = new Trie();\n                }\n                cur = cur->right;\n            }\n        }\n    }\n\n    int check(int num) {\n        Trie* cur = root;\n        int x = 0;\n        for (int k = HIGH_BIT; k >= 0; --k) {\n            int bit = (num >> k) & 1;\n            if (bit == 0) {\n                // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 0ï¼Œåº”å½“å¾€è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹ right èµ°\n                if (cur->right) {\n                    cur = cur->right;\n                    x = x * 2 + 1;\n                }\n                else {\n                    cur = cur->left;\n                    x = x * 2;\n                }\n            }\n            else {\n                // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 1ï¼Œåº”å½“å¾€è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹ left èµ°\n                if (cur->left) {\n                    cur = cur->left;\n                    x = x * 2 + 1;\n                }\n                else {\n                    cur = cur->right;\n                    x = x * 2;\n                }\n            }\n        }\n        return x;\n    }\n\n    int findMaximumXOR(vector<int>& nums) {\n        int n = nums.size();\n        int x = 0;\n        for (int i = 1; i < n; ++i) {\n            // å°† nums[i-1] æ”¾å…¥å­—å…¸æ ‘ï¼Œæ­¤æ—¶ nums[0 .. i-1] éƒ½åœ¨å­—å…¸æ ‘ä¸­\n            add(nums[i - 1]);\n            // å°† nums[i] çœ‹ä½œ aiï¼Œæ‰¾å‡ºæœ€å¤§çš„ x æ›´æ–°ç­”æ¡ˆ\n            x = max(x, check(nums[i]));\n        }\n        return x;\n    }\n};\n```\n\n```Java [sol2-Java]\nclass Solution {\n    // å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹\n    Trie root = new Trie();\n    // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30\n    static final int HIGH_BIT = 30;\n\n    public int findMaximumXOR(int[] nums) {\n        int n = nums.length;\n        int x = 0;\n        for (int i = 1; i < n; ++i) {\n            // å°† nums[i-1] æ”¾å…¥å­—å…¸æ ‘ï¼Œæ­¤æ—¶ nums[0 .. i-1] éƒ½åœ¨å­—å…¸æ ‘ä¸­\n            add(nums[i - 1]);\n            // å°† nums[i] çœ‹ä½œ aiï¼Œæ‰¾å‡ºæœ€å¤§çš„ x æ›´æ–°ç­”æ¡ˆ\n            x = Math.max(x, check(nums[i]));\n        }\n        return x;\n    }\n\n    public void add(int num) {\n        Trie cur = root;\n        for (int k = HIGH_BIT; k >= 0; --k) {\n            int bit = (num >> k) & 1;\n            if (bit == 0) {\n                if (cur.left == null) {\n                    cur.left = new Trie();\n                }\n                cur = cur.left;\n            }\n            else {\n                if (cur.right == null) {\n                    cur.right = new Trie();\n                }\n                cur = cur.right;\n            }\n        }\n    }\n\n    public int check(int num) {\n        Trie cur = root;\n        int x = 0;\n        for (int k = HIGH_BIT; k >= 0; --k) {\n            int bit = (num >> k) & 1;\n            if (bit == 0) {\n                // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 0ï¼Œåº”å½“å¾€è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹ right èµ°\n                if (cur.right != null) {\n                    cur = cur.right;\n                    x = x * 2 + 1;\n                } else {\n                    cur = cur.left;\n                    x = x * 2;\n                }\n            } else {\n                // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 1ï¼Œåº”å½“å¾€è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹ left èµ°\n                if (cur.left != null) {\n                    cur = cur.left;\n                    x = x * 2 + 1;\n                } else {\n                    cur = cur.right;\n                    x = x * 2;\n                }\n            }\n        }\n        return x;\n    }\n}\n\nclass Trie {\n    // å·¦å­æ ‘æŒ‡å‘è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹\n    Trie left = null;\n    // å³å­æ ‘æŒ‡å‘è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹\n    Trie right = null;\n}\n```\n\n```C# [sol2-C#]\npublic class Solution {\n    // å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹\n    Trie root = new Trie();\n    // æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30\n    const int HIGH_BIT = 30;\n\n    public int FindMaximumXOR(int[] nums) {\n        int n = nums.Length;\n        int x = 0;\n        for (int i = 1; i < n; ++i) {\n            // å°† nums[i-1] æ”¾å…¥å­—å…¸æ ‘ï¼Œæ­¤æ—¶ nums[0 .. i-1] éƒ½åœ¨å­—å…¸æ ‘ä¸­\n            Add(nums[i - 1]);\n            // å°† nums[i] çœ‹ä½œ aiï¼Œæ‰¾å‡ºæœ€å¤§çš„ x æ›´æ–°ç­”æ¡ˆ\n            x = Math.Max(x, Check(nums[i]));\n        }\n        return x;\n    }\n\n    public void Add(int num) {\n        Trie cur = root;\n        for (int k = HIGH_BIT; k >= 0; --k) {\n            int bit = (num >> k) & 1;\n            if (bit == 0) {\n                if (cur.left == null) {\n                    cur.left = new Trie();\n                }\n                cur = cur.left;\n            }\n            else {\n                if (cur.right == null) {\n                    cur.right = new Trie();\n                }\n                cur = cur.right;\n            }\n        }\n    }\n\n    public int Check(int num) {\n        Trie cur = root;\n        int x = 0;\n        for (int k = HIGH_BIT; k >= 0; --k) {\n            int bit = (num >> k) & 1;\n            if (bit == 0) {\n                // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 0ï¼Œåº”å½“å¾€è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹ right èµ°\n                if (cur.right != null) {\n                    cur = cur.right;\n                    x = x * 2 + 1;\n                } else {\n                    cur = cur.left;\n                    x = x * 2;\n                }\n            } else {\n                // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 1ï¼Œåº”å½“å¾€è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹ left èµ°\n                if (cur.left != null) {\n                    cur = cur.left;\n                    x = x * 2 + 1;\n                } else {\n                    cur = cur.right;\n                    x = x * 2;\n                }\n            }\n        }\n        return x;\n    }\n}\n\nclass Trie {\n    // å·¦å­æ ‘æŒ‡å‘è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹\n    public Trie left = null;\n    // å³å­æ ‘æŒ‡å‘è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹\n    public Trie right = null;\n}\n```\n\n```Python [sol2-Python3]\nclass Trie:\n    def __init__(self):\n        # å·¦å­æ ‘æŒ‡å‘è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹\n        self.left = None\n        # å³å­æ ‘æŒ‡å‘è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹\n        self.right = None\n\nclass Solution:\n    def findMaximumXOR(self, nums: List[int]) -> int:\n        # å­—å…¸æ ‘çš„æ ¹èŠ‚ç‚¹\n        root = Trie()\n        # æœ€é«˜ä½çš„äºŒè¿›åˆ¶ä½ç¼–å·ä¸º 30\n        HIGH_BIT = 30\n\n        def add(num: int):\n            cur = root\n            for k in range(HIGH_BIT, -1, -1):\n                bit = (num >> k) & 1\n                if bit == 0:\n                    if not cur.left:\n                        cur.left = Trie()\n                    cur = cur.left\n                else:\n                    if not cur.right:\n                        cur.right = Trie()\n                    cur = cur.right\n\n        def check(num: int) -> int:\n            cur = root\n            x = 0\n            for k in range(HIGH_BIT, -1, -1):\n                bit = (num >> k) & 1\n                if bit == 0:\n                    # a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 0ï¼Œåº”å½“å¾€è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹ right èµ°\n                    if cur.right:\n                        cur = cur.right\n                        x = x * 2 + 1\n                    else:\n                        cur = cur.left\n                        x = x * 2\n                else:\n                    # a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 1ï¼Œåº”å½“å¾€è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹ left èµ°\n                    if cur.left:\n                        cur = cur.left\n                        x = x * 2 + 1\n                    else:\n                        cur = cur.right\n                        x = x * 2\n            return x\n\n        n = len(nums)\n        x = 0\n        for i in range(1, n):\n            # å°† nums[i-1] æ”¾å…¥å­—å…¸æ ‘ï¼Œæ­¤æ—¶ nums[0 .. i-1] éƒ½åœ¨å­—å…¸æ ‘ä¸­\n            add(nums[i - 1])\n            # å°† nums[i] çœ‹ä½œ aiï¼Œæ‰¾å‡ºæœ€å¤§çš„ x æ›´æ–°ç­”æ¡ˆ\n            x = max(x, check(nums[i]))\n\n        return x\n```\n\n```go [sol2-Golang]\nconst highBit = 30\n\ntype trie struct {\n    left, right *trie\n}\n\nfunc (t *trie) add(num int) {\n    cur := t\n    for i := highBit; i >= 0; i-- {\n        bit := num >> i & 1\n        if bit == 0 {\n            if cur.left == nil {\n                cur.left = &trie{}\n            }\n            cur = cur.left\n        } else {\n            if cur.right == nil {\n                cur.right = &trie{}\n            }\n            cur = cur.right\n        }\n    }\n}\n\nfunc (t *trie) check(num int) (x int) {\n    cur := t\n    for i := highBit; i >= 0; i-- {\n        bit := num >> i & 1\n        if bit == 0 {\n            // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 0ï¼Œåº”å½“å¾€è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹ right èµ°\n            if cur.right != nil {\n                cur = cur.right\n                x = x*2 + 1\n            } else {\n                cur = cur.left\n                x = x * 2\n            }\n        } else {\n            // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 1ï¼Œåº”å½“å¾€è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹ left èµ°\n            if cur.left != nil {\n                cur = cur.left\n                x = x*2 + 1\n            } else {\n                cur = cur.right\n                x = x * 2\n            }\n        }\n    }\n    return\n}\n\nfunc findMaximumXOR(nums []int) (x int) {\n    root := &trie{}\n    for i := 1; i < len(nums); i++ {\n        // å°† nums[i-1] æ”¾å…¥å­—å…¸æ ‘ï¼Œæ­¤æ—¶ nums[0 .. i-1] éƒ½åœ¨å­—å…¸æ ‘ä¸­\n        root.add(nums[i-1])\n        // å°† nums[i] çœ‹ä½œ aiï¼Œæ‰¾å‡ºæœ€å¤§çš„ x æ›´æ–°ç­”æ¡ˆ\n        x = max(x, root.check(nums[i]))\n    }\n    return\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n```C [sol2-C]\nconst int HIGH_BIT = 30;\n\nstruct Trie {\n    // å·¦å­æ ‘æŒ‡å‘è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹\n    struct Trie* left;\n    // å³å­æ ‘æŒ‡å‘è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹\n    struct Trie* right;\n};\n\nstruct Trie* createTrie() {\n    struct Trie* ret = malloc(sizeof(struct Trie));\n    ret->left = ret->right = NULL;\n    return ret;\n}\n\nvoid add(struct Trie* root, int num) {\n    struct Trie* cur = root;\n    for (int k = HIGH_BIT; k >= 0; --k) {\n        int bit = (num >> k) & 1;\n        if (bit == 0) {\n            if (!cur->left) {\n                cur->left = createTrie();\n            }\n            cur = cur->left;\n        } else {\n            if (!cur->right) {\n                cur->right = createTrie();\n            }\n            cur = cur->right;\n        }\n    }\n}\n\nint check(struct Trie* root, int num) {\n    struct Trie* cur = root;\n    int x = 0;\n    for (int k = HIGH_BIT; k >= 0; --k) {\n        int bit = (num >> k) & 1;\n        if (bit == 0) {\n            // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 0ï¼Œåº”å½“å¾€è¡¨ç¤º 1 çš„å­èŠ‚ç‚¹ right èµ°\n            if (cur->right) {\n                cur = cur->right;\n                x = x * 2 + 1;\n            } else {\n                cur = cur->left;\n                x = x * 2;\n            }\n        } else {\n            // a_i çš„ç¬¬ k ä¸ªäºŒè¿›åˆ¶ä½ä¸º 1ï¼Œåº”å½“å¾€è¡¨ç¤º 0 çš„å­èŠ‚ç‚¹ left èµ°\n            if (cur->left) {\n                cur = cur->left;\n                x = x * 2 + 1;\n            } else {\n                cur = cur->right;\n                x = x * 2;\n            }\n        }\n    }\n    return x;\n}\n\nint findMaximumXOR(int* nums, int numsSize) {\n    struct Trie* root = createTrie();\n    int x = 0;\n    for (int i = 1; i < numsSize; ++i) {\n        // å°† nums[i-1] æ”¾å…¥å­—å…¸æ ‘ï¼Œæ­¤æ—¶ nums[0 .. i-1] éƒ½åœ¨å­—å…¸æ ‘ä¸­\n        add(root, nums[i - 1]);\n        // å°† nums[i] çœ‹ä½œ aiï¼Œæ‰¾å‡ºæœ€å¤§çš„ x æ›´æ–°ç­”æ¡ˆ\n        x = fmax(x, check(root, nums[i]));\n    }\n    return x;\n}\n```\n\n**å¤æ‚åº¦åˆ†æ**\n\n- æ—¶é—´å¤æ‚åº¦ï¼š$O(n \\log C)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„ $\\textit{nums}$ çš„é•¿åº¦ï¼Œ$C$ æ˜¯æ•°ç»„ä¸­çš„å…ƒç´ èŒƒå›´ï¼Œåœ¨æœ¬é¢˜ä¸­ $C < 2^{31}$ã€‚æˆ‘ä»¬éœ€è¦å°† $a_0$ åˆ° $a_{n-2}$ åŠ å…¥å­—å…¸æ ‘ä¸­ï¼Œå¹¶ä¸”éœ€è¦ä»¥ $a_1$ åˆ° $a_{n-1}$ ä½œä¸ºã€Œå‚ç…§å¯¹è±¡ã€åœ¨å­—å…¸æ ‘ä¸Šè¿›è¡Œéå†ï¼Œæ¯ä¸€é¡¹æ“ä½œçš„å•æ¬¡æ—¶é—´å¤æ‚åº¦ä¸º $O(\\log C)$ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n \\log C)$ã€‚\n\n- ç©ºé—´å¤æ‚åº¦ï¼š$O(n \\log C)$ã€‚æ¯ä¸€ä¸ªå…ƒç´ åœ¨å­—å…¸æ ‘ä¸­éœ€è¦ä½¿ç”¨ $O(\\log C)$ çš„ç©ºé—´ï¼Œå› æ­¤æ€»ç©ºé—´å¤æ‚åº¦ä¸º $O(n \\log C)$ã€‚",
      "createdAt": "2021-11-08T03:46:11.198000+00:00",
      "hitCount": 499,
      "identifier": "mfb6OZ",
      "isEditorsPick": false,
      "isMostPopular": false,
      "isMyFavorite": false,
      "next": {
        "__typename": "BriefSolutionNode",
        "slug": "offerii067zui-da-de-yi-huo-by-logilong-jmiv",
        "title": "ğŸ—¡â˜Offerâ…¡067.æœ€å¤§çš„å¼‚æˆ–"
      },
      "position": 1,
      "prev": null,
      "question": {
        "__typename": "QuestionNode",
        "questionTitleSlug": "ms70jA"
      },
      "reactionType": null,
      "reactionsV2": [],
      "rewardEnabled": null,
      "slug": "zui-da-de-yi-huo-by-leetcode-solution-hr7m",
      "status": "PUBLISHED",
      "summary": "å‰è¨€ å‡è®¾æˆ‘ä»¬åœ¨æ•°ç»„ä¸­é€‰æ‹©äº†å…ƒç´  $a_i$ å’Œ $a_j$ï¼ˆ$i \\neq j$ï¼‰ï¼Œä½¿å¾—å®ƒä»¬è¾¾åˆ°æœ€å¤§çš„æŒ‰ä½å¼‚æˆ–è¿ç®—ç»“æœ $x$ï¼š x = a_i \\oplus a_j å…¶ä¸­ $\\oplus$ è¡¨ç¤ºæŒ‰ä½å¼‚æˆ–è¿ç®—ã€‚è¦æƒ³æ±‚å‡º $x$ï¼Œä¸€ç§ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨äºŒé‡å¾ªç¯æšä¸¾ $i$ å’Œ $j$ï¼Œä½†è¿™æ ·åšçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2",
      "sunk": false,
      "tags": [
        {
          "__typename": "CommonTagNode",
          "name": "Bit Manipulation",
          "nameTranslated": "ä½è¿ç®—",
          "slug": "bit-manipulation",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Trie",
          "nameTranslated": "å­—å…¸æ ‘",
          "slug": "trie",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Array",
          "nameTranslated": "æ•°ç»„",
          "slug": "array",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Hash Table",
          "nameTranslated": "å“ˆå¸Œè¡¨",
          "slug": "hash-table",
          "tagType": "TOPIC"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C",
          "nameTranslated": "",
          "slug": "c",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C++",
          "nameTranslated": "",
          "slug": "cpp",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "C#",
          "nameTranslated": "",
          "slug": "csharp",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Go",
          "nameTranslated": "",
          "slug": "golang",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Java",
          "nameTranslated": "",
          "slug": "java",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "JavaScript",
          "nameTranslated": "",
          "slug": "javascript",
          "tagType": "LANGUAGE"
        },
        {
          "__typename": "CommonTagNode",
          "name": "Python",
          "nameTranslated": "",
          "slug": "python",
          "tagType": "LANGUAGE"
        }
      ],
      "thumbnail": "",
      "title": "æœ€å¤§çš„å¼‚æˆ–",
      "topic": {
        "__typename": "TopicNode",
        "commentCount": 0,
        "id": 1090301,
        "viewCount": 329
      },
      "uuid": "mfb6OZ",
      "videosInfo": []
    }
  }
}
